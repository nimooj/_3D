#include "stdafx.h"

/*!
*	\brief	미리 계산된 이항계수들 iCj = Bin[i * (i + 1) / 2 + j]
*/
int Bin[78] = {
	1, 
	1, 1, 
	1, 2, 1, 
	1, 3, 3, 1, 
	1, 4, 6, 4, 1,
	1, 5, 10, 10, 5, 1, 
	1, 6, 15, 20, 15, 6, 1, 
	1, 7, 21, 35, 35, 21, 7, 1, 
	1, 8, 28, 56, 70, 56, 28, 8, 1, 
	1, 9, 36, 84, 126, 126, 84, 36, 9, 1,
	1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1,
	1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1
};

/*!
*	\brief	미리 계산된 uniform cubic B-spline (N0(t), N1(t), N2(t), N3(t)) 함수값
*           t = 0.000, 0.001, 0.002, 0.003, ......, 0.997, 0.998, 0.999, 1.000
*/
double CBS_BASIS[1001][4] = {
	{0.16666667f, 0.66666669f, 0.16666667f, 0.00000000f}, {0.16616717f, 0.66666567f, 0.16716717f, 0.00000000f}, {0.16566867f, 0.66666269f, 0.16766867f, 0.00000000f}, {0.16517116f, 0.66665769f, 0.16817115f, 0.00000000f}, {0.16467465f, 0.66665071f, 0.16867463f, 0.00000001f}, {0.16417915f, 0.66664177f, 0.16917911f, 0.00000002f}, {0.16368464f, 0.66663080f, 0.16968456f, 0.00000004f}, {0.16319111f, 0.66661787f, 0.17019100f, 0.00000006f}, {0.16269858f, 0.66660297f, 0.17069842f, 0.00000009f}, {0.16220705f, 0.66658604f, 0.17120680f, 0.00000012f}, {0.16171651f, 0.66656721f, 0.17171617f, 0.00000017f}, {0.16122694f, 0.66654634f, 0.17222650f, 0.00000022f}, {0.16073838f, 0.66652358f, 0.17273781f, 0.00000029f}, {0.16025080f, 0.66649878f, 0.17325008f, 0.00000037f}, {0.15976422f, 0.66647208f, 0.17376330f, 0.00000046f}, {0.15927862f, 0.66644335f, 0.17427748f, 0.00000056f}, {0.15879399f, 0.66641271f, 0.17479262f, 0.00000068f}, {0.15831035f, 0.66638017f, 0.17530872f, 0.00000082f}, {0.15782771f, 0.66634560f, 0.17582576f, 0.00000097f}, {0.15734603f, 0.66630912f, 0.17634374f, 0.00000114f}, 
	{0.15686534f, 0.66627067f, 0.17686267f, 0.00000133f}, {0.15638563f, 0.66623032f, 0.17738254f, 0.00000154f}, {0.15590690f, 0.66618800f, 0.17790335f, 0.00000177f}, {0.15542914f, 0.66614377f, 0.17842509f, 0.00000203f}, {0.15495236f, 0.66609758f, 0.17894776f, 0.00000230f}, {0.15447657f, 0.66604948f, 0.17947136f, 0.00000260f}, {0.15400174f, 0.66599947f, 0.17999588f, 0.00000293f}, {0.15352789f, 0.66594756f, 0.18052132f, 0.00000328f}, {0.15305501f, 0.66589367f, 0.18104769f, 0.00000366f}, {0.15258311f, 0.66583788f, 0.18157497f, 0.00000406f}, {0.15211217f, 0.66578019f, 0.18210317f, 0.00000450f}, {0.15164220f, 0.66572058f, 0.18263228f, 0.00000497f}, {0.15117320f, 0.66565907f, 0.18316229f, 0.00000546f}, {0.15070519f, 0.66559565f, 0.18369320f, 0.00000599f}, {0.15023813f, 0.66553032f, 0.18422502f, 0.00000655f}, {0.14977202f, 0.66546315f, 0.18475774f, 0.00000715f}, {0.14930689f, 0.66539401f, 0.18529135f, 0.00000778f}, {0.14884272f, 0.66532302f, 0.18582584f, 0.00000844f}, {0.14837952f, 0.66525012f, 0.18636124f, 0.00000915f}, {0.14791729f, 0.66517532f, 0.18689752f, 0.00000989f},
	{0.14745601f, 0.66509867f, 0.18743467f, 0.00001067f}, {0.14699568f, 0.66502017f, 0.18797271f, 0.00001149f}, {0.14653632f, 0.66493970f, 0.18851162f, 0.00001235f}, {0.14607792f, 0.66485745f, 0.18905142f, 0.00001325f}, {0.14562048f, 0.66477329f, 0.18959208f, 0.00001420f}, {0.14516398f, 0.66468728f, 0.19013362f, 0.00001519f}, {0.14470845f, 0.66459936f, 0.19067600f, 0.00001622f}, {0.14425386f, 0.66450959f, 0.19121926f, 0.00001730f}, {0.14380024f, 0.66441798f, 0.19176337f, 0.00001843f}, {0.14334756f, 0.66432452f, 0.19230835f, 0.00001961f}, {0.14289583f, 0.66422921f, 0.19285417f, 0.00002083f}, {0.14244506f, 0.66413200f, 0.19340084f, 0.00002211f}, {0.14199524f, 0.66403300f, 0.19394837f, 0.00002343f}, {0.14154635f, 0.66393214f, 0.19449674f, 0.00002481f}, {0.14109842f, 0.66382945f, 0.19504595f, 0.00002624f}, {0.14065143f, 0.66372490f, 0.19559598f, 0.00002773f}, {0.14020540f, 0.66361851f, 0.19614686f, 0.00002927f}, {0.13976030f, 0.66351026f, 0.19669858f, 0.00003087f}, {0.13931616f, 0.66340023f, 0.19725111f, 0.00003252f}, {0.13887294f, 0.66328835f, 0.19780448f, 0.00003423f},
	{0.13843067f, 0.66317469f, 0.19835867f, 0.00003600f}, {0.13798934f, 0.66305918f, 0.19891368f, 0.00003783f}, {0.13754895f, 0.66294187f, 0.19946951f, 0.00003972f}, {0.13710950f, 0.66282272f, 0.20002615f, 0.00004167f}, {0.13667098f, 0.66270179f, 0.20058361f, 0.00004369f}, {0.13623340f, 0.66257900f, 0.20114186f, 0.00004577f}, {0.13579676f, 0.66245443f, 0.20170093f, 0.00004792f}, {0.13536105f, 0.66232806f, 0.20226079f, 0.00005013f}, {0.13492626f, 0.66219991f, 0.20282146f, 0.00005241f}, {0.13449243f, 0.66206992f, 0.20338292f, 0.00005475f}, {0.13405950f, 0.66193819f, 0.20394517f, 0.00005717f}, {0.13362752f, 0.66180462f, 0.20450822f, 0.00005965f}, {0.13319646f, 0.66166931f, 0.20507205f, 0.00006221f}, {0.13276634f, 0.66153222f, 0.20563667f, 0.00006484f}, {0.13233714f, 0.66139328f, 0.20620206f, 0.00006754f}, {0.13190886f, 0.66125262f, 0.20676823f, 0.00007031f}, {0.13148151f, 0.66111016f, 0.20733519f, 0.00007316f}, {0.13105509f, 0.66096598f, 0.20790291f, 0.00007609f}, {0.13062958f, 0.66081995f, 0.20847140f, 0.00007909f}, {0.13020499f, 0.66067219f, 0.20904066f, 0.00008217f},
	{0.12978134f, 0.66052270f, 0.20961067f, 0.00008533f}, {0.12935859f, 0.66037142f, 0.21018146f, 0.00008857f}, {0.12893677f, 0.66021836f, 0.21075299f, 0.00009189f}, {0.12851587f, 0.66006356f, 0.21132527f, 0.00009530f}, {0.12809588f, 0.65990704f, 0.21189833f, 0.00009878f}, {0.12767681f, 0.65974873f, 0.21247211f, 0.00010235f}, {0.12725866f, 0.65958869f, 0.21304664f, 0.00010601f}, {0.12684143f, 0.65942693f, 0.21362191f, 0.00010975f}, {0.12642509f, 0.65926343f, 0.21419793f, 0.00011358f}, {0.12600967f, 0.65909815f, 0.21477468f, 0.00011749f}, {0.12559517f, 0.65893120f, 0.21535218f, 0.00012150f}, {0.12518157f, 0.65876245f, 0.21593039f, 0.00012560f}, {0.12476889f, 0.65859205f, 0.21650933f, 0.00012978f}, {0.12435711f, 0.65841985f, 0.21708900f, 0.00013406f}, {0.12394624f, 0.65824598f, 0.21766938f, 0.00013843f}, {0.12353627f, 0.65807039f, 0.21825048f, 0.00014290f}, {0.12312721f, 0.65789306f, 0.21883230f, 0.00014746f}, {0.12271906f, 0.65771401f, 0.21941485f, 0.00015211f}, {0.12231181f, 0.65753329f, 0.21999808f, 0.00015687f}, {0.12190545f, 0.65735084f, 0.22058202f, 0.00016172f},
	{0.12150000f, 0.65716666f, 0.22116667f, 0.00016667f}, {0.12109545f, 0.65698081f, 0.22175202f, 0.00017172f}, {0.12069181f, 0.65679330f, 0.22233807f, 0.00017687f}, {0.12028905f, 0.65660405f, 0.22292481f, 0.00018212f}, {0.11988720f, 0.65641314f, 0.22351225f, 0.00018748f}, {0.11948624f, 0.65622050f, 0.22410037f, 0.00019294f}, {0.11908617f, 0.65602618f, 0.22468917f, 0.00019850f}, {0.11868700f, 0.65583020f, 0.22527865f, 0.00020417f}, {0.11828872f, 0.65563256f, 0.22586882f, 0.00020995f}, {0.11789133f, 0.65543318f, 0.22645965f, 0.00021584f}, {0.11749484f, 0.65523219f, 0.22705117f, 0.00022183f}, {0.11709923f, 0.65502948f, 0.22764336f, 0.00022794f}, {0.11670452f, 0.65482515f, 0.22823621f, 0.00023415f}, {0.11631069f, 0.65461916f, 0.22882973f, 0.00024048f}, {0.11591775f, 0.65441144f, 0.22942390f, 0.00024692f}, {0.11552569f, 0.65420210f, 0.23001873f, 0.00025348f}, {0.11513452f, 0.65399116f, 0.23061423f, 0.00026015f}, {0.11474424f, 0.65377849f, 0.23121037f, 0.00026694f}, {0.11435483f, 0.65356421f, 0.23180716f, 0.00027384f}, {0.11396631f, 0.65334827f, 0.23240459f, 0.00028086f},
	{0.11357867f, 0.65313071f, 0.23300268f, 0.00028800f}, {0.11319191f, 0.65291148f, 0.23360139f, 0.00029526f}, {0.11280603f, 0.65269059f, 0.23420075f, 0.00030264f}, {0.11242102f, 0.65246814f, 0.23480074f, 0.00031014f}, {0.11203690f, 0.65224397f, 0.23540136f, 0.00031777f}, {0.11165365f, 0.65201825f, 0.23600261f, 0.00032552f}, {0.11127127f, 0.65179086f, 0.23660448f, 0.00033340f}, {0.11088977f, 0.65156186f, 0.23720698f, 0.00034140f}, {0.11050914f, 0.65133125f, 0.23781011f, 0.00034953f}, {0.11012939f, 0.65109903f, 0.23841383f, 0.00035778f}, {0.10975050f, 0.65086520f, 0.23901817f, 0.00036617f}, {0.10937249f, 0.65062976f, 0.23962313f, 0.00037468f}, {0.10899534f, 0.65039265f, 0.24022868f, 0.00038333f}, {0.10861906f, 0.65015399f, 0.24083486f, 0.00039211f}, {0.10824365f, 0.64991373f, 0.24144162f, 0.00040102f}, {0.10786910f, 0.64967185f, 0.24204899f, 0.00041006f}, {0.10749543f, 0.64942843f, 0.24265695f, 0.00041924f}, {0.10712261f, 0.64918339f, 0.24326549f, 0.00042856f}, {0.10675066f, 0.64893675f, 0.24387464f, 0.00043801f}, {0.10637957f, 0.64868850f, 0.24448436f, 0.00044760f},
	{0.10600933f, 0.64843869f, 0.24509467f, 0.00045733f}, {0.10563996f, 0.64818728f, 0.24570556f, 0.00046720f}, {0.10527145f, 0.64793432f, 0.24631703f, 0.00047721f}, {0.10490380f, 0.64767981f, 0.24692908f, 0.00048737f}, {0.10453701f, 0.64742368f, 0.24754168f, 0.00049766f}, {0.10417107f, 0.64716601f, 0.24815486f, 0.00050810f}, {0.10380598f, 0.64690673f, 0.24876860f, 0.00051869f}, {0.10344175f, 0.64664596f, 0.24938291f, 0.00052942f}, {0.10307837f, 0.64638358f, 0.24999778f, 0.00054030f}, {0.10271584f, 0.64611965f, 0.25061321f, 0.00055132f}, {0.10235417f, 0.64585418f, 0.25122917f, 0.00056250f}, {0.10199334f, 0.64558715f, 0.25184569f, 0.00057383f}, {0.10163337f, 0.64531857f, 0.25246277f, 0.00058530f}, {0.10127424f, 0.64504850f, 0.25308040f, 0.00059693f}, {0.10091596f, 0.64477682f, 0.25369853f, 0.00060871f}, {0.10055853f, 0.64450359f, 0.25431722f, 0.00062065f}, {0.10020193f, 0.64422888f, 0.25493646f, 0.00063274f}, {0.09984618f, 0.64395261f, 0.25555623f, 0.00064498f}, {0.09949128f, 0.64367485f, 0.25617653f, 0.00065739f}, {0.09913722f, 0.64339554f, 0.25679734f, 0.00066995f},
	{0.09878401f, 0.64311469f, 0.25741866f, 0.00068267f}, {0.09843162f, 0.64283234f, 0.25804055f, 0.00069555f}, {0.09808008f, 0.64254844f, 0.25866291f, 0.00070859f}, {0.09772938f, 0.64226305f, 0.25928581f, 0.00072179f}, {0.09737951f, 0.64197618f, 0.25990921f, 0.00073516f}, {0.09703048f, 0.64168775f, 0.26053312f, 0.00074869f}, {0.09668229f, 0.64139783f, 0.26115751f, 0.00076238f}, {0.09633493f, 0.64110643f, 0.26178244f, 0.00077624f}, {0.09598840f, 0.64081353f, 0.26240787f, 0.00079027f}, {0.09564270f, 0.64051908f, 0.26303378f, 0.00080447f}, {0.09529784f, 0.64022321f, 0.26366016f, 0.00081883f}, {0.09495380f, 0.63992578f, 0.26428708f, 0.00083337f}, {0.09461059f, 0.63962692f, 0.26491445f, 0.00084807f}, {0.09426822f, 0.63932657f, 0.26554230f, 0.00086295f}, {0.09392667f, 0.63902467f, 0.26617065f, 0.00087800f}, {0.09358594f, 0.63872135f, 0.26679948f, 0.00089323f}, {0.09324604f, 0.63841659f, 0.26742879f, 0.00090863f}, {0.09290697f, 0.63811028f, 0.26805857f, 0.00092421f}, {0.09256871f, 0.63780254f, 0.26868880f, 0.00093996f}, {0.09223128f, 0.63749337f, 0.26931950f, 0.00095589f},
	{0.09189466f, 0.63718271f, 0.26995069f, 0.00097200f}, {0.09155888f, 0.63687056f, 0.27058229f, 0.00098829f}, {0.09122391f, 0.63655698f, 0.27121440f, 0.00100476f}, {0.09088975f, 0.63624191f, 0.27184692f, 0.00102141f}, {0.09055642f, 0.63592541f, 0.27247992f, 0.00103825f}, {0.09022390f, 0.63560748f, 0.27311337f, 0.00105527f}, {0.08989219f, 0.63528812f, 0.27374724f, 0.00107248f}, {0.08956130f, 0.63496727f, 0.27438158f, 0.00108987f}, {0.08923122f, 0.63464504f, 0.27501634f, 0.00110745f}, {0.08890196f, 0.63432133f, 0.27565154f, 0.00112521f}, {0.08857350f, 0.63399619f, 0.27628717f, 0.00114317f}, {0.08824586f, 0.63366961f, 0.27692324f, 0.00116131f}, {0.08791902f, 0.63334161f, 0.27755973f, 0.00117965f}, {0.08759299f, 0.63301224f, 0.27819666f, 0.00119818f}, {0.08726777f, 0.63268137f, 0.27883399f, 0.00121690f}, {0.08694336f, 0.63234913f, 0.27947173f, 0.00123581f}, {0.08661975f, 0.63201547f, 0.28010991f, 0.00125492f}, {0.08629694f, 0.63168037f, 0.28074849f, 0.00127423f}, {0.08597494f, 0.63134390f, 0.28138748f, 0.00129373f}, {0.08565374f, 0.63100600f, 0.28202689f, 0.00131343f},
	{0.08533333f, 0.63066667f, 0.28266668f, 0.00133333f}, {0.08501373f, 0.63032597f, 0.28330687f, 0.00135343f}, {0.08469493f, 0.62998390f, 0.28394747f, 0.00137373f}, {0.08437693f, 0.62964040f, 0.28458846f, 0.00139424f}, {0.08405972f, 0.62929553f, 0.28522983f, 0.00141494f}, {0.08374332f, 0.62894922f, 0.28587162f, 0.00143585f}, {0.08342770f, 0.62860161f, 0.28651378f, 0.00145697f}, {0.08311288f, 0.62825257f, 0.28715631f, 0.00147829f}, {0.08279885f, 0.62790215f, 0.28779921f, 0.00149982f}, {0.08248561f, 0.62755036f, 0.28844252f, 0.00152156f}, {0.08217317f, 0.62719721f, 0.28908616f, 0.00154350f}, {0.08186152f, 0.62684268f, 0.28973022f, 0.00156566f}, {0.08155065f, 0.62648678f, 0.29037461f, 0.00158802f}, {0.08124057f, 0.62612951f, 0.29101938f, 0.00161060f}, {0.08093128f, 0.62577087f, 0.29166451f, 0.00163339f}, {0.08062277f, 0.62541085f, 0.29231000f, 0.00165640f}, {0.08031505f, 0.62504953f, 0.29295585f, 0.00167962f}, {0.08000812f, 0.62468684f, 0.29360202f, 0.00170305f}, {0.07970197f, 0.62432283f, 0.29424855f, 0.00172671f}, {0.07939659f, 0.62395740f, 0.29489544f, 0.00175058f},
	{0.07909200f, 0.62359071f, 0.29554269f, 0.00177467f}, {0.07878819f, 0.62322259f, 0.29619023f, 0.00179898f}, {0.07848516f, 0.62285322f, 0.29683816f, 0.00182351f}, {0.07818291f, 0.62248248f, 0.29748639f, 0.00184826f}, {0.07788143f, 0.62211037f, 0.29813498f, 0.00187324f}, {0.07758074f, 0.62173700f, 0.29878387f, 0.00189844f}, {0.07728080f, 0.62136227f, 0.29943308f, 0.00192386f}, {0.07698166f, 0.62098622f, 0.30008262f, 0.00194951f}, {0.07668328f, 0.62060887f, 0.30073249f, 0.00197539f}, {0.07638567f, 0.62023020f, 0.30138269f, 0.00200150f}, {0.07608883f, 0.61985016f, 0.30203319f, 0.00202783f}, {0.07579277f, 0.61946887f, 0.30268398f, 0.00205440f}, {0.07549748f, 0.61908627f, 0.30333510f, 0.00208119f}, {0.07520295f, 0.61870235f, 0.30398649f, 0.00210822f}, {0.07490919f, 0.61831713f, 0.30463824f, 0.00213548f}, {0.07461619f, 0.61793065f, 0.30529025f, 0.00216298f}, {0.07432396f, 0.61754280f, 0.30594254f, 0.00219071f}, {0.07403249f, 0.61715370f, 0.30659515f, 0.00221868f}, {0.07374179f, 0.61676329f, 0.30724806f, 0.00224688f}, {0.07345185f, 0.61637163f, 0.30790120f, 0.00227532f},
	{0.07316267f, 0.61597866f, 0.30855468f, 0.00230400f}, {0.07287425f, 0.61558443f, 0.30920842f, 0.00233292f}, {0.07258659f, 0.61518896f, 0.30986243f, 0.00236208f}, {0.07229968f, 0.61479211f, 0.31051672f, 0.00239148f}, {0.07201353f, 0.61439407f, 0.31117129f, 0.00242113f}, {0.07172815f, 0.61399472f, 0.31182611f, 0.00245102f}, {0.07144351f, 0.61359417f, 0.31248122f, 0.00248116f}, {0.07115963f, 0.61319232f, 0.31313655f, 0.00251154f}, {0.07087650f, 0.61278915f, 0.31379217f, 0.00254217f}, {0.07059412f, 0.61238480f, 0.31444806f, 0.00257304f}, {0.07031250f, 0.61197919f, 0.31510419f, 0.00260417f}, {0.07003163f, 0.61157233f, 0.31576055f, 0.00263554f}, {0.06975150f, 0.61116421f, 0.31641719f, 0.00266717f}, {0.06947213f, 0.61075485f, 0.31707403f, 0.00269905f}, {0.06919349f, 0.61034423f, 0.31773114f, 0.00273118f}, {0.06891561f, 0.60993236f, 0.31838849f, 0.00276356f}, {0.06863847f, 0.60951930f, 0.31904608f, 0.00279620f}, {0.06836207f, 0.60910499f, 0.31970388f, 0.00282910f}, {0.06808642f, 0.60868943f, 0.32036191f, 0.00286225f}, {0.06781150f, 0.60827267f, 0.32102019f, 0.00289566f},
	{0.06753734f, 0.60785466f, 0.32167867f, 0.00292933f}, {0.06726390f, 0.60743546f, 0.32233739f, 0.00296326f}, {0.06699122f, 0.60701507f, 0.32299632f, 0.00299745f}, {0.06671926f, 0.60659343f, 0.32365546f, 0.00303191f}, {0.06644805f, 0.60617054f, 0.32431480f, 0.00306662f}, {0.06617757f, 0.60574651f, 0.32497436f, 0.00310160f}, {0.06590782f, 0.60532123f, 0.32563412f, 0.00313685f}, {0.06563881f, 0.60489476f, 0.32629409f, 0.00317236f}, {0.06537053f, 0.60446709f, 0.32695428f, 0.00320814f}, {0.06510299f, 0.60403824f, 0.32761461f, 0.00324418f}, {0.06483617f, 0.60360819f, 0.32827517f, 0.00328050f}, {0.06457008f, 0.60317695f, 0.32893592f, 0.00331709f}, {0.06430472f, 0.60274452f, 0.32959688f, 0.00335394f}, {0.06404010f, 0.60231090f, 0.33025798f, 0.00339107f}, {0.06377620f, 0.60187608f, 0.33091927f, 0.00342847f}, {0.06351302f, 0.60144013f, 0.33158073f, 0.00346615f}, {0.06325057f, 0.60100299f, 0.33224237f, 0.00350410f}, {0.06298884f, 0.60056466f, 0.33290422f, 0.00354232f}, {0.06272785f, 0.60012513f, 0.33356619f, 0.00358083f}, {0.06246756f, 0.59968448f, 0.33422837f, 0.00361961f},
	{0.06220800f, 0.59924269f, 0.33489066f, 0.00365867f}, {0.06194916f, 0.59879971f, 0.33555314f, 0.00369801f}, {0.06169104f, 0.59835559f, 0.33621579f, 0.00373763f}, {0.06143364f, 0.59791028f, 0.33687857f, 0.00377753f}, {0.06117695f, 0.59746385f, 0.33754152f, 0.00381772f}, {0.06092098f, 0.59701627f, 0.33820462f, 0.00385819f}, {0.06066572f, 0.59656751f, 0.33886784f, 0.00389894f}, {0.06041119f, 0.59611762f, 0.33953121f, 0.00393998f}, {0.06015736f, 0.59566665f, 0.34019473f, 0.00398131f}, {0.05990424f, 0.59521449f, 0.34085840f, 0.00402293f}, {0.05965184f, 0.59476119f, 0.34152216f, 0.00406483f}, {0.05940014f, 0.59430677f, 0.34218609f, 0.00410703f}, {0.05914915f, 0.59385121f, 0.34285012f, 0.00414951f}, {0.05889887f, 0.59339458f, 0.34351429f, 0.00419229f}, {0.05864931f, 0.59293675f, 0.34417859f, 0.00423536f}, {0.05840044f, 0.59247786f, 0.34484297f, 0.00427873f}, {0.05815228f, 0.59201783f, 0.34550750f, 0.00432239f}, {0.05790482f, 0.59155673f, 0.34617212f, 0.00436635f}, {0.05765807f, 0.59109449f, 0.34683689f, 0.00441060f}, {0.05741202f, 0.59063113f, 0.34750172f, 0.00445515f},
	{0.05716667f, 0.59016669f, 0.34816667f, 0.00450000f}, {0.05692202f, 0.58970112f, 0.34883171f, 0.00454515f}, {0.05667807f, 0.58923447f, 0.34949687f, 0.00459060f}, {0.05643481f, 0.58876675f, 0.35016212f, 0.00463635f}, {0.05619226f, 0.58829790f, 0.35082743f, 0.00468241f}, {0.05595040f, 0.58782798f, 0.35149288f, 0.00472877f}, {0.05570924f, 0.58735698f, 0.35215837f, 0.00477544f}, {0.05546876f, 0.58688492f, 0.35282397f, 0.00482241f}, {0.05522898f, 0.58641171f, 0.35348961f, 0.00486969f}, {0.05498990f, 0.58593750f, 0.35415536f, 0.00491727f}, {0.05475150f, 0.58546221f, 0.35482118f, 0.00496517f}, {0.05451380f, 0.58498579f, 0.35548705f, 0.00501337f}, {0.05427678f, 0.58450836f, 0.35615301f, 0.00506189f}, {0.05404045f, 0.58402985f, 0.35681903f, 0.00511072f}, {0.05380481f, 0.58355027f, 0.35748512f, 0.00515986f}, {0.05356986f, 0.58306962f, 0.35815123f, 0.00520931f}, {0.05333558f, 0.58258790f, 0.35881743f, 0.00525908f}, {0.05310200f, 0.58210522f, 0.35948366f, 0.00530917f}, {0.05286910f, 0.58162141f, 0.36014995f, 0.00535957f}, {0.05263687f, 0.58113658f, 0.36081630f, 0.00541029f},
	{0.05240534f, 0.58065069f, 0.36148268f, 0.00546133f}, {0.05217447f, 0.58016378f, 0.36214909f, 0.00551269f}, {0.05194429f, 0.57967579f, 0.36281556f, 0.00556437f}, {0.05171479f, 0.57918680f, 0.36348206f, 0.00561638f}, {0.05148596f, 0.57869679f, 0.36414856f, 0.00566870f}, {0.05125782f, 0.57820576f, 0.36481512f, 0.00572135f}, {0.05103034f, 0.57771367f, 0.36548170f, 0.00577433f}, {0.05080354f, 0.57722056f, 0.36614829f, 0.00582763f}, {0.05057741f, 0.57672644f, 0.36681491f, 0.00588126f}, {0.05035195f, 0.57623130f, 0.36748153f, 0.00593521f}, {0.05012716f, 0.57573515f, 0.36814818f, 0.00598950f}, {0.04990305f, 0.57523805f, 0.36881483f, 0.00604412f}, {0.04967961f, 0.57473987f, 0.36948147f, 0.00609906f}, {0.04945683f, 0.57424068f, 0.37014815f, 0.00615434f}, {0.04923472f, 0.57374054f, 0.37081483f, 0.00620995f}, {0.04901327f, 0.57323939f, 0.37148151f, 0.00626590f}, {0.04879249f, 0.57273722f, 0.37214816f, 0.00632218f}, {0.04857237f, 0.57223403f, 0.37281480f, 0.00637879f}, {0.04835292f, 0.57172990f, 0.37348145f, 0.00643575f}, {0.04813413f, 0.57122481f, 0.37414807f, 0.00649304f},
	{0.04791600f, 0.57071871f, 0.37481469f, 0.00655067f}, {0.04769854f, 0.57021159f, 0.37548125f, 0.00660864f}, {0.04748172f, 0.56970352f, 0.37614784f, 0.00666695f}, {0.04726557f, 0.56919450f, 0.37681437f, 0.00672560f}, {0.04705007f, 0.56868446f, 0.37748089f, 0.00678460f}, {0.04683523f, 0.56817347f, 0.37814736f, 0.00684394f}, {0.04662105f, 0.56766158f, 0.37881380f, 0.00690362f}, {0.04640751f, 0.56714863f, 0.37948021f, 0.00696365f}, {0.04619464f, 0.56663477f, 0.38014656f, 0.00702403f}, {0.04598241f, 0.56611997f, 0.38081291f, 0.00708476f}, {0.04577084f, 0.56560421f, 0.38147917f, 0.00714583f}, {0.04555991f, 0.56508744f, 0.38214540f, 0.00720726f}, {0.04534964f, 0.56456977f, 0.38281158f, 0.00726903f}, {0.04514001f, 0.56405115f, 0.38347769f, 0.00733116f}, {0.04493102f, 0.56353164f, 0.38414374f, 0.00739364f}, {0.04472269f, 0.56301111f, 0.38480973f, 0.00745648f}, {0.04451500f, 0.56248969f, 0.38547567f, 0.00751967f}, {0.04430795f, 0.56196731f, 0.38614154f, 0.00758322f}, {0.04410155f, 0.56144404f, 0.38680732f, 0.00764712f}, {0.04389579f, 0.56091982f, 0.38747305f, 0.00771138f}, 
	{0.04369067f, 0.56039470f, 0.38813868f, 0.00777600f}, {0.04348619f, 0.55986863f, 0.38880423f, 0.00784098f}, {0.04328235f, 0.55934167f, 0.38946971f, 0.00790632f}, {0.04307914f, 0.55881375f, 0.39013511f, 0.00797203f}, {0.04287658f, 0.55828494f, 0.39080039f, 0.00803809f}, {0.04267465f, 0.55775523f, 0.39146563f, 0.00810452f}, {0.04247335f, 0.55722463f, 0.39213073f, 0.00817132f}, {0.04227269f, 0.55669314f, 0.39279574f, 0.00823848f}, {0.04207266f, 0.55616069f, 0.39346066f, 0.00830601f}, {0.04187327f, 0.55562741f, 0.39412546f, 0.00837390f}, {0.04167450f, 0.55509317f, 0.39479017f, 0.00844217f}, {0.04147637f, 0.55455810f, 0.39545476f, 0.00851080f}, {0.04127886f, 0.55402207f, 0.39611927f, 0.00857981f}, {0.04108198f, 0.55348521f, 0.39678362f, 0.00864919f}, {0.04088573f, 0.55294746f, 0.39744788f, 0.00871894f}, {0.04069011f, 0.55240887f, 0.39811200f, 0.00878906f}, {0.04049511f, 0.55186939f, 0.39877599f, 0.00885956f}, {0.04030073f, 0.55132902f, 0.39943987f, 0.00893044f}, {0.04010698f, 0.55078775f, 0.40010360f, 0.00900169f}, {0.03991384f, 0.55024564f, 0.40076721f, 0.00907332f}, 
	{0.03972134f, 0.54970270f, 0.40143067f, 0.00914533f}, {0.03952944f, 0.54915887f, 0.40209401f, 0.00921772f}, {0.03933817f, 0.54861414f, 0.40275720f, 0.00929049f}, {0.03914752f, 0.54806864f, 0.40342024f, 0.00936365f}, {0.03895748f, 0.54752225f, 0.40408313f, 0.00943718f}, {0.03876806f, 0.54697502f, 0.40474585f, 0.00951110f}, {0.03857926f, 0.54642689f, 0.40540844f, 0.00958541f}, {0.03839107f, 0.54587799f, 0.40607089f, 0.00966010f}, {0.03820349f, 0.54532820f, 0.40673316f, 0.00973518f}, {0.03801652f, 0.54477763f, 0.40739524f, 0.00981065f}, {0.03783017f, 0.54422617f, 0.40805718f, 0.00988650f}, {0.03764442f, 0.54367393f, 0.40871894f, 0.00996275f}, {0.03745929f, 0.54312086f, 0.40938053f, 0.01003938f}, {0.03727476f, 0.54256690f, 0.41004196f, 0.01011641f}, {0.03709084f, 0.54201216f, 0.41070318f, 0.01019383f}, {0.03690752f, 0.54145664f, 0.41136426f, 0.01027165f}, {0.03672481f, 0.54090023f, 0.41202512f, 0.01034986f}, {0.03654270f, 0.54034305f, 0.41268581f, 0.01042846f}, {0.03636120f, 0.53978509f, 0.41334629f, 0.01050747f}, {0.03618030f, 0.53922629f, 0.41400656f, 0.01058687f},
	{0.03600000f, 0.53866667f, 0.41466668f, 0.01066667f}, {0.03582030f, 0.53810626f, 0.41532657f, 0.01074687f}, {0.03564120f, 0.53754508f, 0.41598627f, 0.01082747f}, {0.03546270f, 0.53698307f, 0.41664577f, 0.01090847f}, {0.03528479f, 0.53642029f, 0.41730505f, 0.01098988f}, {0.03510748f, 0.53585672f, 0.41796413f, 0.01107169f}, {0.03493077f, 0.53529239f, 0.41862297f, 0.01115390f}, {0.03475464f, 0.53472728f, 0.41928160f, 0.01123652f}, {0.03457912f, 0.53416133f, 0.41994002f, 0.01131955f}, {0.03440418f, 0.53359467f, 0.42059821f, 0.01140299f}, {0.03422983f, 0.53302717f, 0.42125618f, 0.01148683f}, {0.03405608f, 0.53245896f, 0.42191392f, 0.01157109f}, {0.03388291f, 0.53188998f, 0.42257142f, 0.01165576f}, {0.03371034f, 0.53132021f, 0.42322868f, 0.01174083f}, {0.03353834f, 0.53074968f, 0.42388570f, 0.01182632f}, {0.03336694f, 0.53017837f, 0.42454249f, 0.01191223f}, {0.03319612f, 0.52960634f, 0.42519903f, 0.01199855f}, {0.03302588f, 0.52903354f, 0.42585531f, 0.01208529f}, {0.03285623f, 0.52845997f, 0.42651138f, 0.01217244f}, {0.03268716f, 0.52788574f, 0.42716715f, 0.01226001f},
	{0.03251867f, 0.52731067f, 0.42782268f, 0.01234800f}, {0.03235076f, 0.52673489f, 0.42847794f, 0.01243641f}, {0.03218343f, 0.52615839f, 0.42913294f, 0.01252524f}, {0.03201667f, 0.52558118f, 0.42978770f, 0.01261450f}, {0.03185050f, 0.52500319f, 0.43044215f, 0.01270417f}, {0.03168489f, 0.52442449f, 0.43109637f, 0.01279427f}, {0.03151987f, 0.52384508f, 0.43175030f, 0.01288480f}, {0.03135542f, 0.52326494f, 0.43240392f, 0.01297575f}, {0.03119154f, 0.52268404f, 0.43305731f, 0.01306713f}, {0.03102824f, 0.52210248f, 0.43371037f, 0.01315893f}, {0.03086550f, 0.52152020f, 0.43436319f, 0.01325117f}, {0.03070334f, 0.52093720f, 0.43501568f, 0.01334383f}, {0.03054174f, 0.52035344f, 0.43566790f, 0.01343693f}, {0.03038071f, 0.51976907f, 0.43631980f, 0.01353046f}, {0.03022025f, 0.51918393f, 0.43697143f, 0.01362442f}, {0.03006035f, 0.51859814f, 0.43762276f, 0.01371881f}, {0.02990103f, 0.51801163f, 0.43827376f, 0.01381364f}, {0.02974226f, 0.51742440f, 0.43892446f, 0.01390891f}, {0.02958406f, 0.51683652f, 0.43957484f, 0.01400461f}, {0.02942641f, 0.51624793f, 0.44022492f, 0.01410075f},
	{0.02926933f, 0.51565868f, 0.44087467f, 0.01419733f}, {0.02911281f, 0.51506871f, 0.44152412f, 0.01429436f}, {0.02895685f, 0.51447815f, 0.44217324f, 0.01439182f}, {0.02880145f, 0.51388687f, 0.44282201f, 0.01448972f}, {0.02864660f, 0.51329488f, 0.44347048f, 0.01458807f}, {0.02849231f, 0.51270223f, 0.44411862f, 0.01468685f}, {0.02833858f, 0.51210892f, 0.44476643f, 0.01478609f}, {0.02818540f, 0.51151502f, 0.44541386f, 0.01488577f}, {0.02803277f, 0.51092035f, 0.44606099f, 0.01498590f}, {0.02788069f, 0.51032513f, 0.44670776f, 0.01508648f}, {0.02772917f, 0.50972921f, 0.44735417f, 0.01518750f}, {0.02757819f, 0.50913262f, 0.44800025f, 0.01528898f}, {0.02742777f, 0.50853539f, 0.44864598f, 0.01539090f}, {0.02727789f, 0.50793749f, 0.44929135f, 0.01549328f}, {0.02712856f, 0.50733900f, 0.44993636f, 0.01559611f}, {0.02697977f, 0.50673985f, 0.45058101f, 0.01569940f}, {0.02683153f, 0.50614011f, 0.45122528f, 0.01580314f}, {0.02668384f, 0.50553972f, 0.45186919f, 0.01590733f}, {0.02653668f, 0.50493866f, 0.45251274f, 0.01601199f}, {0.02639007f, 0.50433695f, 0.45315588f, 0.01611710f}, 
	{0.02624400f, 0.50373465f, 0.45379868f, 0.01622267f}, {0.02609847f, 0.50313175f, 0.45444110f, 0.01632870f}, {0.02595348f, 0.50252825f, 0.45508313f, 0.01643519f}, {0.02580903f, 0.50192410f, 0.45572475f, 0.01654214f}, {0.02566511f, 0.50131935f, 0.45636600f, 0.01664956f}, {0.02552173f, 0.50071400f, 0.45700687f, 0.01675744f}, {0.02537889f, 0.50010806f, 0.45764732f, 0.01686578f}, {0.02523657f, 0.49950147f, 0.45828742f, 0.01697459f}, {0.02509480f, 0.49889430f, 0.45892707f, 0.01708387f}, {0.02495355f, 0.49828652f, 0.45956632f, 0.01719362f}, {0.02481283f, 0.49767819f, 0.46020517f, 0.01730383f}, {0.02467265f, 0.49706924f, 0.46084362f, 0.01741452f}, {0.02453299f, 0.49645969f, 0.46148166f, 0.01752567f}, {0.02439387f, 0.49584961f, 0.46211925f, 0.01763730f}, {0.02425526f, 0.49523890f, 0.46275648f, 0.01774940f}, {0.02411719f, 0.49462762f, 0.46339324f, 0.01786198f}, {0.02397964f, 0.49401575f, 0.46402961f, 0.01797503f}, {0.02384261f, 0.49340335f, 0.46466550f, 0.01808855f}, {0.02370611f, 0.49279037f, 0.46530101f, 0.01820256f}, {0.02357013f, 0.49217680f, 0.46593606f, 0.01831704f},
	{0.02343467f, 0.49156269f, 0.46657068f, 0.01843200f}, {0.02329973f, 0.49094799f, 0.46720487f, 0.01854744f}, {0.02316531f, 0.49033278f, 0.46783859f, 0.01866336f}, {0.02303140f, 0.48971698f, 0.46847188f, 0.01877977f}, {0.02289802f, 0.48910064f, 0.46910474f, 0.01889665f}, {0.02276514f, 0.48848373f, 0.46973711f, 0.01901402f}, {0.02263279f, 0.48786631f, 0.47036904f, 0.01913188f}, {0.02250095f, 0.48724833f, 0.47100052f, 0.01925022f}, {0.02236962f, 0.48662981f, 0.47163156f, 0.01936905f}, {0.02223881f, 0.48601076f, 0.47226208f, 0.01948836f}, {0.02210850f, 0.48539117f, 0.47289219f, 0.01960817f}, {0.02197871f, 0.48477107f, 0.47352180f, 0.01972846f}, {0.02184942f, 0.48415041f, 0.47415096f, 0.01984925f}, {0.02172064f, 0.48352927f, 0.47477961f, 0.01997053f}, {0.02159237f, 0.48290759f, 0.47540778f, 0.02009230f}, {0.02146460f, 0.48228538f, 0.47603551f, 0.02021456f}, {0.02133735f, 0.48166266f, 0.47666270f, 0.02033732f}, {0.02121059f, 0.48103940f, 0.47728944f, 0.02046058f}, {0.02108434f, 0.48041567f, 0.47791567f, 0.02058433f}, {0.02095858f, 0.47979143f, 0.47854143f, 0.02070859f}, 
	{0.02083333f, 0.47916669f, 0.47916669f, 0.02083333f}, {0.02070859f, 0.47854143f, 0.47979143f, 0.02095858f}, {0.02058434f, 0.47791570f, 0.48041567f, 0.02108433f}, {0.02046058f, 0.47728944f, 0.48103943f, 0.02121059f}, {0.02033732f, 0.47666270f, 0.48166266f, 0.02133735f}, {0.02021456f, 0.47603551f, 0.48228538f, 0.02146460f}, {0.02009230f, 0.47540781f, 0.48290756f, 0.02159237f}, {0.01997052f, 0.47477958f, 0.48352927f, 0.02172064f}, {0.01984925f, 0.47415093f, 0.48415044f, 0.02184942f}, {0.01972846f, 0.47352180f, 0.48477107f, 0.02197871f}, {0.01960817f, 0.47289219f, 0.48539117f, 0.02210850f}, {0.01948836f, 0.47226211f, 0.48601076f, 0.02223880f}, {0.01936904f, 0.47163153f, 0.48662984f, 0.02236963f}, {0.01925022f, 0.47100052f, 0.48724833f, 0.02250095f}, {0.01913188f, 0.47036904f, 0.48786631f, 0.02263279f}, {0.01901402f, 0.46973711f, 0.48848373f, 0.02276514f}, {0.01889665f, 0.46910474f, 0.48910061f, 0.02289801f}, {0.01877976f, 0.46847188f, 0.48971698f, 0.02303141f}, {0.01866336f, 0.46783859f, 0.49033278f, 0.02316531f}, {0.01854744f, 0.46720487f, 0.49094799f, 0.02329973f},
	{0.01843200f, 0.46657071f, 0.49156266f, 0.02343467f}, {0.01831704f, 0.46593603f, 0.49217683f, 0.02357013f}, {0.01820256f, 0.46530101f, 0.49279037f, 0.02370611f}, {0.01808855f, 0.46466550f, 0.49340335f, 0.02384261f}, {0.01797503f, 0.46402961f, 0.49401575f, 0.02397964f}, {0.01786198f, 0.46339327f, 0.49462759f, 0.02411718f}, {0.01774940f, 0.46275645f, 0.49523890f, 0.02425527f}, {0.01763730f, 0.46211925f, 0.49584961f, 0.02439387f}, {0.01752567f, 0.46148166f, 0.49645969f, 0.02453299f}, {0.01741452f, 0.46084362f, 0.49706924f, 0.02467265f}, {0.01730384f, 0.46020520f, 0.49767816f, 0.02481283f}, {0.01719362f, 0.45956632f, 0.49828655f, 0.02495355f}, {0.01708387f, 0.45892707f, 0.49889430f, 0.02509480f}, {0.01697459f, 0.45828742f, 0.49950147f, 0.02523657f}, {0.01686579f, 0.45764735f, 0.50010800f, 0.02537888f}, {0.01675743f, 0.45700684f, 0.50071400f, 0.02552173f}, {0.01664956f, 0.45636600f, 0.50131935f, 0.02566511f}, {0.01654214f, 0.45572475f, 0.50192410f, 0.02580903f}, {0.01643519f, 0.45508313f, 0.50252825f, 0.02595348f}, {0.01632870f, 0.45444110f, 0.50313175f, 0.02609847f}, 
	{0.01622267f, 0.45379865f, 0.50373471f, 0.02624400f}, {0.01611710f, 0.45315588f, 0.50433695f, 0.02639007f}, {0.01601199f, 0.45251274f, 0.50493866f, 0.02653668f}, {0.01590733f, 0.45186919f, 0.50553966f, 0.02668383f}, {0.01580313f, 0.45122525f, 0.50614011f, 0.02683154f}, {0.01569939f, 0.45058098f, 0.50673985f, 0.02697977f}, {0.01559611f, 0.44993636f, 0.50733900f, 0.02712856f}, {0.01549328f, 0.44929135f, 0.50793749f, 0.02727789f}, {0.01539090f, 0.44864598f, 0.50853539f, 0.02742776f}, {0.01528897f, 0.44800025f, 0.50913262f, 0.02757820f}, {0.01518750f, 0.44735417f, 0.50972921f, 0.02772917f}, {0.01508648f, 0.44670776f, 0.51032513f, 0.02788069f}, {0.01498590f, 0.44606099f, 0.51092035f, 0.02803277f}, {0.01488577f, 0.44541389f, 0.51151496f, 0.02818539f}, {0.01478609f, 0.44476640f, 0.51210898f, 0.02833858f}, {0.01468685f, 0.44411862f, 0.51270223f, 0.02849231f}, {0.01458807f, 0.44347048f, 0.51329488f, 0.02864660f}, {0.01448972f, 0.44282204f, 0.51388681f, 0.02880145f}, {0.01439181f, 0.44217321f, 0.51447815f, 0.02895686f}, {0.01429435f, 0.44152412f, 0.51506877f, 0.02911282f},
	{0.01419733f, 0.44087467f, 0.51565868f, 0.02926933f}, {0.01410075f, 0.44022492f, 0.51624793f, 0.02942641f}, {0.01400461f, 0.43957487f, 0.51683652f, 0.02958405f}, {0.01390891f, 0.43892443f, 0.51742440f, 0.02974226f}, {0.01381364f, 0.43827376f, 0.51801163f, 0.02990103f}, {0.01371881f, 0.43762276f, 0.51859814f, 0.03006035f}, {0.01362442f, 0.43697143f, 0.51918393f, 0.03022025f}, {0.01353046f, 0.43631983f, 0.51976901f, 0.03038071f}, {0.01343693f, 0.43566787f, 0.52035350f, 0.03054174f}, {0.01334383f, 0.43501568f, 0.52093720f, 0.03070334f}, {0.01325117f, 0.43436319f, 0.52152020f, 0.03086550f}, {0.01315893f, 0.43371040f, 0.52210248f, 0.03102823f}, {0.01306712f, 0.43305728f, 0.52268410f, 0.03119155f}, {0.01297575f, 0.43240392f, 0.52326494f, 0.03135542f}, {0.01288480f, 0.43175030f, 0.52384508f, 0.03151987f}, {0.01279427f, 0.43109637f, 0.52442449f, 0.03168489f}, {0.01270417f, 0.43044218f, 0.52500319f, 0.03185049f}, {0.01261449f, 0.42978770f, 0.52558118f, 0.03201668f}, {0.01252524f, 0.42913294f, 0.52615839f, 0.03218343f}, {0.01243641f, 0.42847794f, 0.52673489f, 0.03235076f}, 
	{0.01234800f, 0.42782268f, 0.52731067f, 0.03251867f}, {0.01226001f, 0.42716718f, 0.52788568f, 0.03268715f}, {0.01217244f, 0.42651135f, 0.52846003f, 0.03285623f}, {0.01208529f, 0.42585531f, 0.52903354f, 0.03302588f}, {0.01199855f, 0.42519903f, 0.52960634f, 0.03319612f}, {0.01191223f, 0.42454252f, 0.53017837f, 0.03336693f}, {0.01182632f, 0.42388570f, 0.53074968f, 0.03353835f}, {0.01174083f, 0.42322868f, 0.53132021f, 0.03371034f}, {0.01165576f, 0.42257142f, 0.53188998f, 0.03388291f}, {0.01157109f, 0.42191392f, 0.53245896f, 0.03405608f}, {0.01148684f, 0.42125618f, 0.53302717f, 0.03422983f}, {0.01140299f, 0.42059821f, 0.53359467f, 0.03440418f}, {0.01131955f, 0.41994002f, 0.53416133f, 0.03457912f}, {0.01123652f, 0.41928160f, 0.53472728f, 0.03475464f}, {0.01115390f, 0.41862297f, 0.53529239f, 0.03493076f}, {0.01107169f, 0.41796410f, 0.53585678f, 0.03510749f}, {0.01098988f, 0.41730502f, 0.53642035f, 0.03528479f}, {0.01090847f, 0.41664577f, 0.53698307f, 0.03546270f}, {0.01082747f, 0.41598627f, 0.53754508f, 0.03564120f}, {0.01074687f, 0.41532660f, 0.53810626f, 0.03582030f},
	{0.01066666f, 0.41466665f, 0.53866673f, 0.03600001f}, {0.01058687f, 0.41400656f, 0.53922629f, 0.03618030f}, {0.01050747f, 0.41334629f, 0.53978509f, 0.03636120f}, {0.01042846f, 0.41268581f, 0.54034305f, 0.03654270f}, {0.01034986f, 0.41202512f, 0.54090023f, 0.03672481f}, {0.01027164f, 0.41136423f, 0.54145664f, 0.03690752f}, {0.01019383f, 0.41070318f, 0.54201216f, 0.03709084f}, {0.01011641f, 0.41004196f, 0.54256690f, 0.03727476f}, {0.01003938f, 0.40938056f, 0.54312080f, 0.03745928f}, {0.00996274f, 0.40871891f, 0.54367393f, 0.03764443f}, {0.00988650f, 0.40805718f, 0.54422617f, 0.03783017f}, {0.00981065f, 0.40739524f, 0.54477763f, 0.03801652f}, {0.00973518f, 0.40673316f, 0.54532820f, 0.03820349f}, {0.00966010f, 0.40607089f, 0.54587799f, 0.03839106f}, {0.00958541f, 0.40540844f, 0.54642695f, 0.03857926f}, {0.00951110f, 0.40474585f, 0.54697502f, 0.03876806f}, {0.00943718f, 0.40408313f, 0.54752225f, 0.03895748f}, {0.00936365f, 0.40342024f, 0.54806864f, 0.03914752f}, {0.00929050f, 0.40275723f, 0.54861414f, 0.03933817f}, {0.00921772f, 0.40209401f, 0.54915887f, 0.03952945f},
	{0.00914533f, 0.40143067f, 0.54970270f, 0.03972134f}, {0.00907332f, 0.40076721f, 0.55024564f, 0.03991384f}, {0.00900169f, 0.40010363f, 0.55078775f, 0.04010697f}, {0.00893044f, 0.39943984f, 0.55132902f, 0.04030073f}, {0.00885956f, 0.39877599f, 0.55186939f, 0.04049511f}, {0.00878906f, 0.39811200f, 0.55240887f, 0.04069011f}, {0.00871894f, 0.39744788f, 0.55294746f, 0.04088573f}, {0.00864919f, 0.39678365f, 0.55348521f, 0.04108198f}, {0.00857981f, 0.39611924f, 0.55402213f, 0.04127887f}, {0.00851080f, 0.39545476f, 0.55455810f, 0.04147637f}, {0.00844217f, 0.39479017f, 0.55509317f, 0.04167450f}, {0.00837390f, 0.39412549f, 0.55562741f, 0.04187326f}, {0.00830600f, 0.39346063f, 0.55616069f, 0.04207267f}, {0.00823848f, 0.39279574f, 0.55669314f, 0.04227269f}, {0.00817132f, 0.39213073f, 0.55722463f, 0.04247335f}, {0.00810452f, 0.39146563f, 0.55775523f, 0.04267465f}, {0.00803809f, 0.39080042f, 0.55828494f, 0.04287657f}, {0.00797202f, 0.39013508f, 0.55881375f, 0.04307915f}, {0.00790632f, 0.38946971f, 0.55934167f, 0.04328235f}, {0.00784098f, 0.38880423f, 0.55986863f, 0.04348619f},
	{0.00777600f, 0.38813868f, 0.56039470f, 0.04369067f}, {0.00771138f, 0.38747305f, 0.56091982f, 0.04389578f}, {0.00764712f, 0.38680732f, 0.56144404f, 0.04410155f}, {0.00758322f, 0.38614154f, 0.56196731f, 0.04430795f}, {0.00751967f, 0.38547567f, 0.56248969f, 0.04451500f}, {0.00745648f, 0.38480976f, 0.56301111f, 0.04472268f}, {0.00739364f, 0.38414374f, 0.56353164f, 0.04493103f}, {0.00733116f, 0.38347769f, 0.56405115f, 0.04514001f}, {0.00726903f, 0.38281158f, 0.56456977f, 0.04534964f}, {0.00720726f, 0.38214540f, 0.56508744f, 0.04555991f}, {0.00714584f, 0.38147920f, 0.56560415f, 0.04577083f}, {0.00708476f, 0.38081288f, 0.56611997f, 0.04598241f}, {0.00702403f, 0.38014656f, 0.56663477f, 0.04619464f}, {0.00696365f, 0.37948021f, 0.56714863f, 0.04640751f}, {0.00690362f, 0.37881383f, 0.56766152f, 0.04662104f}, {0.00684394f, 0.37814739f, 0.56817347f, 0.04683523f}, {0.00678460f, 0.37748086f, 0.56868446f, 0.04705007f}, {0.00672560f, 0.37681437f, 0.56919450f, 0.04726557f}, {0.00666695f, 0.37614784f, 0.56970352f, 0.04748172f}, {0.00660864f, 0.37548128f, 0.57021159f, 0.04769853f}, 
	{0.00655067f, 0.37481466f, 0.57071871f, 0.04791601f}, {0.00649304f, 0.37414807f, 0.57122481f, 0.04813413f}, {0.00643575f, 0.37348145f, 0.57172990f, 0.04835292f}, {0.00637879f, 0.37281480f, 0.57223403f, 0.04857237f}, {0.00632218f, 0.37214816f, 0.57273722f, 0.04879249f}, {0.00626589f, 0.37148148f, 0.57323939f, 0.04901328f}, {0.00620995f, 0.37081483f, 0.57374054f, 0.04923472f}, {0.00615434f, 0.37014815f, 0.57424068f, 0.04945683f}, {0.00609906f, 0.36948150f, 0.57473987f, 0.04967960f}, {0.00604411f, 0.36881483f, 0.57523805f, 0.04990306f}, {0.00598950f, 0.36814818f, 0.57573521f, 0.05012717f}, {0.00593521f, 0.36748153f, 0.57623130f, 0.05035195f}, {0.00588126f, 0.36681491f, 0.57672644f, 0.05057741f}, {0.00582763f, 0.36614829f, 0.57722056f, 0.05080353f}, {0.00577433f, 0.36548167f, 0.57771367f, 0.05103035f}, {0.00572135f, 0.36481512f, 0.57820576f, 0.05125782f}, {0.00566870f, 0.36414856f, 0.57869679f, 0.05148596f}, {0.00561638f, 0.36348206f, 0.57918680f, 0.05171479f}, {0.00556438f, 0.36281556f, 0.57967579f, 0.05194429f}, {0.00551269f, 0.36214909f, 0.58016378f, 0.05217448f},
	{0.00546133f, 0.36148268f, 0.58065069f, 0.05240534f}, {0.00541029f, 0.36081630f, 0.58113658f, 0.05263687f}, {0.00535957f, 0.36014998f, 0.58162141f, 0.05286909f}, {0.00530917f, 0.35948366f, 0.58210522f, 0.05310201f}, {0.00525908f, 0.35881743f, 0.58258796f, 0.05333559f}, {0.00520931f, 0.35815123f, 0.58306962f, 0.05356986f}, {0.00515986f, 0.35748512f, 0.58355027f, 0.05380481f}, {0.00511072f, 0.35681903f, 0.58402979f, 0.05404045f}, {0.00506189f, 0.35615301f, 0.58450836f, 0.05427679f}, {0.00501337f, 0.35548705f, 0.58498579f, 0.05451380f}, {0.00496517f, 0.35482118f, 0.58546221f, 0.05475150f}, {0.00491727f, 0.35415536f, 0.58593750f, 0.05498989f}, {0.00486969f, 0.35348964f, 0.58641171f, 0.05522897f}, {0.00482241f, 0.35282394f, 0.58688492f, 0.05546876f}, {0.00477544f, 0.35215837f, 0.58735698f, 0.05570924f}, {0.00472877f, 0.35149288f, 0.58782798f, 0.05595040f}, {0.00468241f, 0.35082746f, 0.58829790f, 0.05619225f}, {0.00463635f, 0.35016209f, 0.58876675f, 0.05643482f}, {0.00459060f, 0.34949687f, 0.58923447f, 0.05667807f}, {0.00454515f, 0.34883171f, 0.58970112f, 0.05692202f}, 
	{0.00450000f, 0.34816667f, 0.59016669f, 0.05716667f}, {0.00445515f, 0.34750175f, 0.59063113f, 0.05741201f}, {0.00441060f, 0.34683686f, 0.59109449f, 0.05765808f}, {0.00436635f, 0.34617212f, 0.59155673f, 0.05790482f}, {0.00432239f, 0.34550750f, 0.59201783f, 0.05815228f}, {0.00427873f, 0.34484300f, 0.59247786f, 0.05840043f}, {0.00423537f, 0.34417862f, 0.59293675f, 0.05864930f}, {0.00419229f, 0.34351429f, 0.59339458f, 0.05889888f}, {0.00414951f, 0.34285012f, 0.59385121f, 0.05914915f}, {0.00410703f, 0.34218609f, 0.59430677f, 0.05940014f}, {0.00406483f, 0.34152219f, 0.59476119f, 0.05965183f}, {0.00402293f, 0.34085837f, 0.59521449f, 0.05990425f}, {0.00398131f, 0.34019473f, 0.59566665f, 0.06015736f}, {0.00393998f, 0.33953121f, 0.59611762f, 0.06041119f}, {0.00389894f, 0.33886784f, 0.59656751f, 0.06066572f}, {0.00385819f, 0.33820462f, 0.59701622f, 0.06092098f}, {0.00381772f, 0.33754152f, 0.59746385f, 0.06117696f}, {0.00377753f, 0.33687857f, 0.59791028f, 0.06143364f}, {0.00373763f, 0.33621579f, 0.59835559f, 0.06169104f}, {0.00369801f, 0.33555317f, 0.59879971f, 0.06194916f},
	{0.00365867f, 0.33489066f, 0.59924269f, 0.06220801f}, {0.00361961f, 0.33422834f, 0.59968454f, 0.06246757f}, {0.00358083f, 0.33356619f, 0.60012513f, 0.06272785f}, {0.00354232f, 0.33290422f, 0.60056466f, 0.06298884f}, {0.00350410f, 0.33224240f, 0.60100299f, 0.06325056f}, {0.00346615f, 0.33158073f, 0.60144013f, 0.06351303f}, {0.00342847f, 0.33091927f, 0.60187608f, 0.06377620f}, {0.00339107f, 0.33025798f, 0.60231090f, 0.06404010f}, {0.00335394f, 0.32959688f, 0.60274452f, 0.06430472f}, {0.00331709f, 0.32893595f, 0.60317695f, 0.06457008f}, {0.00328050f, 0.32827517f, 0.60360819f, 0.06483617f}, {0.00324418f, 0.32761461f, 0.60403824f, 0.06510299f}, {0.00320814f, 0.32695428f, 0.60446709f, 0.06537053f}, {0.00317236f, 0.32629409f, 0.60489476f, 0.06563880f}, {0.00313685f, 0.32563412f, 0.60532123f, 0.06590783f}, {0.00310160f, 0.32497436f, 0.60574651f, 0.06617757f}, {0.00306662f, 0.32431480f, 0.60617054f, 0.06644805f}, {0.00303191f, 0.32365546f, 0.60659343f, 0.06671926f}, {0.00299746f, 0.32299632f, 0.60701501f, 0.06699121f}, {0.00296326f, 0.32233736f, 0.60743546f, 0.06726391f}, 
	{0.00292933f, 0.32167867f, 0.60785466f, 0.06753734f}, {0.00289566f, 0.32102019f, 0.60827267f, 0.06781150f}, {0.00286225f, 0.32036194f, 0.60868943f, 0.06808642f}, {0.00282910f, 0.31970391f, 0.60910499f, 0.06836206f}, {0.00279620f, 0.31904605f, 0.60951930f, 0.06863847f}, {0.00276356f, 0.31838849f, 0.60993236f, 0.06891561f}, {0.00273118f, 0.31773114f, 0.61034423f, 0.06919349f}, {0.00269905f, 0.31707406f, 0.61075479f, 0.06947212f}, {0.00266717f, 0.31641716f, 0.61116421f, 0.06975151f}, {0.00263554f, 0.31576055f, 0.61157233f, 0.07003163f}, {0.00260417f, 0.31510419f, 0.61197919f, 0.07031250f}, {0.00257304f, 0.31444806f, 0.61238480f, 0.07059412f}, {0.00254217f, 0.31379220f, 0.61278915f, 0.07087649f}, {0.00251154f, 0.31313655f, 0.61319232f, 0.07115964f}, {0.00248116f, 0.31248119f, 0.61359417f, 0.07144351f}, {0.00245102f, 0.31182611f, 0.61399472f, 0.07172815f}, {0.00242113f, 0.31117129f, 0.61439407f, 0.07201353f}, {0.00239148f, 0.31051672f, 0.61479217f, 0.07229969f}, {0.00236208f, 0.30986243f, 0.61518896f, 0.07258659f}, {0.00233292f, 0.30920842f, 0.61558443f, 0.07287425f},
	{0.00230400f, 0.30855468f, 0.61597866f, 0.07316267f}, {0.00227532f, 0.30790123f, 0.61637163f, 0.07345184f}, {0.00224688f, 0.30724803f, 0.61676335f, 0.07374179f}, {0.00221868f, 0.30659515f, 0.61715370f, 0.07403250f}, {0.00219071f, 0.30594254f, 0.61754280f, 0.07432396f}, {0.00216298f, 0.30529025f, 0.61793059f, 0.07461619f}, {0.00213548f, 0.30463824f, 0.61831713f, 0.07490918f}, {0.00210822f, 0.30398649f, 0.61870235f, 0.07520295f}, {0.00208119f, 0.30333510f, 0.61908627f, 0.07549748f}, {0.00205440f, 0.30268398f, 0.61946887f, 0.07579277f}, {0.00202783f, 0.30203319f, 0.61985016f, 0.07608883f}, {0.00200150f, 0.30138266f, 0.62023020f, 0.07638568f}, {0.00197539f, 0.30073249f, 0.62060887f, 0.07668328f}, {0.00194951f, 0.30008262f, 0.62098622f, 0.07698166f}, {0.00192386f, 0.29943308f, 0.62136227f, 0.07728080f}, {0.00189844f, 0.29878387f, 0.62173700f, 0.07758073f}, {0.00187324f, 0.29813495f, 0.62211043f, 0.07788144f}, {0.00184826f, 0.29748639f, 0.62248248f, 0.07818291f}, {0.00182351f, 0.29683816f, 0.62285322f, 0.07848516f}, {0.00179898f, 0.29619026f, 0.62322259f, 0.07878819f}, 
	{0.00177467f, 0.29554269f, 0.62359065f, 0.07909200f}, {0.00175058f, 0.29489544f, 0.62395740f, 0.07939660f}, {0.00172671f, 0.29424855f, 0.62432283f, 0.07970197f}, {0.00170305f, 0.29360202f, 0.62468684f, 0.08000811f}, {0.00167962f, 0.29295585f, 0.62504953f, 0.08031505f}, {0.00165640f, 0.29230997f, 0.62541085f, 0.08062278f}, {0.00163339f, 0.29166448f, 0.62577087f, 0.08093128f}, {0.00161060f, 0.29101938f, 0.62612951f, 0.08124057f}, {0.00158802f, 0.29037461f, 0.62648672f, 0.08155064f}, {0.00156566f, 0.28973022f, 0.62684262f, 0.08186150f}, {0.00154350f, 0.28908616f, 0.62719721f, 0.08217318f}, {0.00152155f, 0.28844249f, 0.62755036f, 0.08248562f}, {0.00149982f, 0.28779921f, 0.62790215f, 0.08279885f}, {0.00147829f, 0.28715631f, 0.62825257f, 0.08311287f}, {0.00145697f, 0.28651375f, 0.62860161f, 0.08342771f}, {0.00143585f, 0.28587160f, 0.62894922f, 0.08374332f}, {0.00141494f, 0.28522983f, 0.62929553f, 0.08405972f}, {0.00139424f, 0.28458846f, 0.62964040f, 0.08437693f}, {0.00137374f, 0.28394750f, 0.62998390f, 0.08469493f}, {0.00135343f, 0.28330687f, 0.63032597f, 0.08501375f},
	{0.00133333f, 0.28266665f, 0.63066667f, 0.08533334f}, {0.00131343f, 0.28202689f, 0.63100600f, 0.08565374f}, {0.00129373f, 0.28138748f, 0.63134390f, 0.08597493f}, {0.00127423f, 0.28074852f, 0.63168037f, 0.08629693f}, {0.00125492f, 0.28010988f, 0.63201547f, 0.08661975f}, {0.00123581f, 0.27947173f, 0.63234913f, 0.08694336f}, {0.00121690f, 0.27883399f, 0.63268137f, 0.08726777f}, {0.00119818f, 0.27819666f, 0.63301224f, 0.08759299f}, {0.00117965f, 0.27755973f, 0.63334161f, 0.08791903f}, {0.00116131f, 0.27692324f, 0.63366961f, 0.08824586f}, {0.00114317f, 0.27628717f, 0.63399619f, 0.08857350f}, {0.00112521f, 0.27565154f, 0.63432133f, 0.08890195f}, {0.00110745f, 0.27501637f, 0.63464499f, 0.08923122f}, {0.00108987f, 0.27438155f, 0.63496727f, 0.08956131f}, {0.00107248f, 0.27374724f, 0.63528812f, 0.08989219f}, {0.00105527f, 0.27311337f, 0.63560748f, 0.09022390f}, {0.00103825f, 0.27247992f, 0.63592541f, 0.09055641f}, {0.00102141f, 0.27184695f, 0.63624191f, 0.09088974f}, {0.00100476f, 0.27121437f, 0.63655698f, 0.09122392f}, {0.00098829f, 0.27058229f, 0.63687056f, 0.09155888f}, 
	{0.00097200f, 0.26995069f, 0.63718271f, 0.09189466f}, {0.00095589f, 0.26931950f, 0.63749337f, 0.09223127f}, {0.00093996f, 0.26868877f, 0.63780254f, 0.09256872f}, {0.00092421f, 0.26805854f, 0.63811028f, 0.09290697f}, {0.00090863f, 0.26742879f, 0.63841659f, 0.09324604f}, {0.00089323f, 0.26679948f, 0.63872135f, 0.09358594f}, {0.00087800f, 0.26617068f, 0.63902467f, 0.09392666f}, {0.00086295f, 0.26554230f, 0.63932657f, 0.09426823f}, {0.00084807f, 0.26491445f, 0.63962692f, 0.09461059f}, {0.00083337f, 0.26428708f, 0.63992578f, 0.09495380f}, {0.00081883f, 0.26366019f, 0.64022321f, 0.09529783f}, {0.00080447f, 0.26303378f, 0.64051908f, 0.09564269f}, {0.00079027f, 0.26240784f, 0.64081353f, 0.09598840f}, {0.00077624f, 0.26178244f, 0.64110643f, 0.09633493f}, {0.00076238f, 0.26115754f, 0.64139783f, 0.09668228f}, {0.00074869f, 0.26053312f, 0.64168775f, 0.09703048f}, {0.00073516f, 0.25990918f, 0.64197618f, 0.09737952f}, {0.00072179f, 0.25928581f, 0.64226305f, 0.09772938f}, {0.00070859f, 0.25866291f, 0.64254844f, 0.09808008f}, {0.00069555f, 0.25804055f, 0.64283234f, 0.09843162f},
	{0.00068267f, 0.25741869f, 0.64311469f, 0.09878399f}, {0.00066995f, 0.25679731f, 0.64339554f, 0.09913723f}, {0.00065739f, 0.25617650f, 0.64367485f, 0.09949128f}, {0.00064498f, 0.25555623f, 0.64395261f, 0.09984618f}, {0.00063274f, 0.25493649f, 0.64422888f, 0.10020193f}, {0.00062065f, 0.25431722f, 0.64450365f, 0.10055853f}, {0.00060871f, 0.25369853f, 0.64477682f, 0.10091596f}, {0.00059693f, 0.25308040f, 0.64504850f, 0.10127424f}, {0.00058530f, 0.25246277f, 0.64531857f, 0.10163336f}, {0.00057383f, 0.25184572f, 0.64558715f, 0.10199334f}, {0.00056250f, 0.25122917f, 0.64585418f, 0.10235418f}, {0.00055132f, 0.25061318f, 0.64611965f, 0.10271585f}, {0.00054030f, 0.24999778f, 0.64638358f, 0.10307837f}, {0.00052942f, 0.24938293f, 0.64664596f, 0.10344175f}, {0.00051869f, 0.24876863f, 0.64690673f, 0.10380597f}, {0.00050810f, 0.24815485f, 0.64716601f, 0.10417107f}, {0.00049766f, 0.24754168f, 0.64742368f, 0.10453701f}, {0.00048737f, 0.24692908f, 0.64767981f, 0.10490380f}, {0.00047721f, 0.24631704f, 0.64793432f, 0.10527145f}, {0.00046720f, 0.24570554f, 0.64818728f, 0.10563998f}, 
	{0.00045733f, 0.24509467f, 0.64843869f, 0.10600934f}, {0.00044760f, 0.24448436f, 0.64868850f, 0.10637957f}, {0.00043801f, 0.24387464f, 0.64893675f, 0.10675065f}, {0.00042856f, 0.24326551f, 0.64918333f, 0.10712260f}, {0.00041924f, 0.24265693f, 0.64942843f, 0.10749543f}, {0.00041006f, 0.24204898f, 0.64967185f, 0.10786911f}, {0.00040102f, 0.24144162f, 0.64991373f, 0.10824365f}, {0.00039211f, 0.24083486f, 0.65015399f, 0.10861906f}, {0.00038333f, 0.24022871f, 0.65039265f, 0.10899533f}, {0.00037468f, 0.23962311f, 0.65062976f, 0.10937250f}, {0.00036617f, 0.23901817f, 0.65086520f, 0.10975050f}, {0.00035778f, 0.23841384f, 0.65109903f, 0.11012939f}, {0.00034953f, 0.23781011f, 0.65133125f, 0.11050913f}, {0.00034140f, 0.23720697f, 0.65156186f, 0.11088978f}, {0.00033340f, 0.23660448f, 0.65179086f, 0.11127128f}, {0.00032552f, 0.23600261f, 0.65201825f, 0.11165365f}, {0.00031777f, 0.23540136f, 0.65224397f, 0.11203689f}, {0.00031014f, 0.23480076f, 0.65246809f, 0.11242101f}, {0.00030264f, 0.23420073f, 0.65269059f, 0.11280604f}, {0.00029526f, 0.23360139f, 0.65291148f, 0.11319191f},
	{0.00028800f, 0.23300268f, 0.65313071f, 0.11357867f}, {0.00028086f, 0.23240460f, 0.65334827f, 0.11396630f}, {0.00027384f, 0.23180714f, 0.65356421f, 0.11435484f}, {0.00026694f, 0.23121035f, 0.65377849f, 0.11474424f}, {0.00026015f, 0.23061423f, 0.65399116f, 0.11513452f}, {0.00025348f, 0.23001873f, 0.65420210f, 0.11552569f}, {0.00024692f, 0.22942391f, 0.65441144f, 0.11591773f}, {0.00024048f, 0.22882971f, 0.65461916f, 0.11631069f}, {0.00023415f, 0.22823620f, 0.65482515f, 0.11670452f}, {0.00022794f, 0.22764336f, 0.65502948f, 0.11709923f}, {0.00022183f, 0.22705118f, 0.65523219f, 0.11749483f}, {0.00021584f, 0.22645968f, 0.65543318f, 0.11789132f}, {0.00020995f, 0.22586881f, 0.65563256f, 0.11828873f}, {0.00020417f, 0.22527865f, 0.65583020f, 0.11868700f}, {0.00019850f, 0.22468917f, 0.65602618f, 0.11908617f}, {0.00019294f, 0.22410037f, 0.65622050f, 0.11948623f}, {0.00018748f, 0.22351223f, 0.65641314f, 0.11988720f}, {0.00018212f, 0.22292480f, 0.65660405f, 0.12028906f}, {0.00017687f, 0.22233807f, 0.65679330f, 0.12069181f}, {0.00017172f, 0.22175203f, 0.65698081f, 0.12109545f}, 
	{0.00016667f, 0.22116669f, 0.65716666f, 0.12149999f}, {0.00016172f, 0.22058201f, 0.65735084f, 0.12190546f}, {0.00015687f, 0.21999808f, 0.65753329f, 0.12231181f}, {0.00015211f, 0.21941485f, 0.65771401f, 0.12271906f}, {0.00014746f, 0.21883231f, 0.65789306f, 0.12312721f}, {0.00014290f, 0.21825050f, 0.65807039f, 0.12353627f}, {0.00013843f, 0.21766937f, 0.65824598f, 0.12394625f}, {0.00013406f, 0.21708900f, 0.65841985f, 0.12435711f}, {0.00012978f, 0.21650933f, 0.65859205f, 0.12476888f}, {0.00012560f, 0.21593040f, 0.65876245f, 0.12518157f}, {0.00012150f, 0.21535216f, 0.65893120f, 0.12559518f}, {0.00011749f, 0.21477468f, 0.65909815f, 0.12600969f}, {0.00011358f, 0.21419793f, 0.65926343f, 0.12642509f}, {0.00010975f, 0.21362193f, 0.65942693f, 0.12684141f}, {0.00010601f, 0.21304666f, 0.65958869f, 0.12725864f}, {0.00010235f, 0.21247210f, 0.65974873f, 0.12767683f}, {0.00009878f, 0.21189831f, 0.65990704f, 0.12809590f}, {0.00009530f, 0.21132529f, 0.66006356f, 0.12851587f}, {0.00009189f, 0.21075299f, 0.66021836f, 0.12893677f}, {0.00008857f, 0.21018143f, 0.66037142f, 0.12935860f},
	{0.00008533f, 0.20961067f, 0.66052270f, 0.12978135f}, {0.00008217f, 0.20904066f, 0.66067219f, 0.13020501f}, {0.00007909f, 0.20847140f, 0.66081995f, 0.13062957f}, {0.00007609f, 0.20790292f, 0.66096598f, 0.13105507f}, {0.00007316f, 0.20733517f, 0.66111016f, 0.13148151f}, {0.00007031f, 0.20676823f, 0.66125262f, 0.13190886f}, {0.00006754f, 0.20620206f, 0.66139328f, 0.13233714f}, {0.00006484f, 0.20563667f, 0.66153216f, 0.13276632f}, {0.00006221f, 0.20507206f, 0.66166931f, 0.13319646f}, {0.00005965f, 0.20450820f, 0.66180462f, 0.13362753f}, {0.00005717f, 0.20394517f, 0.66193819f, 0.13405950f}, {0.00005475f, 0.20338292f, 0.66206992f, 0.13449241f}, {0.00005241f, 0.20282146f, 0.66219991f, 0.13492626f}, {0.00005013f, 0.20226078f, 0.66232806f, 0.13536106f}, {0.00004792f, 0.20170091f, 0.66245443f, 0.13579676f}, {0.00004577f, 0.20114186f, 0.66257900f, 0.13623340f}, {0.00004369f, 0.20058361f, 0.66270179f, 0.13667098f}, {0.00004167f, 0.20002617f, 0.66282272f, 0.13710949f}, {0.00003972f, 0.19946949f, 0.66294187f, 0.13754895f}, {0.00003783f, 0.19891368f, 0.66305918f, 0.13798934f}, 
	{0.00003600f, 0.19835867f, 0.66317469f, 0.13843067f}, {0.00003423f, 0.19780450f, 0.66328835f, 0.13887294f}, {0.00003252f, 0.19725113f, 0.66340023f, 0.13931614f}, {0.00003087f, 0.19669856f, 0.66351026f, 0.13976032f}, {0.00002927f, 0.19614686f, 0.66361851f, 0.14020540f}, {0.00002773f, 0.19559599f, 0.66372490f, 0.14065143f}, {0.00002624f, 0.19504595f, 0.66382945f, 0.14109842f}, {0.00002481f, 0.19449672f, 0.66393214f, 0.14154637f}, {0.00002343f, 0.19394836f, 0.66403300f, 0.14199524f}, {0.00002211f, 0.19340084f, 0.66413200f, 0.14244506f}, {0.00002083f, 0.19285418f, 0.66422921f, 0.14289583f}, {0.00001961f, 0.19230837f, 0.66432452f, 0.14334755f}, {0.00001843f, 0.19176337f, 0.66441798f, 0.14380024f}, {0.00001730f, 0.19121926f, 0.66450959f, 0.14425386f}, {0.00001622f, 0.19067600f, 0.66459936f, 0.14470844f}, {0.00001519f, 0.19013362f, 0.66468728f, 0.14516398f}, {0.00001420f, 0.18959209f, 0.66477329f, 0.14562047f}, {0.00001325f, 0.18905140f, 0.66485745f, 0.14607793f}, {0.00001235f, 0.18851162f, 0.66493970f, 0.14653632f}, {0.00001149f, 0.18797271f, 0.66502017f, 0.14699568f},
	{0.00001067f, 0.18743469f, 0.66509867f, 0.14745599f}, {0.00000989f, 0.18689750f, 0.66517532f, 0.14791730f}, {0.00000915f, 0.18636122f, 0.66525012f, 0.14837953f}, {0.00000844f, 0.18582584f, 0.66532302f, 0.14884272f}, {0.00000778f, 0.18529135f, 0.66539401f, 0.14930689f}, {0.00000715f, 0.18475775f, 0.66546315f, 0.14977202f}, {0.00000655f, 0.18422501f, 0.66553032f, 0.15023813f}, {0.00000599f, 0.18369320f, 0.66559565f, 0.15070519f}, {0.00000546f, 0.18316229f, 0.66565907f, 0.15117320f}, {0.00000497f, 0.18263228f, 0.66572058f, 0.15164220f}, {0.00000450f, 0.18210316f, 0.66578019f, 0.15211219f}, {0.00000406f, 0.18157497f, 0.66583788f, 0.15258311f}, {0.00000366f, 0.18104769f, 0.66589367f, 0.15305501f}, {0.00000328f, 0.18052134f, 0.66594756f, 0.15352789f}, {0.00000293f, 0.17999589f, 0.66599947f, 0.15400173f}, {0.00000260f, 0.17947134f, 0.66604948f, 0.15447658f}, {0.00000230f, 0.17894776f, 0.66609758f, 0.15495238f}, {0.00000203f, 0.17842509f, 0.66614377f, 0.15542914f}, {0.00000177f, 0.17790335f, 0.66618800f, 0.15590689f}, {0.00000154f, 0.17738256f, 0.66623032f, 0.15638562f}, 
	{0.00000133f, 0.17686266f, 0.66627067f, 0.15686534f}, {0.00000114f, 0.17634374f, 0.66630912f, 0.15734603f}, {0.00000097f, 0.17582576f, 0.66634560f, 0.15782769f}, {0.00000082f, 0.17530872f, 0.66638017f, 0.15831034f}, {0.00000068f, 0.17479260f, 0.66641271f, 0.15879400f}, {0.00000056f, 0.17427748f, 0.66644335f, 0.15927862f}, {0.00000046f, 0.17376330f, 0.66647208f, 0.15976422f}, {0.00000037f, 0.17325008f, 0.66649878f, 0.16025080f}, {0.00000029f, 0.17273782f, 0.66652358f, 0.16073838f}, {0.00000022f, 0.17222649f, 0.66654634f, 0.16122696f}, {0.00000017f, 0.17171617f, 0.66656721f, 0.16171651f}, {0.00000012f, 0.17120680f, 0.66658604f, 0.16220705f}, {0.00000009f, 0.17069842f, 0.66660297f, 0.16269858f}, {0.00000006f, 0.17019102f, 0.66661787f, 0.16319109f}, {0.00000004f, 0.16968456f, 0.66663080f, 0.16368465f}, {0.00000002f, 0.16917911f, 0.66664177f, 0.16417915f}, {0.00000001f, 0.16867465f, 0.66665071f, 0.16467465f}, {0.00000000f, 0.16817117f, 0.66665769f, 0.16517116f}, {0.00000000f, 0.16766866f, 0.66666269f, 0.16566868f}, {0.00000000f, 0.16716717f, 0.66666567f, 0.16616718f},
	{0.00000000f, 0.16666667f, 0.66666669f, 0.16666667f}};

	/*!
	*	\brief	미리 계산된 uniform cubic B-spline의 미분값(N'0(t), N'1(t), N'2(t), N'3(t)) 함수값
	*           t = 0.000, 0.001, 0.002, 0.003, ......, 0.997, 0.998, 0.999, 1.000
	*/
	double CBS_BASIS_DERIV[1001][4] = {
		{-0.50000000f, -0.00000000f, 0.50000000f, 0.00000000f}, {-0.49900049f, -0.00199850f, 0.50099850f, 0.00000050f}, {-0.49800199f, -0.00399400f, 0.50199401f, 0.00000200f}, {-0.49700451f, -0.00598650f, 0.50298649f, 0.00000450f}, {-0.49600801f, -0.00797600f, 0.50397599f, 0.00000800f}, {-0.49501249f, -0.00996250f, 0.50496250f, 0.00001250f}, {-0.49401799f, -0.01194600f, 0.50594598f, 0.00001800f}, {-0.49302450f, -0.01392650f, 0.50692648f, 0.00002450f}, {-0.49203199f, -0.01590400f, 0.50790399f, 0.00003200f}, {-0.49104050f, -0.01787850f, 0.50887853f, 0.00004050f}, {-0.49004999f, -0.01985000f, 0.50985003f, 0.00005000f}, {-0.48906049f, -0.02181850f, 0.51081848f, 0.00006050f}, {-0.48807201f, -0.02378400f, 0.51178402f, 0.00007200f}, {-0.48708451f, -0.02574650f, 0.51274651f, 0.00008450f}, {-0.48609799f, -0.02770600f, 0.51370603f, 0.00009800f}, {-0.48511249f, -0.02966250f, 0.51466250f, 0.00011250f}, {-0.48412800f, -0.03161600f, 0.51561600f, 0.00012800f}, {-0.48314449f, -0.03356650f, 0.51656651f, 0.00014450f}, {-0.48216200f, -0.03551400f, 0.51751399f, 0.00016200f}, {-0.48118049f, -0.03745850f, 0.51845849f, 0.00018050f}, {-0.48019999f, -0.03940000f, 0.51940000f, 0.00020000f}, {-0.47922051f, -0.04133850f, 0.52033848f, 0.00022050f}, {-0.47824201f, -0.04327400f, 0.52127397f, 0.00024200f}, {-0.47726449f, -0.04520650f, 0.52220649f, 0.00026450f}, {-0.47628799f, -0.04713600f, 0.52313602f, 0.00028800f}, {-0.47531250f, -0.04906250f, 0.52406251f, 0.00031250f}, {-0.47433800f, -0.05098600f, 0.52498603f, 0.00033800f}, {-0.47336450f, -0.05290650f, 0.52590650f, 0.00036450f}, {-0.47239199f, -0.05482400f, 0.52682400f, 0.00039200f}, {-0.47142050f, -0.05673850f, 0.52773851f, 0.00042050f}, {-0.47045001f, -0.05865000f, 0.52864999f, 0.00045000f}, {-0.46948051f, -0.06055850f, 0.52955848f, 0.00048050f}, {-0.46851200f, -0.06246400f, 0.53046399f, 0.00051200f}, {-0.46754450f, -0.06436650f, 0.53136653f, 0.00054450f}, {-0.46657801f, -0.06626600f, 0.53226602f, 0.00057800f}, {-0.46561250f, -0.06816250f, 0.53316247f, 0.00061250f},
		{-0.46464801f, -0.07005600f, 0.53405601f, 0.00064800f}, {-0.46368450f, -0.07194650f, 0.53494650f, 0.00068450f}, {-0.46272200f, -0.07383399f, 0.53583401f, 0.00072200f}, {-0.46176049f, -0.07571850f, 0.53671849f, 0.00076050f}, {-0.46079999f, -0.07759999f, 0.53759998f, 0.00080000f}, {-0.45984051f, -0.07947850f, 0.53847849f, 0.00084050f}, {-0.45888200f, -0.08135400f, 0.53935403f, 0.00088200f}, {-0.45792449f, -0.08322650f, 0.54022652f, 0.00092450f}, {-0.45696801f, -0.08509600f, 0.54109597f, 0.00096800f}, {-0.45601249f, -0.08696251f, 0.54196250f, 0.00101250f}, {-0.45505801f, -0.08882600f, 0.54282600f, 0.00105800f}, {-0.45410451f, -0.09068650f, 0.54368651f, 0.00110450f}, {-0.45315200f, -0.09254400f, 0.54454398f, 0.00115200f}, {-0.45220050f, -0.09439850f, 0.54539847f, 0.00120050f}, {-0.45124999f, -0.09625001f, 0.54624999f, 0.00125000f}, {-0.45030051f, -0.09809850f, 0.54709852f, 0.00130050f}, {-0.44935200f, -0.09994400f, 0.54794401f, 0.00135200f}, {-0.44840449f, -0.10178650f, 0.54878652f, 0.00140450f}, {-0.44745800f, -0.10362601f, 0.54962599f, 0.00145800f}, {-0.44651249f, -0.10546250f, 0.55046248f, 0.00151250f}, {-0.44556800f, -0.10729600f, 0.55129600f, 0.00156800f}, {-0.44462451f, -0.10912650f, 0.55212653f, 0.00162450f}, {-0.44368201f, -0.11095399f, 0.55295402f, 0.00168200f}, {-0.44274050f, -0.11277850f, 0.55377853f, 0.00174050f}, {-0.44180000f, -0.11460000f, 0.55460000f, 0.00180000f}, {-0.44086051f, -0.11641850f, 0.55541849f, 0.00186050f}, {-0.43992200f, -0.11823400f, 0.55623400f, 0.00192200f}, {-0.43898451f, -0.12004650f, 0.55704647f, 0.00198450f}, {-0.43804801f, -0.12185600f, 0.55785602f, 0.00204800f}, {-0.43711251f, -0.12366249f, 0.55866247f, 0.00211250f}, {-0.43617800f, -0.12546600f, 0.55946600f, 0.00217800f}, {-0.43524450f, -0.12726650f, 0.56026649f, 0.00224450f}, {-0.43431199f, -0.12906401f, 0.56106400f, 0.00231200f}, {-0.43338051f, -0.13085850f, 0.56185848f, 0.00238050f}, {-0.43245000f, -0.13265000f, 0.56265002f, 0.00245000f}, {-0.43152049f, -0.13443850f, 0.56343848f, 0.00252050f},
		{-0.43059200f, -0.13622400f, 0.56422400f, 0.00259200f}, {-0.42966449f, -0.13800649f, 0.56500649f, 0.00266450f}, {-0.42873800f, -0.13978601f, 0.56578600f, 0.00273800f}, {-0.42781249f, -0.14156251f, 0.56656247f, 0.00281250f}, {-0.42688799f, -0.14333600f, 0.56733602f, 0.00288800f}, {-0.42596450f, -0.14510649f, 0.56810647f, 0.00296450f}, {-0.42504200f, -0.14687400f, 0.56887400f, 0.00304200f}, {-0.42412049f, -0.14863850f, 0.56963849f, 0.00312050f}, {-0.42320001f, -0.15040000f, 0.57040000f, 0.00320000f}, {-0.42228049f, -0.15215850f, 0.57115853f, 0.00328050f}, {-0.42136201f, -0.15391400f, 0.57191402f, 0.00336200f}, {-0.42044449f, -0.15566650f, 0.57266653f, 0.00344450f}, {-0.41952801f, -0.15741600f, 0.57341599f, 0.00352800f}, {-0.41861251f, -0.15916251f, 0.57416248f, 0.00361250f}, {-0.41769800f, -0.16090600f, 0.57490599f, 0.00369800f}, {-0.41678450f, -0.16264650f, 0.57564652f, 0.00378450f}, {-0.41587201f, -0.16438399f, 0.57638401f, 0.00387200f}, {-0.41496050f, -0.16611850f, 0.57711852f, 0.00396050f}, {-0.41404998f, -0.16785000f, 0.57784998f, 0.00405000f}, {-0.41314051f, -0.16957849f, 0.57857847f, 0.00414050f}, {-0.41223201f, -0.17130400f, 0.57930398f, 0.00423200f}, {-0.41132450f, -0.17302650f, 0.58002651f, 0.00432450f}, {-0.41041800f, -0.17474599f, 0.58074600f, 0.00441800f}, {-0.40951249f, -0.17646250f, 0.58146250f, 0.00451250f}, {-0.40860799f, -0.17817600f, 0.58217603f, 0.00460800f}, {-0.40770450f, -0.17988651f, 0.58288652f, 0.00470450f}, {-0.40680200f, -0.18159400f, 0.58359402f, 0.00480200f}, {-0.40590051f, -0.18329850f, 0.58429849f, 0.00490050f}, {-0.40500000f, -0.18500000f, 0.58499998f, 0.00500000f}, {-0.40410051f, -0.18669851f, 0.58569849f, 0.00510050f}, {-0.40320200f, -0.18839400f, 0.58639401f, 0.00520200f}, {-0.40230450f, -0.19008650f, 0.58708650f, 0.00530450f}, {-0.40140799f, -0.19177601f, 0.58777601f, 0.00540800f}, {-0.40051252f, -0.19346249f, 0.58846247f, 0.00551250f}, {-0.39961800f, -0.19514599f, 0.58914602f, 0.00561800f}, {-0.39872450f, -0.19682650f, 0.58982652f, 0.00572450f},
		{-0.39783201f, -0.19850400f, 0.59050399f, 0.00583200f}, {-0.39694050f, -0.20017849f, 0.59117848f, 0.00594050f}, {-0.39605001f, -0.20185000f, 0.59184998f, 0.00605000f}, {-0.39516050f, -0.20351849f, 0.59251851f, 0.00616050f}, {-0.39427200f, -0.20518401f, 0.59318399f, 0.00627200f}, {-0.39338452f, -0.20684649f, 0.59384650f, 0.00638450f}, {-0.39249799f, -0.20850600f, 0.59450603f, 0.00649800f}, {-0.39161250f, -0.21016251f, 0.59516251f, 0.00661250f}, {-0.39072800f, -0.21181600f, 0.59581602f, 0.00672800f}, {-0.38984451f, -0.21346650f, 0.59646648f, 0.00684450f}, {-0.38896200f, -0.21511400f, 0.59711403f, 0.00696200f}, {-0.38808051f, -0.21675850f, 0.59775847f, 0.00708050f}, {-0.38720000f, -0.21840000f, 0.59840000f, 0.00720000f}, {-0.38632050f, -0.22003850f, 0.59903848f, 0.00732050f}, {-0.38544199f, -0.22167400f, 0.59967399f, 0.00744200f}, {-0.38456449f, -0.22330651f, 0.60030651f, 0.00756450f}, {-0.38368800f, -0.22493599f, 0.60093600f, 0.00768800f}, {-0.38281250f, -0.22656250f, 0.60156250f, 0.00781250f}, {-0.38193801f, -0.22818600f, 0.60218602f, 0.00793800f}, {-0.38106450f, -0.22980651f, 0.60280651f, 0.00806450f}, {-0.38019198f, -0.23142400f, 0.60342401f, 0.00819200f}, {-0.37932050f, -0.23303849f, 0.60403848f, 0.00832050f}, {-0.37845001f, -0.23464999f, 0.60465002f, 0.00845000f}, {-0.37758049f, -0.23625849f, 0.60525852f, 0.00858050f}, {-0.37671199f, -0.23786400f, 0.60586399f, 0.00871200f}, {-0.37584451f, -0.23946650f, 0.60646647f, 0.00884450f}, {-0.37497801f, -0.24106601f, 0.60706598f, 0.00897800f}, {-0.37411249f, -0.24266250f, 0.60766250f, 0.00911250f}, {-0.37324798f, -0.24425600f, 0.60825598f, 0.00924800f}, {-0.37238452f, -0.24584650f, 0.60884649f, 0.00938450f}, {-0.37152201f, -0.24743399f, 0.60943401f, 0.00952200f}, {-0.37066051f, -0.24901849f, 0.61001849f, 0.00966050f}, {-0.36980000f, -0.25060001f, 0.61059999f, 0.00980000f}, {-0.36894050f, -0.25217849f, 0.61117852f, 0.00994050f}, {-0.36808199f, -0.25375402f, 0.61175400f, 0.01008200f}, {-0.36722448f, -0.25532651f, 0.61232650f, 0.01022450f},
		{-0.36636800f, -0.25689599f, 0.61289603f, 0.01036800f}, {-0.36551249f, -0.25846249f, 0.61346251f, 0.01051250f}, {-0.36465800f, -0.26002601f, 0.61402601f, 0.01065800f}, {-0.36380449f, -0.26158649f, 0.61458647f, 0.01080450f}, {-0.36295199f, -0.26314402f, 0.61514401f, 0.01095200f}, {-0.36210048f, -0.26469851f, 0.61569852f, 0.01110050f}, {-0.36124998f, -0.26625001f, 0.61624998f, 0.01125000f}, {-0.36040050f, -0.26779848f, 0.61679852f, 0.01140050f}, {-0.35955200f, -0.26934400f, 0.61734402f, 0.01155200f}, {-0.35870451f, -0.27088648f, 0.61788648f, 0.01170450f}, {-0.35785800f, -0.27242601f, 0.61842602f, 0.01185800f}, {-0.35701251f, -0.27396250f, 0.61896253f, 0.01201250f}, {-0.35616800f, -0.27549601f, 0.61949599f, 0.01216800f}, {-0.35532451f, -0.27702650f, 0.62002653f, 0.01232450f}, {-0.35448200f, -0.27855402f, 0.62055403f, 0.01248200f}, {-0.35364050f, -0.28007850f, 0.62107849f, 0.01264050f}, {-0.35280001f, -0.28160000f, 0.62159997f, 0.01280000f}, {-0.35196051f, -0.28311849f, 0.62211847f, 0.01296050f}, {-0.35112199f, -0.28463399f, 0.62263399f, 0.01312200f}, {-0.35028449f, -0.28614649f, 0.62314647f, 0.01328450f}, {-0.34944800f, -0.28765601f, 0.62365597f, 0.01344800f}, {-0.34861249f, -0.28916252f, 0.62416250f, 0.01361250f}, {-0.34777799f, -0.29066598f, 0.62466598f, 0.01377800f}, {-0.34694451f, -0.29216650f, 0.62516648f, 0.01394450f}, {-0.34611201f, -0.29366401f, 0.62566400f, 0.01411200f}, {-0.34528050f, -0.29515851f, 0.62615848f, 0.01428050f}, {-0.34445000f, -0.29664999f, 0.62664998f, 0.01445000f}, {-0.34362051f, -0.29813850f, 0.62713850f, 0.01462050f}, {-0.34279200f, -0.29962400f, 0.62762398f, 0.01479200f}, {-0.34196451f, -0.30110648f, 0.62810647f, 0.01496450f}, {-0.34113801f, -0.30258599f, 0.62858599f, 0.01513800f}, {-0.34031251f, -0.30406249f, 0.62906247f, 0.01531250f}, {-0.33948800f, -0.30553600f, 0.62953597f, 0.01548800f}, {-0.33866450f, -0.30700651f, 0.63000649f, 0.01566450f}, {-0.33784199f, -0.30847400f, 0.63047403f, 0.01584200f}, {-0.33702049f, -0.30993852f, 0.63093853f, 0.01602050f},
		{-0.33620000f, -0.31140000f, 0.63139999f, 0.01620000f}, {-0.33538049f, -0.31285849f, 0.63185847f, 0.01638050f}, {-0.33456200f, -0.31431401f, 0.63231403f, 0.01656200f}, {-0.33374450f, -0.31576648f, 0.63276649f, 0.01674450f}, {-0.33292800f, -0.31721601f, 0.63321602f, 0.01692800f}, {-0.33211249f, -0.31866249f, 0.63366252f, 0.01711250f}, {-0.33129799f, -0.32010600f, 0.63410598f, 0.01729800f}, {-0.33048451f, -0.32154649f, 0.63454652f, 0.01748450f}, {-0.32967201f, -0.32298398f, 0.63498402f, 0.01767200f}, {-0.32886049f, -0.32441849f, 0.63541847f, 0.01786050f}, {-0.32804999f, -0.32585001f, 0.63585001f, 0.01805000f}, {-0.32724050f, -0.32727849f, 0.63627851f, 0.01824050f}, {-0.32643199f, -0.32870400f, 0.63670403f, 0.01843200f}, {-0.32562450f, -0.33012649f, 0.63712651f, 0.01862450f}, {-0.32481799f, -0.33154601f, 0.63754600f, 0.01881800f}, {-0.32401252f, -0.33296248f, 0.63796252f, 0.01901250f}, {-0.32320800f, -0.33437601f, 0.63837600f, 0.01920800f}, {-0.32240450f, -0.33578649f, 0.63878649f, 0.01940450f}, {-0.32160199f, -0.33719400f, 0.63919401f, 0.01960200f}, {-0.32080051f, -0.33859849f, 0.63959849f, 0.01980050f}, {-0.31999999f, -0.34000000f, 0.63999999f, 0.02000000f}, {-0.31920049f, -0.34139851f, 0.64039850f, 0.02020050f}, {-0.31840199f, -0.34279400f, 0.64079398f, 0.02040200f}, {-0.31760451f, -0.34418648f, 0.64118648f, 0.02060450f}, {-0.31680802f, -0.34557599f, 0.64157599f, 0.02080800f}, {-0.31601250f, -0.34696251f, 0.64196253f, 0.02101250f}, {-0.31521800f, -0.34834599f, 0.64234602f, 0.02121800f}, {-0.31442448f, -0.34972650f, 0.64272648f, 0.02142450f}, {-0.31363201f, -0.35110399f, 0.64310402f, 0.02163200f}, {-0.31284049f, -0.35247850f, 0.64347851f, 0.02184050f}, {-0.31205001f, -0.35384998f, 0.64384997f, 0.02205000f}, {-0.31126049f, -0.35521850f, 0.64421850f, 0.02226050f}, {-0.31047201f, -0.35658398f, 0.64458400f, 0.02247200f}, {-0.30968451f, -0.35794649f, 0.64494652f, 0.02268450f}, {-0.30889800f, -0.35930601f, 0.64530599f, 0.02289800f}, {-0.30811250f, -0.36066249f, 0.64566249f, 0.02311250f},
		{-0.30732799f, -0.36201602f, 0.64601600f, 0.02332800f}, {-0.30654451f, -0.36336648f, 0.64636648f, 0.02354450f}, {-0.30576199f, -0.36471400f, 0.64671397f, 0.02376200f}, {-0.30498052f, -0.36605850f, 0.64705849f, 0.02398050f}, {-0.30419999f, -0.36739999f, 0.64740002f, 0.02420000f}, {-0.30342051f, -0.36873850f, 0.64773852f, 0.02442050f}, {-0.30264199f, -0.37007400f, 0.64807397f, 0.02464200f}, {-0.30186450f, -0.37140650f, 0.64840651f, 0.02486450f}, {-0.30108801f, -0.37273601f, 0.64873600f, 0.02508800f}, {-0.30031252f, -0.37406248f, 0.64906251f, 0.02531250f}, {-0.29953802f, -0.37538600f, 0.64938599f, 0.02553800f}, {-0.29876450f, -0.37670651f, 0.64970648f, 0.02576450f}, {-0.29799199f, -0.37802401f, 0.65002400f, 0.02599200f}, {-0.29722050f, -0.37933850f, 0.65033847f, 0.02622050f}, {-0.29644999f, -0.38065001f, 0.65065002f, 0.02645000f}, {-0.29568049f, -0.38195851f, 0.65095848f, 0.02668050f}, {-0.29491201f, -0.38326401f, 0.65126401f, 0.02691200f}, {-0.29414451f, -0.38456649f, 0.65156651f, 0.02714450f}, {-0.29337800f, -0.38586599f, 0.65186602f, 0.02737800f}, {-0.29261249f, -0.38716251f, 0.65216249f, 0.02761250f}, {-0.29184800f, -0.38845599f, 0.65245599f, 0.02784800f}, {-0.29108450f, -0.38974652f, 0.65274650f, 0.02808450f}, {-0.29032201f, -0.39103401f, 0.65303397f, 0.02832200f}, {-0.28956050f, -0.39231849f, 0.65331852f, 0.02856050f}, {-0.28880000f, -0.39359999f, 0.65359998f, 0.02880000f}, {-0.28804049f, -0.39487851f, 0.65387851f, 0.02904050f}, {-0.28728199f, -0.39615399f, 0.65415400f, 0.02928200f}, {-0.28652450f, -0.39742649f, 0.65442652f, 0.02952450f}, {-0.28576800f, -0.39869601f, 0.65469599f, 0.02976800f}, {-0.28501248f, -0.39996251f, 0.65496248f, 0.03001250f}, {-0.28425801f, -0.40122601f, 0.65522599f, 0.03025800f}, {-0.28350452f, -0.40248650f, 0.65548652f, 0.03050450f}, {-0.28275201f, -0.40374398f, 0.65574402f, 0.03075200f}, {-0.28200051f, -0.40499851f, 0.65599853f, 0.03100050f}, {-0.28125000f, -0.40625000f, 0.65625000f, 0.03125000f}, {-0.28050050f, -0.40749848f, 0.65649849f, 0.03150050f},
		{-0.27975199f, -0.40874401f, 0.65674400f, 0.03175200f}, {-0.27900451f, -0.40998650f, 0.65698647f, 0.03200450f}, {-0.27825800f, -0.41122600f, 0.65722603f, 0.03225800f}, {-0.27751249f, -0.41246250f, 0.65746248f, 0.03251250f}, {-0.27676800f, -0.41369602f, 0.65769601f, 0.03276800f}, {-0.27602449f, -0.41492650f, 0.65792650f, 0.03302450f}, {-0.27528200f, -0.41615400f, 0.65815401f, 0.03328200f}, {-0.27454048f, -0.41737852f, 0.65837848f, 0.03354050f}, {-0.27380002f, -0.41859999f, 0.65859997f, 0.03380000f}, {-0.27306050f, -0.41981852f, 0.65881848f, 0.03406050f}, {-0.27232200f, -0.42103398f, 0.65903401f, 0.03432200f}, {-0.27158448f, -0.42224652f, 0.65924650f, 0.03458450f}, {-0.27084801f, -0.42345598f, 0.65945601f, 0.03484800f}, {-0.27011251f, -0.42466247f, 0.65966249f, 0.03511250f}, {-0.26937801f, -0.42586601f, 0.65986598f, 0.03537800f}, {-0.26864451f, -0.42706648f, 0.66006649f, 0.03564450f}, {-0.26791200f, -0.42826402f, 0.66026402f, 0.03591200f}, {-0.26718050f, -0.42945850f, 0.66045851f, 0.03618050f}, {-0.26644999f, -0.43065003f, 0.66065001f, 0.03645000f}, {-0.26572052f, -0.43183848f, 0.66083848f, 0.03672050f}, {-0.26499200f, -0.43302402f, 0.66102397f, 0.03699200f}, {-0.26426449f, -0.43420652f, 0.66120648f, 0.03726450f}, {-0.26353800f, -0.43538597f, 0.66138601f, 0.03753800f}, {-0.26281250f, -0.43656251f, 0.66156250f, 0.03781250f}, {-0.26208800f, -0.43773600f, 0.66173601f, 0.03808800f}, {-0.26136449f, -0.43890652f, 0.66190648f, 0.03836450f}, {-0.26064199f, -0.44007400f, 0.66207397f, 0.03864200f}, {-0.25992048f, -0.44123852f, 0.66223848f, 0.03892050f}, {-0.25920001f, -0.44240001f, 0.66240001f, 0.03920000f}, {-0.25848052f, -0.44355848f, 0.66255850f, 0.03948050f}, {-0.25776199f, -0.44471401f, 0.66271400f, 0.03976200f}, {-0.25704449f, -0.44586650f, 0.66286647f, 0.04004450f}, {-0.25632799f, -0.44701600f, 0.66301602f, 0.04032800f}, {-0.25561249f, -0.44816250f, 0.66316247f, 0.04061250f}, {-0.25489798f, -0.44930601f, 0.66330600f, 0.04089800f}, {-0.25418451f, -0.45044649f, 0.66344649f, 0.04118450f},
		{-0.25347200f, -0.45158398f, 0.66358399f, 0.04147200f}, {-0.25276050f, -0.45271850f, 0.66371852f, 0.04176050f}, {-0.25205001f, -0.45385000f, 0.66385001f, 0.04205000f}, {-0.25134051f, -0.45497850f, 0.66397852f, 0.04234050f}, {-0.25063202f, -0.45610398f, 0.66410398f, 0.04263200f}, {-0.24992450f, -0.45722651f, 0.66422647f, 0.04292450f}, {-0.24921800f, -0.45834601f, 0.66434598f, 0.04321800f}, {-0.24851251f, -0.45946249f, 0.66446251f, 0.04351250f}, {-0.24780799f, -0.46057600f, 0.66457599f, 0.04380800f}, {-0.24710451f, -0.46168649f, 0.66468650f, 0.04410450f}, {-0.24640200f, -0.46279401f, 0.66479403f, 0.04440200f}, {-0.24570051f, -0.46389848f, 0.66489851f, 0.04470050f}, {-0.24499999f, -0.46500000f, 0.66500002f, 0.04500000f}, {-0.24430050f, -0.46609849f, 0.66509849f, 0.04530050f}, {-0.24360201f, -0.46719399f, 0.66519397f, 0.04560200f}, {-0.24290450f, -0.46828651f, 0.66528648f, 0.04590450f}, {-0.24220800f, -0.46937600f, 0.66537601f, 0.04620800f}, {-0.24151249f, -0.47046250f, 0.66546249f, 0.04651250f}, {-0.24081801f, -0.47154599f, 0.66554600f, 0.04681800f}, {-0.24012449f, -0.47262651f, 0.66562653f, 0.04712450f}, {-0.23943201f, -0.47370401f, 0.66570401f, 0.04743200f}, {-0.23874050f, -0.47477847f, 0.66577852f, 0.04774050f}, {-0.23805000f, -0.47585002f, 0.66584998f, 0.04805000f}, {-0.23736051f, -0.47691849f, 0.66591853f, 0.04836050f}, {-0.23667200f, -0.47798401f, 0.66598397f, 0.04867200f}, {-0.23598450f, -0.47904649f, 0.66604650f, 0.04898450f}, {-0.23529799f, -0.48010603f, 0.66610599f, 0.04929800f}, {-0.23461249f, -0.48116249f, 0.66616249f, 0.04961250f}, {-0.23392799f, -0.48221600f, 0.66621602f, 0.04992800f}, {-0.23324449f, -0.48326650f, 0.66626650f, 0.05024450f}, {-0.23256201f, -0.48431399f, 0.66631401f, 0.05056200f}, {-0.23188050f, -0.48535851f, 0.66635847f, 0.05088050f}, {-0.23120001f, -0.48639998f, 0.66640002f, 0.05120000f}, {-0.23052049f, -0.48743850f, 0.66643852f, 0.05152050f}, {-0.22984201f, -0.48847401f, 0.66647398f, 0.05184200f}, {-0.22916450f, -0.48950651f, 0.66650653f, 0.05216450f},
		{-0.22848800f, -0.49053600f, 0.66653597f, 0.05248800f}, {-0.22781251f, -0.49156249f, 0.66656250f, 0.05281250f}, {-0.22713800f, -0.49258602f, 0.66658598f, 0.05313800f}, {-0.22646451f, -0.49360648f, 0.66660649f, 0.05346450f}, {-0.22579199f, -0.49462402f, 0.66662401f, 0.05379200f}, {-0.22512050f, -0.49563849f, 0.66663849f, 0.05412050f}, {-0.22444999f, -0.49665001f, 0.66665000f, 0.05445000f}, {-0.22378050f, -0.49765849f, 0.66665852f, 0.05478050f}, {-0.22311200f, -0.49866399f, 0.66666400f, 0.05511200f}, {-0.22244450f, -0.49966651f, 0.66666651f, 0.05544450f}, {-0.22177801f, -0.50066596f, 0.66666597f, 0.05577800f}, {-0.22111249f, -0.50166249f, 0.66666251f, 0.05611250f}, {-0.22044800f, -0.50265598f, 0.66665602f, 0.05644800f}, {-0.21978450f, -0.50364649f, 0.66664648f, 0.05678450f}, {-0.21912201f, -0.50463402f, 0.66663402f, 0.05712200f}, {-0.21846052f, -0.50561851f, 0.66661853f, 0.05746050f}, {-0.21779999f, -0.50660002f, 0.66659999f, 0.05780000f}, {-0.21714051f, -0.50757849f, 0.66657847f, 0.05814050f}, {-0.21648200f, -0.50855398f, 0.66655397f, 0.05848200f}, {-0.21582450f, -0.50952649f, 0.66652650f, 0.05882450f}, {-0.21516800f, -0.51049602f, 0.66649598f, 0.05916800f}, {-0.21451250f, -0.51146251f, 0.66646248f, 0.05951250f}, {-0.21385801f, -0.51242596f, 0.66642600f, 0.05985800f}, {-0.21320450f, -0.51338649f, 0.66638649f, 0.06020450f}, {-0.21255201f, -0.51434398f, 0.66634399f, 0.06055200f}, {-0.21190050f, -0.51529849f, 0.66629851f, 0.06090050f}, {-0.21125001f, -0.51625001f, 0.66624999f, 0.06125000f}, {-0.21060050f, -0.51719850f, 0.66619849f, 0.06160050f}, {-0.20995200f, -0.51814401f, 0.66614401f, 0.06195200f}, {-0.20930451f, -0.51908648f, 0.66608649f, 0.06230449f}, {-0.20865799f, -0.52002603f, 0.66602600f, 0.06265800f}, {-0.20801251f, -0.52096248f, 0.66596252f, 0.06301250f}, {-0.20736800f, -0.52189600f, 0.66589600f, 0.06336800f}, {-0.20672451f, -0.52282649f, 0.66582650f, 0.06372450f}, {-0.20608199f, -0.52375400f, 0.66575402f, 0.06408200f}, {-0.20544051f, -0.52467847f, 0.66567850f, 0.06444050f},
		{-0.20479999f, -0.52560002f, 0.66560000f, 0.06480001f}, {-0.20416050f, -0.52651852f, 0.66551852f, 0.06516050f}, {-0.20352201f, -0.52743399f, 0.66543400f, 0.06552200f}, {-0.20288450f, -0.52834648f, 0.66534650f, 0.06588450f}, {-0.20224801f, -0.52925599f, 0.66525602f, 0.06624800f}, {-0.20161249f, -0.53016251f, 0.66516250f, 0.06661250f}, {-0.20097800f, -0.53106600f, 0.66506600f, 0.06697800f}, {-0.20034449f, -0.53196651f, 0.66496652f, 0.06734450f}, {-0.19971199f, -0.53286397f, 0.66486400f, 0.06771200f}, {-0.19908051f, -0.53375846f, 0.66475850f, 0.06808050f}, {-0.19845000f, -0.53465003f, 0.66465002f, 0.06845000f}, {-0.19782050f, -0.53553849f, 0.66453850f, 0.06882050f}, {-0.19719200f, -0.53642398f, 0.66442400f, 0.06919200f}, {-0.19656450f, -0.53730649f, 0.66430652f, 0.06956450f}, {-0.19593799f, -0.53818601f, 0.66418600f, 0.06993800f}, {-0.19531250f, -0.53906250f, 0.66406250f, 0.07031250f}, {-0.19468801f, -0.53993601f, 0.66393602f, 0.07068800f}, {-0.19406450f, -0.54080653f, 0.66380650f, 0.07106450f}, {-0.19344200f, -0.54167402f, 0.66367400f, 0.07144200f}, {-0.19282049f, -0.54253852f, 0.66353852f, 0.07182050f}, {-0.19220001f, -0.54339999f, 0.66339999f, 0.07220000f}, {-0.19158049f, -0.54425853f, 0.66325849f, 0.07258050f}, {-0.19096200f, -0.54511398f, 0.66311401f, 0.07296200f}, {-0.19034451f, -0.54596651f, 0.66296649f, 0.07334449f}, {-0.18972799f, -0.54681599f, 0.66281599f, 0.07372800f}, {-0.18911250f, -0.54766250f, 0.66266251f, 0.07411250f}, {-0.18849799f, -0.54850602f, 0.66250598f, 0.07449800f}, {-0.18788451f, -0.54934651f, 0.66234648f, 0.07488450f}, {-0.18727200f, -0.55018401f, 0.66218400f, 0.07527200f}, {-0.18666050f, -0.55101848f, 0.66201848f, 0.07566050f}, {-0.18605001f, -0.55184996f, 0.66184998f, 0.07604999f}, {-0.18544050f, -0.55267853f, 0.66167849f, 0.07644050f}, {-0.18483201f, -0.55350399f, 0.66150403f, 0.07683200f}, {-0.18422450f, -0.55432653f, 0.66132653f, 0.07722450f}, {-0.18361801f, -0.55514598f, 0.66114599f, 0.07761800f}, {-0.18301250f, -0.55596250f, 0.66096252f, 0.07801250f},
		{-0.18240800f, -0.55677599f, 0.66077602f, 0.07840800f}, {-0.18180449f, -0.55758649f, 0.66058648f, 0.07880451f}, {-0.18120199f, -0.55839401f, 0.66039401f, 0.07920200f}, {-0.18060051f, -0.55919850f, 0.66019851f, 0.07960050f}, {-0.17999999f, -0.56000000f, 0.66000003f, 0.08000000f}, {-0.17940050f, -0.56079847f, 0.65979850f, 0.08040050f}, {-0.17880200f, -0.56159401f, 0.65959400f, 0.08080200f}, {-0.17820451f, -0.56238651f, 0.65938652f, 0.08120450f}, {-0.17760800f, -0.56317604f, 0.65917599f, 0.08160801f}, {-0.17701250f, -0.56396252f, 0.65896249f, 0.08201250f}, {-0.17641801f, -0.56474596f, 0.65874600f, 0.08241800f}, {-0.17582449f, -0.56552649f, 0.65852648f, 0.08282450f}, {-0.17523201f, -0.56630397f, 0.65830398f, 0.08323200f}, {-0.17464049f, -0.56707853f, 0.65807849f, 0.08364050f}, {-0.17405000f, -0.56784999f, 0.65785003f, 0.08405000f}, {-0.17346050f, -0.56861854f, 0.65761852f, 0.08446051f}, {-0.17287201f, -0.56938398f, 0.65738398f, 0.08487200f}, {-0.17228451f, -0.57014650f, 0.65714651f, 0.08528449f}, {-0.17169800f, -0.57090598f, 0.65690601f, 0.08569800f}, {-0.17111251f, -0.57166249f, 0.65666252f, 0.08611250f}, {-0.17052799f, -0.57241601f, 0.65641600f, 0.08652800f}, {-0.16994451f, -0.57316649f, 0.65616649f, 0.08694450f}, {-0.16936199f, -0.57391399f, 0.65591401f, 0.08736201f}, {-0.16878051f, -0.57465851f, 0.65565848f, 0.08778050f}, {-0.16820000f, -0.57539999f, 0.65539998f, 0.08819999f}, {-0.16762049f, -0.57613850f, 0.65513849f, 0.08862050f}, {-0.16704200f, -0.57687402f, 0.65487403f, 0.08904200f}, {-0.16646449f, -0.57760650f, 0.65460652f, 0.08946450f}, {-0.16588800f, -0.57833600f, 0.65433598f, 0.08988800f}, {-0.16531250f, -0.57906252f, 0.65406251f, 0.09031251f}, {-0.16473800f, -0.57978600f, 0.65378600f, 0.09073800f}, {-0.16416451f, -0.58050650f, 0.65350652f, 0.09116449f}, {-0.16359200f, -0.58122402f, 0.65322399f, 0.09159200f}, {-0.16302051f, -0.58193851f, 0.65293849f, 0.09202050f}, {-0.16245000f, -0.58265001f, 0.65265000f, 0.09245000f}, {-0.16188051f, -0.58335847f, 0.65235847f, 0.09288050f},
		{-0.16131200f, -0.58406401f, 0.65206403f, 0.09331200f}, {-0.16074450f, -0.58476651f, 0.65176648f, 0.09374450f}, {-0.16017801f, -0.58546597f, 0.65146601f, 0.09417799f}, {-0.15961249f, -0.58616251f, 0.65116251f, 0.09461250f}, {-0.15904801f, -0.58685601f, 0.65085602f, 0.09504800f}, {-0.15848450f, -0.58754653f, 0.65054649f, 0.09548450f}, {-0.15792200f, -0.58823401f, 0.65023398f, 0.09592200f}, {-0.15736049f, -0.58891851f, 0.64991850f, 0.09636050f}, {-0.15680000f, -0.58960003f, 0.64960003f, 0.09680000f}, {-0.15624049f, -0.59027851f, 0.64927852f, 0.09724051f}, {-0.15568200f, -0.59095401f, 0.64895397f, 0.09768200f}, {-0.15512450f, -0.59162647f, 0.64862651f, 0.09812450f}, {-0.15456800f, -0.59229600f, 0.64829600f, 0.09856800f}, {-0.15401250f, -0.59296250f, 0.64796251f, 0.09901250f}, {-0.15345800f, -0.59362602f, 0.64762598f, 0.09945800f}, {-0.15290450f, -0.59428650f, 0.64728647f, 0.09990450f}, {-0.15235199f, -0.59494400f, 0.64694399f, 0.10035201f}, {-0.15180050f, -0.59559852f, 0.64659852f, 0.10080050f}, {-0.15125000f, -0.59625000f, 0.64625001f, 0.10124999f}, {-0.15070049f, -0.59689850f, 0.64589852f, 0.10170050f}, {-0.15015200f, -0.59754401f, 0.64554399f, 0.10215200f}, {-0.14960450f, -0.59818649f, 0.64518648f, 0.10260450f}, {-0.14905800f, -0.59882599f, 0.64482599f, 0.10305800f}, {-0.14851250f, -0.59946251f, 0.64446247f, 0.10351251f}, {-0.14796799f, -0.60009599f, 0.64409602f, 0.10396800f}, {-0.14742450f, -0.60072649f, 0.64372653f, 0.10442449f}, {-0.14688200f, -0.60135400f, 0.64335400f, 0.10488200f}, {-0.14634050f, -0.60197848f, 0.64297849f, 0.10534050f}, {-0.14579999f, -0.60259998f, 0.64260000f, 0.10580000f}, {-0.14526050f, -0.60321850f, 0.64221853f, 0.10626050f}, {-0.14472200f, -0.60383403f, 0.64183402f, 0.10672201f}, {-0.14418450f, -0.60444647f, 0.64144647f, 0.10718450f}, {-0.14364801f, -0.60505599f, 0.64105600f, 0.10764799f}, {-0.14311250f, -0.60566252f, 0.64066249f, 0.10811250f}, {-0.14257801f, -0.60626602f, 0.64026600f, 0.10857800f}, {-0.14204450f, -0.60686648f, 0.63986647f, 0.10904450f},
		{-0.14151201f, -0.60746402f, 0.63946402f, 0.10951200f}, {-0.14098050f, -0.60805851f, 0.63905847f, 0.10998051f}, {-0.14045000f, -0.60865003f, 0.63865000f, 0.11045000f}, {-0.13992050f, -0.60923851f, 0.63823849f, 0.11092049f}, {-0.13939200f, -0.60982400f, 0.63782400f, 0.11139200f}, {-0.13886450f, -0.61040652f, 0.63740653f, 0.11186450f}, {-0.13833800f, -0.61098599f, 0.63698602f, 0.11233800f}, {-0.13781251f, -0.61156249f, 0.63656253f, 0.11281250f}, {-0.13728799f, -0.61213601f, 0.63613600f, 0.11328801f}, {-0.13676450f, -0.61270648f, 0.63570648f, 0.11376450f}, {-0.13624200f, -0.61327398f, 0.63527399f, 0.11424199f}, {-0.13572051f, -0.61383849f, 0.63483852f, 0.11472050f}, {-0.13520001f, -0.61439997f, 0.63440001f, 0.11519999f}, {-0.13468049f, -0.61495852f, 0.63395852f, 0.11568050f}, {-0.13416201f, -0.61551398f, 0.63351399f, 0.11616200f}, {-0.13364449f, -0.61606652f, 0.63306648f, 0.11664450f}, {-0.13312800f, -0.61661601f, 0.63261598f, 0.11712800f}, {-0.13261250f, -0.61716253f, 0.63216251f, 0.11761251f}, {-0.13209800f, -0.61770600f, 0.63170600f, 0.11809800f}, {-0.13158451f, -0.61824650f, 0.63124651f, 0.11858449f}, {-0.13107200f, -0.61878401f, 0.63078398f, 0.11907200f}, {-0.13056050f, -0.61931849f, 0.63031852f, 0.11956050f}, {-0.13004999f, -0.61984998f, 0.62984997f, 0.12005000f}, {-0.12954050f, -0.62037849f, 0.62937850f, 0.12054050f}, {-0.12903199f, -0.62090403f, 0.62890399f, 0.12103201f}, {-0.12852450f, -0.62142652f, 0.62842649f, 0.12152450f}, {-0.12801801f, -0.62194598f, 0.62794602f, 0.12201799f}, {-0.12751250f, -0.62246251f, 0.62746251f, 0.12251250f}, {-0.12700801f, -0.62297601f, 0.62697601f, 0.12300800f}, {-0.12650450f, -0.62348652f, 0.62648648f, 0.12350450f}, {-0.12600200f, -0.62399399f, 0.62599403f, 0.12400200f}, {-0.12550050f, -0.62449849f, 0.62549847f, 0.12450051f}, {-0.12500000f, -0.62500000f, 0.62500000f, 0.12500000f}, {-0.12450051f, -0.62549847f, 0.62449849f, 0.12550049f}, {-0.12400201f, -0.62599397f, 0.62399399f, 0.12600199f}, {-0.12350449f, -0.62648654f, 0.62348652f, 0.12650451f},
		{-0.12300800f, -0.62697601f, 0.62297601f, 0.12700800f}, {-0.12251250f, -0.62746251f, 0.62246251f, 0.12751250f}, {-0.12201801f, -0.62794602f, 0.62194604f, 0.12801799f}, {-0.12152448f, -0.62842649f, 0.62142646f, 0.12852451f}, {-0.12103199f, -0.62890399f, 0.62090397f, 0.12903201f}, {-0.12054050f, -0.62937850f, 0.62037849f, 0.12954050f}, {-0.12005001f, -0.62984997f, 0.61984998f, 0.13005000f}, {-0.11956051f, -0.63031846f, 0.61931849f, 0.13056049f}, {-0.11907199f, -0.63078403f, 0.61878401f, 0.13107201f}, {-0.11858449f, -0.63124651f, 0.61824650f, 0.13158451f}, {-0.11809800f, -0.63170600f, 0.61770600f, 0.13209800f}, {-0.11761250f, -0.63216251f, 0.61716253f, 0.13261249f}, {-0.11712801f, -0.63261598f, 0.61661601f, 0.13312799f}, {-0.11664449f, -0.63306653f, 0.61606652f, 0.13364451f}, {-0.11616199f, -0.63351399f, 0.61551398f, 0.13416200f}, {-0.11568050f, -0.63395852f, 0.61495852f, 0.13468050f}, {-0.11520001f, -0.63440001f, 0.61440003f, 0.13519999f}, {-0.11472049f, -0.63483852f, 0.61383849f, 0.13572051f}, {-0.11424199f, -0.63527399f, 0.61327398f, 0.13624201f}, {-0.11376450f, -0.63570648f, 0.61270648f, 0.13676450f}, {-0.11328801f, -0.63613600f, 0.61213601f, 0.13728799f}, {-0.11281251f, -0.63656247f, 0.61156249f, 0.13781249f}, {-0.11233799f, -0.63698602f, 0.61098599f, 0.13833801f}, {-0.11186449f, -0.63740653f, 0.61040652f, 0.13886451f}, {-0.11139200f, -0.63782400f, 0.60982400f, 0.13939200f}, {-0.11092050f, -0.63823849f, 0.60923851f, 0.13992049f}, {-0.11045001f, -0.63865000f, 0.60865003f, 0.14044998f}, {-0.10998049f, -0.63905853f, 0.60805851f, 0.14098051f}, {-0.10951199f, -0.63946402f, 0.60746402f, 0.14151200f}, {-0.10904451f, -0.63986647f, 0.60686648f, 0.14204450f}, {-0.10857801f, -0.64026600f, 0.60626602f, 0.14257799f}, {-0.10811248f, -0.64066249f, 0.60566247f, 0.14311251f}, {-0.10764799f, -0.64105600f, 0.60505599f, 0.14364801f}, {-0.10718450f, -0.64144647f, 0.60444647f, 0.14418450f}, {-0.10672200f, -0.64183402f, 0.60383403f, 0.14472199f}, {-0.10626051f, -0.64221847f, 0.60321850f, 0.14526049f},
		{-0.10579999f, -0.64260000f, 0.60259998f, 0.14580001f}, {-0.10534050f, -0.64297849f, 0.60197848f, 0.14634050f}, {-0.10488200f, -0.64335400f, 0.60135400f, 0.14688200f}, {-0.10442451f, -0.64372647f, 0.60072649f, 0.14742449f}, {-0.10396799f, -0.64409602f, 0.60009599f, 0.14796802f}, {-0.10351250f, -0.64446253f, 0.59946251f, 0.14851251f}, {-0.10305800f, -0.64482599f, 0.59882599f, 0.14905800f}, {-0.10260450f, -0.64518648f, 0.59818649f, 0.14960450f}, {-0.10215201f, -0.64554399f, 0.59754401f, 0.15015199f}, {-0.10170049f, -0.64589852f, 0.59689850f, 0.15070051f}, {-0.10124999f, -0.64625001f, 0.59625000f, 0.15125001f}, {-0.10080050f, -0.64659852f, 0.59559852f, 0.15180050f}, {-0.10035200f, -0.64694399f, 0.59494400f, 0.15235199f}, {-0.09990451f, -0.64728647f, 0.59428650f, 0.15290449f}, {-0.09945799f, -0.64762598f, 0.59362596f, 0.15345801f}, {-0.09901249f, -0.64796251f, 0.59296250f, 0.15401250f}, {-0.09856800f, -0.64829600f, 0.59229600f, 0.15456800f}, {-0.09812451f, -0.64862651f, 0.59162652f, 0.15512449f}, {-0.09768198f, -0.64895403f, 0.59095401f, 0.15568202f}, {-0.09724049f, -0.64927852f, 0.59027851f, 0.15624051f}, {-0.09680000f, -0.64960003f, 0.58960003f, 0.15680000f}, {-0.09636050f, -0.64991850f, 0.58891851f, 0.15736049f}, {-0.09592201f, -0.65023398f, 0.58823401f, 0.15792199f}, {-0.09548449f, -0.65054649f, 0.58754647f, 0.15848451f}, {-0.09504800f, -0.65085602f, 0.58685601f, 0.15904801f}, {-0.09461250f, -0.65116251f, 0.58616251f, 0.15961250f}, {-0.09417801f, -0.65146601f, 0.58546603f, 0.16017799f}, {-0.09374451f, -0.65176648f, 0.58476651f, 0.16074448f}, {-0.09331200f, -0.65206403f, 0.58406401f, 0.16131201f}, {-0.09288049f, -0.65235847f, 0.58335847f, 0.16188050f}, {-0.09245000f, -0.65265000f, 0.58265001f, 0.16245000f}, {-0.09202051f, -0.65293849f, 0.58193851f, 0.16302049f}, {-0.09159199f, -0.65322399f, 0.58122396f, 0.16359202f}, {-0.09116449f, -0.65350652f, 0.58050650f, 0.16416451f}, {-0.09073800f, -0.65378600f, 0.57978600f, 0.16473800f}, {-0.09031250f, -0.65406251f, 0.57906252f, 0.16531249f},
		{-0.08988801f, -0.65433598f, 0.57833600f, 0.16588799f}, {-0.08946449f, -0.65460652f, 0.57760650f, 0.16646451f}, {-0.08904199f, -0.65487403f, 0.57687402f, 0.16704201f}, {-0.08862050f, -0.65513849f, 0.57613850f, 0.16762050f}, {-0.08820001f, -0.65539998f, 0.57539999f, 0.16819999f}, {-0.08778051f, -0.65565848f, 0.57465851f, 0.16878048f}, {-0.08736199f, -0.65591401f, 0.57391399f, 0.16936201f}, {-0.08694450f, -0.65616649f, 0.57316649f, 0.16994450f}, {-0.08652800f, -0.65641600f, 0.57241601f, 0.17052799f}, {-0.08611251f, -0.65666252f, 0.57166255f, 0.17111249f}, {-0.08569799f, -0.65690601f, 0.57090598f, 0.17169801f}, {-0.08528449f, -0.65714651f, 0.57014650f, 0.17228451f}, {-0.08487200f, -0.65738398f, 0.56938398f, 0.17287200f}, {-0.08446050f, -0.65761852f, 0.56861854f, 0.17346049f}, {-0.08405001f, -0.65784997f, 0.56784999f, 0.17404998f}, {-0.08364049f, -0.65807849f, 0.56707847f, 0.17464051f}, {-0.08323200f, -0.65830398f, 0.56630397f, 0.17523200f}, {-0.08282450f, -0.65852648f, 0.56552649f, 0.17582450f}, {-0.08241801f, -0.65874600f, 0.56474602f, 0.17641799f}, {-0.08201249f, -0.65896249f, 0.56396246f, 0.17701252f}, {-0.08160799f, -0.65917599f, 0.56317598f, 0.17760801f}, {-0.08120450f, -0.65938652f, 0.56238651f, 0.17820450f}, {-0.08080200f, -0.65959400f, 0.56159401f, 0.17880199f}, {-0.08040051f, -0.65979850f, 0.56079853f, 0.17940049f}, {-0.07999999f, -0.66000003f, 0.56000000f, 0.18000001f}, {-0.07960050f, -0.66019851f, 0.55919850f, 0.18060051f}, {-0.07920200f, -0.66039401f, 0.55839401f, 0.18120200f}, {-0.07880451f, -0.66058648f, 0.55758649f, 0.18180449f}, {-0.07840801f, -0.66077602f, 0.55677605f, 0.18240798f}, {-0.07801249f, -0.66096252f, 0.55596250f, 0.18301251f}, {-0.07761800f, -0.66114599f, 0.55514598f, 0.18361800f}, {-0.07722450f, -0.66132653f, 0.55432653f, 0.18422450f}, {-0.07683201f, -0.66150397f, 0.55350399f, 0.18483199f}, {-0.07644049f, -0.66167849f, 0.55267847f, 0.18544052f}, {-0.07604999f, -0.66184998f, 0.55184996f, 0.18605001f}, {-0.07566050f, -0.66201848f, 0.55101848f, 0.18666050f},
		{-0.07527200f, -0.66218400f, 0.55018401f, 0.18727199f}, {-0.07488451f, -0.66234648f, 0.54934651f, 0.18788449f}, {-0.07449799f, -0.66250598f, 0.54850596f, 0.18849801f}, {-0.07411250f, -0.66266251f, 0.54766250f, 0.18911251f}, {-0.07372800f, -0.66281599f, 0.54681599f, 0.18972800f}, {-0.07334451f, -0.66296649f, 0.54596651f, 0.19034449f}, {-0.07296201f, -0.66311401f, 0.54511404f, 0.19096198f}, {-0.07258049f, -0.66325849f, 0.54425848f, 0.19158051f}, {-0.07220000f, -0.66339999f, 0.54339999f, 0.19220000f}, {-0.07182050f, -0.66353852f, 0.54253852f, 0.19282049f}, {-0.07144201f, -0.66367400f, 0.54167402f, 0.19344199f}, {-0.07106449f, -0.66380650f, 0.54080647f, 0.19406452f}, {-0.07068799f, -0.66393602f, 0.53993601f, 0.19468801f}, {-0.07031250f, -0.66406250f, 0.53906250f, 0.19531250f}, {-0.06993800f, -0.66418600f, 0.53818601f, 0.19593799f}, {-0.06956451f, -0.66430652f, 0.53730655f, 0.19656448f}, {-0.06919199f, -0.66442400f, 0.53642398f, 0.19719201f}, {-0.06882050f, -0.66453850f, 0.53553849f, 0.19782051f}, {-0.06845000f, -0.66465002f, 0.53465003f, 0.19845000f}, {-0.06808051f, -0.66475850f, 0.53375852f, 0.19908049f}, {-0.06771199f, -0.66486400f, 0.53286397f, 0.19971202f}, {-0.06734449f, -0.66496652f, 0.53196651f, 0.20034451f}, {-0.06697800f, -0.66506600f, 0.53106600f, 0.20097800f}, {-0.06661250f, -0.66516250f, 0.53016251f, 0.20161249f}, {-0.06624801f, -0.66525602f, 0.52925605f, 0.20224799f}, {-0.06588449f, -0.66534650f, 0.52834648f, 0.20288452f}, {-0.06552199f, -0.66543400f, 0.52743399f, 0.20352201f}, {-0.06516050f, -0.66551852f, 0.52651852f, 0.20416050f}, {-0.06480000f, -0.66560000f, 0.52560002f, 0.20479999f}, {-0.06444051f, -0.66567850f, 0.52467853f, 0.20544048f}, {-0.06408200f, -0.66575402f, 0.52375400f, 0.20608201f}, {-0.06372450f, -0.66582650f, 0.52282649f, 0.20672450f}, {-0.06336800f, -0.66589600f, 0.52189600f, 0.20736800f}, {-0.06301250f, -0.66596252f, 0.52096254f, 0.20801249f}, {-0.06265799f, -0.66602600f, 0.52002597f, 0.20865802f}, {-0.06230449f, -0.66608649f, 0.51908648f, 0.20930451f},
		{-0.06195200f, -0.66614401f, 0.51814401f, 0.20995200f}, {-0.06160050f, -0.66619849f, 0.51719850f, 0.21060049f}, {-0.06125001f, -0.66624999f, 0.51625001f, 0.21124998f}, {-0.06090049f, -0.66629851f, 0.51529849f, 0.21190051f}, {-0.06055200f, -0.66634399f, 0.51434398f, 0.21255201f}, {-0.06020450f, -0.66638649f, 0.51338649f, 0.21320450f}, {-0.05985801f, -0.66642600f, 0.51242602f, 0.21385799f}, {-0.05951251f, -0.66646248f, 0.51146251f, 0.21451248f}, {-0.05916799f, -0.66649598f, 0.51049596f, 0.21516801f}, {-0.05882450f, -0.66652650f, 0.50952649f, 0.21582450f}, {-0.05848200f, -0.66655397f, 0.50855398f, 0.21648199f}, {-0.05814051f, -0.66657847f, 0.50757849f, 0.21714049f}, {-0.05779999f, -0.66659999f, 0.50659996f, 0.21780002f}, {-0.05746049f, -0.66661853f, 0.50561851f, 0.21846051f}, {-0.05712200f, -0.66663402f, 0.50463402f, 0.21912200f}, {-0.05678450f, -0.66664648f, 0.50364649f, 0.21978449f}, {-0.05644801f, -0.66665602f, 0.50265604f, 0.22044798f}, {-0.05611249f, -0.66666251f, 0.50166249f, 0.22111251f}, {-0.05577800f, -0.66666597f, 0.50066596f, 0.22177801f}, {-0.05544450f, -0.66666651f, 0.49966651f, 0.22244450f}, {-0.05511200f, -0.66666400f, 0.49866402f, 0.22311199f}, {-0.05478049f, -0.66665852f, 0.49765846f, 0.22378052f}, {-0.05444999f, -0.66665000f, 0.49664998f, 0.22445001f}, {-0.05412050f, -0.66663849f, 0.49563849f, 0.22512050f}, {-0.05379200f, -0.66662401f, 0.49462402f, 0.22579199f}, {-0.05346451f, -0.66660649f, 0.49360651f, 0.22646449f}, {-0.05313799f, -0.66658598f, 0.49258599f, 0.22713802f}, {-0.05281249f, -0.66656250f, 0.49156249f, 0.22781251f}, {-0.05248800f, -0.66653597f, 0.49053600f, 0.22848800f}, {-0.05216451f, -0.66650653f, 0.48950651f, 0.22916449f}, {-0.05184201f, -0.66647398f, 0.48847404f, 0.22984198f}, {-0.05152049f, -0.66643852f, 0.48743847f, 0.23052051f}, {-0.05120000f, -0.66640002f, 0.48639998f, 0.23120000f}, {-0.05088050f, -0.66635847f, 0.48535851f, 0.23188050f}, {-0.05056201f, -0.66631401f, 0.48431402f, 0.23256199f}, {-0.05024449f, -0.66626650f, 0.48326647f, 0.23324452f},
		{-0.04992799f, -0.66621602f, 0.48221597f, 0.23392801f}, {-0.04961250f, -0.66616249f, 0.48116249f, 0.23461250f}, {-0.04929800f, -0.66610599f, 0.48010603f, 0.23529799f}, {-0.04898451f, -0.66604650f, 0.47904652f, 0.23598448f}, {-0.04867199f, -0.66598397f, 0.47798398f, 0.23667202f}, {-0.04836050f, -0.66591853f, 0.47691849f, 0.23736051f}, {-0.04805000f, -0.66584998f, 0.47585002f, 0.23805000f}, {-0.04774050f, -0.66577852f, 0.47477850f, 0.23874049f}, {-0.04743201f, -0.66570401f, 0.47370404f, 0.23943198f}, {-0.04712449f, -0.66562653f, 0.47262648f, 0.24012451f}, {-0.04681800f, -0.66554600f, 0.47154599f, 0.24081800f}, {-0.04651250f, -0.66546249f, 0.47046250f, 0.24151250f}, {-0.04620801f, -0.66537601f, 0.46937603f, 0.24220799f}, {-0.04590449f, -0.66528648f, 0.46828648f, 0.24290452f}, {-0.04560200f, -0.66519397f, 0.46719399f, 0.24360201f}, {-0.04530050f, -0.66509849f, 0.46609849f, 0.24430050f}, {-0.04500000f, -0.66500002f, 0.46500000f, 0.24499999f}, {-0.04470051f, -0.66489851f, 0.46389854f, 0.24570048f}, {-0.04440199f, -0.66479397f, 0.46279398f, 0.24640202f}, {-0.04410450f, -0.66468650f, 0.46168649f, 0.24710451f}, {-0.04380800f, -0.66457599f, 0.46057600f, 0.24780800f}, {-0.04351250f, -0.66446251f, 0.45946252f, 0.24851249f}, {-0.04321801f, -0.66434598f, 0.45834604f, 0.24921798f}, {-0.04292449f, -0.66422647f, 0.45722649f, 0.24992451f}, {-0.04263200f, -0.66410398f, 0.45610398f, 0.25063200f}, {-0.04234050f, -0.66397852f, 0.45497850f, 0.25134049f}, {-0.04205001f, -0.66385001f, 0.45385003f, 0.25204998f}, {-0.04176049f, -0.66371852f, 0.45271847f, 0.25276052f}, {-0.04147200f, -0.66358399f, 0.45158398f, 0.25347201f}, {-0.04118450f, -0.66344649f, 0.45044649f, 0.25418450f}, {-0.04089800f, -0.66330600f, 0.44930601f, 0.25489799f}, {-0.04061251f, -0.66316253f, 0.44816253f, 0.25561248f}, {-0.04032800f, -0.66301602f, 0.44701597f, 0.25632801f}, {-0.04004450f, -0.66286647f, 0.44586650f, 0.25704451f}, {-0.03976200f, -0.66271400f, 0.44471401f, 0.25776200f}, {-0.03948050f, -0.66255850f, 0.44355851f, 0.25848049f},
		{-0.03919999f, -0.66240001f, 0.44239998f, 0.25920002f}, {-0.03892050f, -0.66223848f, 0.44123849f, 0.25992051f}, {-0.03864200f, -0.66207397f, 0.44007400f, 0.26064200f}, {-0.03836450f, -0.66190648f, 0.43890652f, 0.26136449f}, {-0.03808801f, -0.66173601f, 0.43773603f, 0.26208798f}, {-0.03781249f, -0.66156250f, 0.43656248f, 0.26281252f}, {-0.03753800f, -0.66138601f, 0.43538597f, 0.26353801f}, {-0.03726450f, -0.66120648f, 0.43420652f, 0.26426450f}, {-0.03699200f, -0.66102397f, 0.43302402f, 0.26499199f}, {-0.03672051f, -0.66083848f, 0.43183854f, 0.26572048f}, {-0.03644999f, -0.66065001f, 0.43064997f, 0.26645001f}, {-0.03618050f, -0.66045851f, 0.42945850f, 0.26718050f}, {-0.03591200f, -0.66026402f, 0.42826402f, 0.26791200f}, {-0.03564451f, -0.66006649f, 0.42706653f, 0.26864449f}, {-0.03537799f, -0.65986598f, 0.42586598f, 0.26937802f}, {-0.03511250f, -0.65966249f, 0.42466247f, 0.27011251f}, {-0.03484800f, -0.65945601f, 0.42345598f, 0.27084800f}, {-0.03458450f, -0.65924650f, 0.42224652f, 0.27158449f}, {-0.03432200f, -0.65903401f, 0.42103404f, 0.27232198f}, {-0.03406049f, -0.65881848f, 0.41981846f, 0.27306052f}, {-0.03380000f, -0.65859997f, 0.41859999f, 0.27380001f}, {-0.03354050f, -0.65837848f, 0.41737852f, 0.27454050f}, {-0.03328200f, -0.65815401f, 0.41615403f, 0.27528199f}, {-0.03302451f, -0.65792650f, 0.41492653f, 0.27602448f}, {-0.03276800f, -0.65769601f, 0.41369599f, 0.27676801f}, {-0.03251250f, -0.65746248f, 0.41246250f, 0.27751250f}, {-0.03225800f, -0.65722603f, 0.41122600f, 0.27825799f}, {-0.03200451f, -0.65698653f, 0.40998653f, 0.27900448f}, {-0.03175199f, -0.65674400f, 0.40874398f, 0.27975202f}, {-0.03150050f, -0.65649849f, 0.40749848f, 0.28050051f}, {-0.03125000f, -0.65625000f, 0.40625000f, 0.28125000f}, {-0.03100050f, -0.65599853f, 0.40499851f, 0.28200049f}, {-0.03075201f, -0.65574402f, 0.40374404f, 0.28275198f}, {-0.03050449f, -0.65548652f, 0.40248647f, 0.28350452f}, {-0.03025800f, -0.65522599f, 0.40122598f, 0.28425801f}, {-0.03001250f, -0.65496248f, 0.39996251f, 0.28501250f},
		{-0.02976801f, -0.65469599f, 0.39869604f, 0.28576799f}, {-0.02952449f, -0.65442652f, 0.39742646f, 0.28652452f}, {-0.02928200f, -0.65415400f, 0.39615399f, 0.28728201f}, {-0.02904050f, -0.65387851f, 0.39487851f, 0.28804050f}, {-0.02880000f, -0.65359998f, 0.39360002f, 0.28879999f}, {-0.02856051f, -0.65331852f, 0.39231852f, 0.28956048f}, {-0.02832199f, -0.65303397f, 0.39103398f, 0.29032202f}, {-0.02808450f, -0.65274650f, 0.38974649f, 0.29108451f}, {-0.02784800f, -0.65245599f, 0.38845599f, 0.29184800f}, {-0.02761250f, -0.65216249f, 0.38716251f, 0.29261249f}, {-0.02737801f, -0.65186602f, 0.38586605f, 0.29337798f}, {-0.02714450f, -0.65156651f, 0.38456649f, 0.29414451f}, {-0.02691200f, -0.65126401f, 0.38326401f, 0.29491201f}, {-0.02668050f, -0.65095848f, 0.38195851f, 0.29568050f}, {-0.02645000f, -0.65065002f, 0.38065001f, 0.29644999f}, {-0.02622049f, -0.65033847f, 0.37933847f, 0.29722052f}, {-0.02599200f, -0.65002400f, 0.37802398f, 0.29799201f}, {-0.02576450f, -0.64970648f, 0.37670651f, 0.29876450f}, {-0.02553800f, -0.64938599f, 0.37538600f, 0.29953799f}, {-0.02531251f, -0.64906251f, 0.37406254f, 0.30031248f}, {-0.02508800f, -0.64873600f, 0.37273598f, 0.30108802f}, {-0.02486450f, -0.64840651f, 0.37140650f, 0.30186451f}, {-0.02464200f, -0.64807397f, 0.37007400f, 0.30264200f}, {-0.02442050f, -0.64773852f, 0.36873853f, 0.30342049f}, {-0.02420001f, -0.64740002f, 0.36740005f, 0.30419998f}, {-0.02398050f, -0.64705849f, 0.36605847f, 0.30498051f}, {-0.02376200f, -0.64671397f, 0.36471400f, 0.30576200f}, {-0.02354450f, -0.64636648f, 0.36336651f, 0.30654449f}, {-0.02332800f, -0.64601600f, 0.36201602f, 0.30732798f}, {-0.02311249f, -0.64566249f, 0.36066246f, 0.30811252f}, {-0.02289800f, -0.64530599f, 0.35930598f, 0.30889801f}, {-0.02268450f, -0.64494652f, 0.35794649f, 0.30968450f}, {-0.02247200f, -0.64458400f, 0.35658401f, 0.31047199f}, {-0.02226051f, -0.64421850f, 0.35521853f, 0.31126048f}, {-0.02205000f, -0.64384997f, 0.35384998f, 0.31205002f}, {-0.02184050f, -0.64347851f, 0.35247847f, 0.31284051f},
		{-0.02163200f, -0.64310402f, 0.35110399f, 0.31363200f}, {-0.02142450f, -0.64272648f, 0.34972653f, 0.31442449f}, {-0.02121799f, -0.64234596f, 0.34834597f, 0.31521802f}, {-0.02101250f, -0.64196247f, 0.34696248f, 0.31601251f}, {-0.02080800f, -0.64157599f, 0.34557599f, 0.31680800f}, {-0.02060450f, -0.64118648f, 0.34418651f, 0.31760449f}, {-0.02040200f, -0.64079398f, 0.34279403f, 0.31840198f}, {-0.02020049f, -0.64039850f, 0.34139848f, 0.31920052f}, {-0.02000000f, -0.63999999f, 0.33999997f, 0.32000001f}, {-0.01980050f, -0.63959849f, 0.33859849f, 0.32080050f}, {-0.01960200f, -0.63919401f, 0.33719403f, 0.32160199f}, {-0.01940450f, -0.63878649f, 0.33578655f, 0.32240448f}, {-0.01920800f, -0.63837600f, 0.33437598f, 0.32320802f}, {-0.01901250f, -0.63796252f, 0.33296248f, 0.32401251f}, {-0.01881800f, -0.63754600f, 0.33154601f, 0.32481800f}, {-0.01862450f, -0.63712651f, 0.33012652f, 0.32562448f}, {-0.01843200f, -0.63670397f, 0.32870397f, 0.32643202f}, {-0.01824050f, -0.63627851f, 0.32727847f, 0.32724051f}, {-0.01805000f, -0.63585001f, 0.32585001f, 0.32805000f}, {-0.01786050f, -0.63541853f, 0.32441851f, 0.32886049f}, {-0.01767200f, -0.63498402f, 0.32298404f, 0.32967198f}, {-0.01748450f, -0.63454652f, 0.32154647f, 0.33048452f}, {-0.01729800f, -0.63410598f, 0.32010600f, 0.33129801f}, {-0.01711250f, -0.63366252f, 0.31866249f, 0.33211250f}, {-0.01692800f, -0.63321602f, 0.31721601f, 0.33292799f}, {-0.01674451f, -0.63276649f, 0.31576654f, 0.33374448f}, {-0.01656200f, -0.63231397f, 0.31431398f, 0.33456202f}, {-0.01638050f, -0.63185847f, 0.31285849f, 0.33538050f}, {-0.01620000f, -0.63139999f, 0.31140000f, 0.33619999f}, {-0.01602050f, -0.63093853f, 0.30993852f, 0.33702048f}, {-0.01584199f, -0.63047397f, 0.30847397f, 0.33784202f}, {-0.01566450f, -0.63000649f, 0.30700648f, 0.33866451f}, {-0.01548800f, -0.62953597f, 0.30553600f, 0.33948800f}, {-0.01531250f, -0.62906253f, 0.30406252f, 0.34031249f}, {-0.01513800f, -0.62858599f, 0.30258605f, 0.34113798f}, {-0.01496450f, -0.62810647f, 0.30110645f, 0.34196452f},
		{-0.01479200f, -0.62762398f, 0.29962400f, 0.34279201f}, {-0.01462050f, -0.62713850f, 0.29813850f, 0.34362050f}, {-0.01445000f, -0.62665004f, 0.29665002f, 0.34444999f}, {-0.01428050f, -0.62615854f, 0.29515854f, 0.34528048f}, {-0.01411200f, -0.62566400f, 0.29366398f, 0.34611201f}, {-0.01394450f, -0.62516648f, 0.29216650f, 0.34694450f}, {-0.01377800f, -0.62466598f, 0.29066601f, 0.34777799f}, {-0.01361250f, -0.62416250f, 0.28916255f, 0.34861248f}, {-0.01344800f, -0.62365597f, 0.28765595f, 0.34944802f}, {-0.01328450f, -0.62314647f, 0.28614649f, 0.35028451f}, {-0.01312200f, -0.62263399f, 0.28463399f, 0.35112200f}, {-0.01296050f, -0.62211853f, 0.28311852f, 0.35196049f}, {-0.01280000f, -0.62160003f, 0.28160003f, 0.35279998f}, {-0.01264050f, -0.62107849f, 0.28007847f, 0.35364052f}, {-0.01248200f, -0.62055397f, 0.27855399f, 0.35448201f}, {-0.01232450f, -0.62002653f, 0.27702650f, 0.35532450f}, {-0.01216800f, -0.61949599f, 0.27549604f, 0.35616798f}, {-0.01201250f, -0.61896247f, 0.27396247f, 0.35701252f}, {-0.01185800f, -0.61842597f, 0.27242598f, 0.35785801f}, {-0.01170450f, -0.61788648f, 0.27088648f, 0.35870450f}, {-0.01155200f, -0.61734402f, 0.26934400f, 0.35955199f}, {-0.01140050f, -0.61679852f, 0.26779854f, 0.36040048f}, {-0.01125000f, -0.61624998f, 0.26624995f, 0.36125002f}, {-0.01110050f, -0.61569852f, 0.26469848f, 0.36210051f}, {-0.01095200f, -0.61514401f, 0.26314402f, 0.36295200f}, {-0.01080450f, -0.61458653f, 0.26158652f, 0.36380449f}, {-0.01065800f, -0.61402601f, 0.26002604f, 0.36465798f}, {-0.01051250f, -0.61346251f, 0.25846246f, 0.36551252f}, {-0.01036800f, -0.61289603f, 0.25689599f, 0.36636801f}, {-0.01022450f, -0.61232650f, 0.25532651f, 0.36722449f}, {-0.01008200f, -0.61175400f, 0.25375402f, 0.36808198f}, {-0.00994050f, -0.61117846f, 0.25217846f, 0.36894052f}, {-0.00980000f, -0.61059999f, 0.25059998f, 0.36980001f}, {-0.00966050f, -0.61001849f, 0.24901849f, 0.37066050f}, {-0.00952200f, -0.60943401f, 0.24743402f, 0.37152199f}, {-0.00938450f, -0.60884649f, 0.24584654f, 0.37238448f},
		{-0.00924800f, -0.60825598f, 0.24425596f, 0.37324802f}, {-0.00911250f, -0.60766250f, 0.24266249f, 0.37411251f}, {-0.00897800f, -0.60706598f, 0.24106601f, 0.37497800f}, {-0.00884450f, -0.60646653f, 0.23946653f, 0.37584449f}, {-0.00871200f, -0.60586399f, 0.23786405f, 0.37671197f}, {-0.00858050f, -0.60525846f, 0.23625848f, 0.37758052f}, {-0.00845000f, -0.60465002f, 0.23464999f, 0.37845000f}, {-0.00832050f, -0.60403848f, 0.23303851f, 0.37932049f}, {-0.00819200f, -0.60342401f, 0.23142403f, 0.38019198f}, {-0.00806450f, -0.60280651f, 0.22980645f, 0.38106452f}, {-0.00793800f, -0.60218596f, 0.22818598f, 0.38193801f}, {-0.00781250f, -0.60156250f, 0.22656250f, 0.38281250f}, {-0.00768800f, -0.60093600f, 0.22493602f, 0.38368799f}, {-0.00756450f, -0.60030651f, 0.22330654f, 0.38456448f}, {-0.00744200f, -0.59967399f, 0.22167397f, 0.38544202f}, {-0.00732050f, -0.59903848f, 0.22003849f, 0.38632051f}, {-0.00720000f, -0.59840000f, 0.21840000f, 0.38720000f}, {-0.00708050f, -0.59775853f, 0.21675853f, 0.38808048f}, {-0.00696200f, -0.59711397f, 0.21511395f, 0.38896203f}, {-0.00684450f, -0.59646648f, 0.21346648f, 0.38984451f}, {-0.00672800f, -0.59581602f, 0.21181600f, 0.39072800f}, {-0.00661250f, -0.59516251f, 0.21016252f, 0.39161249f}, {-0.00649800f, -0.59450603f, 0.20850603f, 0.39249798f}, {-0.00638450f, -0.59384650f, 0.20684646f, 0.39338452f}, {-0.00627200f, -0.59318399f, 0.20518398f, 0.39427201f}, {-0.00616050f, -0.59251851f, 0.20351849f, 0.39516050f}, {-0.00605000f, -0.59184998f, 0.20185003f, 0.39604999f}, {-0.00594050f, -0.59117854f, 0.20017855f, 0.39694048f}, {-0.00583200f, -0.59050399f, 0.19850397f, 0.39783202f}, {-0.00572450f, -0.58982652f, 0.19682649f, 0.39872451f}, {-0.00561800f, -0.58914602f, 0.19514601f, 0.39961799f}, {-0.00551250f, -0.58846253f, 0.19346254f, 0.40051248f}, {-0.00540800f, -0.58777601f, 0.19177595f, 0.40140802f}, {-0.00530450f, -0.58708650f, 0.19008647f, 0.40230451f}, {-0.00520200f, -0.58639401f, 0.18839400f, 0.40320200f}, {-0.00510050f, -0.58569849f, 0.18669851f, 0.40410049f},
		{-0.00500000f, -0.58500004f, 0.18500005f, 0.40499998f}, {-0.00490050f, -0.58429849f, 0.18329845f, 0.40590052f}, {-0.00480200f, -0.58359396f, 0.18159398f, 0.40680201f}, {-0.00470450f, -0.58288652f, 0.17988651f, 0.40770450f}, {-0.00460800f, -0.58217603f, 0.17817603f, 0.40860799f}, {-0.00451250f, -0.58146250f, 0.17646255f, 0.40951247f}, {-0.00441800f, -0.58074600f, 0.17474596f, 0.41041802f}, {-0.00432450f, -0.58002651f, 0.17302649f, 0.41132450f}, {-0.00423200f, -0.57930398f, 0.17130402f, 0.41223199f}, {-0.00414050f, -0.57857853f, 0.16957854f, 0.41314048f}, {-0.00405000f, -0.57784998f, 0.16784996f, 0.41405002f}, {-0.00396050f, -0.57711852f, 0.16611847f, 0.41496051f}, {-0.00387200f, -0.57638401f, 0.16438399f, 0.41587200f}, {-0.00378450f, -0.57564652f, 0.16264652f, 0.41678449f}, {-0.00369800f, -0.57490599f, 0.16090605f, 0.41769798f}, {-0.00361250f, -0.57416248f, 0.15916246f, 0.41861252f}, {-0.00352800f, -0.57341599f, 0.15741599f, 0.41952801f}, {-0.00344450f, -0.57266653f, 0.15566650f, 0.42044450f}, {-0.00336200f, -0.57191402f, 0.15391403f, 0.42136198f}, {-0.00328050f, -0.57115847f, 0.15215845f, 0.42228053f}, {-0.00320000f, -0.57040000f, 0.15039997f, 0.42320002f}, {-0.00312050f, -0.56963849f, 0.14863849f, 0.42412050f}, {-0.00304200f, -0.56887400f, 0.14687401f, 0.42504199f}, {-0.00296450f, -0.56810653f, 0.14510654f, 0.42596448f}, {-0.00288800f, -0.56733596f, 0.14333595f, 0.42688802f}, {-0.00281250f, -0.56656247f, 0.14156248f, 0.42781251f}, {-0.00273800f, -0.56578600f, 0.13978601f, 0.42873800f}, {-0.00266450f, -0.56500649f, 0.13800652f, 0.42966449f}, {-0.00259200f, -0.56422400f, 0.13622405f, 0.43059198f}, {-0.00252050f, -0.56343848f, 0.13443847f, 0.43152052f}, {-0.00245000f, -0.56264997f, 0.13264999f, 0.43245001f}, {-0.00238050f, -0.56185848f, 0.13085851f, 0.43338049f}, {-0.00231200f, -0.56106400f, 0.12906404f, 0.43431198f}, {-0.00224450f, -0.56026649f, 0.12726645f, 0.43524453f}, {-0.00217800f, -0.55946600f, 0.12546597f, 0.43617801f}, {-0.00211250f, -0.55866247f, 0.12366249f, 0.43711250f},
		{-0.00204800f, -0.55785602f, 0.12185602f, 0.43804799f}, {-0.00198450f, -0.55704653f, 0.12004654f, 0.43898448f}, {-0.00192200f, -0.55623400f, 0.11823396f, 0.43992202f}, {-0.00186050f, -0.55541849f, 0.11641848f, 0.44086051f}, {-0.00180000f, -0.55460000f, 0.11460000f, 0.44180000f}, {-0.00174050f, -0.55377853f, 0.11277853f, 0.44274049f}, {-0.00168200f, -0.55295402f, 0.11095405f, 0.44368197f}, {-0.00162450f, -0.55212647f, 0.10912646f, 0.44462452f}, {-0.00156800f, -0.55129600f, 0.10729599f, 0.44556801f}, {-0.00151250f, -0.55046248f, 0.10546251f, 0.44651249f}, {-0.00145800f, -0.54962599f, 0.10362604f, 0.44745798f}, {-0.00140450f, -0.54878646f, 0.10178645f, 0.44840453f}, {-0.00135200f, -0.54794401f, 0.09994397f, 0.44935201f}, {-0.00130050f, -0.54709852f, 0.09809850f, 0.45030050f}, {-0.00125000f, -0.54624999f, 0.09625002f, 0.45124999f}, {-0.00120050f, -0.54539853f, 0.09439854f, 0.45220048f}, {-0.00115200f, -0.54454398f, 0.09254396f, 0.45315202f}, {-0.00110450f, -0.54368651f, 0.09068649f, 0.45410451f}, {-0.00105800f, -0.54282600f, 0.08882601f, 0.45505800f}, {-0.00101250f, -0.54196250f, 0.08696253f, 0.45601248f}, {-0.00096800f, -0.54109603f, 0.08509605f, 0.45696797f}, {-0.00092450f, -0.54022646f, 0.08322646f, 0.45792452f}, {-0.00088200f, -0.53935397f, 0.08135399f, 0.45888200f}, {-0.00084050f, -0.53847849f, 0.07947852f, 0.45984049f}, {-0.00080000f, -0.53760004f, 0.07760004f, 0.46079998f}, {-0.00076050f, -0.53671849f, 0.07571846f, 0.46176052f}, {-0.00072200f, -0.53583401f, 0.07383398f, 0.46272201f}, {-0.00068450f, -0.53494650f, 0.07194650f, 0.46368450f}, {-0.00064800f, -0.53405601f, 0.07005603f, 0.46464799f}, {-0.00061250f, -0.53316253f, 0.06816255f, 0.46561247f}, {-0.00057800f, -0.53226596f, 0.06626596f, 0.46657802f}, {-0.00054450f, -0.53136647f, 0.06436648f, 0.46754451f}, {-0.00051200f, -0.53046399f, 0.06246401f, 0.46851199f}, {-0.00048050f, -0.52955854f, 0.06055854f, 0.46948048f}, {-0.00045000f, -0.52864999f, 0.05864995f, 0.47045003f}, {-0.00042050f, -0.52773851f, 0.05673847f, 0.47142052f},
		{-0.00039200f, -0.52682400f, 0.05482399f, 0.47239200f}, {-0.00036450f, -0.52590650f, 0.05290652f, 0.47336449f}, {-0.00033800f, -0.52498603f, 0.05098604f, 0.47433798f}, {-0.00031250f, -0.52406245f, 0.04906245f, 0.47531252f}, {-0.00028800f, -0.52313596f, 0.04713598f, 0.47628801f}, {-0.00026450f, -0.52220649f, 0.04520650f, 0.47726450f}, {-0.00024200f, -0.52127403f, 0.04327403f, 0.47824199f}, {-0.00022050f, -0.52033854f, 0.04133855f, 0.47922047f}, {-0.00020000f, -0.51940000f, 0.03939996f, 0.48020002f}, {-0.00018050f, -0.51845849f, 0.03745849f, 0.48118051f}, {-0.00016200f, -0.51751399f, 0.03551401f, 0.48216199f}, {-0.00014450f, -0.51656651f, 0.03356654f, 0.48314448f}, {-0.00012800f, -0.51561600f, 0.03161595f, 0.48412803f}, {-0.00011250f, -0.51466250f, 0.02966247f, 0.48511251f}, {-0.00009800f, -0.51370597f, 0.02770600f, 0.48609800f}, {-0.00008450f, -0.51274651f, 0.02574652f, 0.48708449f}, {-0.00007200f, -0.51178402f, 0.02378405f, 0.48807198f}, {-0.00006050f, -0.51081848f, 0.02181846f, 0.48906052f}, {-0.00005000f, -0.50984997f, 0.01984998f, 0.49005001f}, {-0.00004050f, -0.50887853f, 0.01787851f, 0.49104050f}, {-0.00003200f, -0.50790399f, 0.01590403f, 0.49203198f}, {-0.00002450f, -0.50692654f, 0.01392656f, 0.49302447f}, {-0.00001800f, -0.50594598f, 0.01194596f, 0.49401802f}, {-0.00001250f, -0.50496250f, 0.00996249f, 0.49501250f}, {-0.00000800f, -0.50397599f, 0.00797602f, 0.49600799f}, {-0.00000450f, -0.50298655f, 0.00598654f, 0.49700448f}, {-0.00000200f, -0.50199395f, 0.00399395f, 0.49800203f}, {-0.00000050f, -0.50099850f, 0.00199847f, 0.49900051f}, {-0.00000000f, -0.50000000f, 0.00000000f, 0.50000000f}};


/*************************************/
/* Implementation of GNurbsCrv Class */
/*************************************/
IMPLEMENT_GMESH_OBJECT(GNurbsCrv)

/*!
*	\brief 객체가 포함된 메쉬의 포인터를 반환한다.
*
*	\return 객체가 포함된 메쉬의 포인터를 반환한다.
*/
GMesh *GNurbsCrv::GetRefMesh()
{
	return this;
}

/*!
*	\brief 객체의 모델링 좌표계를 반환한다.
*
*	\return 월드 좌표계에서 표현된 객체의 모델링 좌표계를 반환한다.
*/
GTransf GNurbsCrv::GetTransf()
{
	return MC;
}

/*!
*	\brief 선택된 객체를 편집한다.
*
*	\param EC 편집 좌표계
*	\param t 편집될 객체의 이동 변위
*	\param q 편집될 객체의 회전 변위
*	\param s 편집될 객체의 스케일 변위
*	\param pParentMesh 편집 객체의 부모 메쉬
*/
void GNurbsCrv::Edit(GTransf EC, GVector3 t, GQuater q, GVector3 s, GMesh *pParentMesh)
{
	GMesh::Edit(EC, t, q, s, pParentMesh);
}

/*!
*	\brief 선택된 객체를 렌더링 한다.
*/
void GNurbsCrv::RenderForEdit(float r, float g, float b)
{
	GMesh::RenderForEdit(r, g, b);
}

/*!
*	\brief	넙스곡선의 생성을 위한 낫 벡터와 제어점 배열을 동적으로 할당
*	
*	\param _p 곡선의 차수
*	\param _n 곡선의 제어점의 마지막 인덱스
*/
void GNurbsCrv::_alloc(int _p, int _n)
{
	p = _p;
	n = _n;
	U = new double [p + n + 2];
	P = new GCtrlPt [n + 1];
	for (int i = 0; i < n + 1; ++i)
		P[i].pMesh = this;
}

/*!
*	\brief	넙스곡선의 낫 벡터와 제어점의 동적 배열을 해제
*/
void GNurbsCrv::_free()
{
	if (U != NULL)
		delete [] U;
	U = NULL;

	if (P != NULL)
		delete [] P;
	P = NULL;
}

/*!
*	\brief	디폴트 생성자
*/
GNurbsCrv::GNurbsCrv()
: GMesh("noname", GTransf(), FACE_QUAD, "")
{
	RefMeshName = "";
	_alloc(0, 0);
	U[0] = 0.0;
	U[1] = 1.0;
	rational = false;
	closed = false;
}

/*!
*	\brief	넙스곡선을 생성
*	
*	\param _Name 곡선의 이름
*	\param _MC 곡선이 생성될 모델링 좌표계
*	\param _p 곡선의 차수
*	\param _n 곡선의 제어점의 마지막 인덱스
*	\param _U 낫 벡터 배열
*	\param _P 제어점의 리스트
*	\param _rational true: 3차원공간의 유리식 곡선, false: 4차원 공간의 다항식 곡선
*	\param _ParentName 곡선의 부모 메쉬 이름
*	\param _RefMeshName 곡선이 정의된 메쉬의 이름
*/
GNurbsCrv::GNurbsCrv(std::string _Name, GTransf _MC, int _p, int _n, double *_U, GVector4 *_P, bool _rational, std::string _ParentName, std::string _RefMeshName)
: GMesh(_Name, _MC, FACE_QUAD, _ParentName)
{
	RefMeshName = _RefMeshName;
	_alloc(_p, _n);
	rational = _rational;
	closed = false;

	ARR_COPY(U, _U, p + n + 2);
	for (int i = 0; i < n + 1; i++)
		P[i] = _P[i];	
}

/*!
*	\brief	넙스곡선을 생성
*	
*	\param _Name 곡선의 이름
*	\param _MC 곡선이 생성될 모델링 좌표계
*	\param _p 곡선의 차수
*	\param _n 곡선의 제어점의 마지막 인덱스
*	\param _U 낫 벡터 배열
*	\param _P 제어점의 리스트
*	\param _rational true: 3차원공간의 유리식 곡선, false: 4차원 공간의 다항식 곡선
*	\param _ParentName 곡선의 부모 메쉬 이름
*	\param _RefMeshName 곡선이 정의된 메쉬의 이름
*/
GNurbsCrv::GNurbsCrv(std::string _Name, GTransf _MC, int _p, int _n, double *_U, GCtrlPt *_P, bool _rational, std::string _ParentName, std::string _RefMeshName)
: GMesh(_Name, _MC, FACE_QUAD, _ParentName)
{
	RefMeshName = _RefMeshName;
	_alloc(_p, _n);
	rational = _rational;
	closed = false;

	ARR_COPY(U, _U, p + n + 2);
	for (int i = 0; i < n + 1; i++)
		P[i] = _P[i];	
}

/*!
*	\brief	넙스곡선의 복사생성자
*
*	\param cpy 복사할 객체
*/
GNurbsCrv::GNurbsCrv(const GNurbsCrv &cpy)
: GMesh(cpy)
{
	RefMeshName = cpy.RefMeshName;
	_alloc(cpy.p, cpy.n);
	rational = cpy.rational;
	closed = cpy.closed;

	ARR_COPY(U, cpy.U, p + n + 2);
	for (int i = 0; i < n + 1; i++)
		P[i] = cpy.P[i];
}

/*!
*	\brief	넙스곡선의 소멸자
*/
GNurbsCrv::~GNurbsCrv()
{
	_free();
}

/*!
*	\brief	넙스곡선의 대입연산자 중복
*
*	\param rhs 대입될 넙스곡선 객체
*
*	\return 대입된 넙스곡선을 반환한다
*/
GNurbsCrv &GNurbsCrv::operator =(const GNurbsCrv &rhs)
{
	GMesh::operator =(rhs);

	RefMeshName = rhs.RefMeshName;
	_free();
	_alloc(rhs.p, rhs.n);
	rational = rhs.rational;
	closed = rhs.closed;

	ARR_COPY(U, rhs.U, p + n + 2);
	for (int i = 0; i < n + 1; i++)
		P[i] = rhs.P[i];

	return *this;
}

/*!
*	\brief	넙스 곡선을 렌더링 한다.
*
*	\param bSubMesh 서브 메쉬의 렌더링 여부(선택 모드에서는 false로 설정)
*/
void GNurbsCrv::Render(bool bSubMesh)
{
	// 곡선의 기본 형상을 렌더링 한후, 
	GMesh::Render(bSubMesh);

	// 추가적인 속성을 렌더링 한다.
	glPushMatrix();
	{
		// 월드 좌표계에서 객체의 모델링 좌표계로 변환하고,
		glMultMatrixd(cast_mat(MC).M);

		double size = Renderer.CtrlPtSize;
		double u_min, u_max;
		GetDomain(&u_min, &u_max);
		GVector4 C0 = Eval(u_min);
		GVector4 C1 = Eval(u_max);

		// 빨간색으로 시작어점을 렌더링 하고,
		GMaterial Mtl("mtl");
		Mtl.SetAmbient(0.3f, 0.3f, 0.3f);
		Mtl.SetDiffuse(1.0f, 0.0f, 0.0f);
		Mtl.SetSpecular(0.7f, 0.7f, 0.7f);
		Mtl.Enable(false);

		glPushMatrix();
		glTranslated(C0[0], C0[1], C0[2]);
		glutSolidSphere(size * 0.5, Renderer.NumSampU, Renderer.NumSampU);
		glPopMatrix();

		// 파란색으로 끝점을 렌더링 한다.
		Mtl.SetDiffuse(0.0, 0.0, 1.0);
		Mtl.Enable(false);
		glPushMatrix();
		glTranslated(C1[0], C1[1], C1[2]);
		glutSolidSphere(size * 0.5, Renderer.NumSampU, Renderer.NumSampU);
		glPopMatrix();

		// 제어점을 렌더링 할 경우,
		if (Renderer.RenderType & RENDER_CTRL_PT)
		{
			// 빨간색으로 시작 제어점을 렌더링 하고,
			Mtl.SetDiffuse(1.0f, 0.0f, 0.0f);
			Mtl.Enable(false);
			glPushMatrix();
			glTranslated(P[0][0], P[0][1], P[0][2]);
			glutSolidSphere(size, 10, 10);
			glPopMatrix();

			// 파란색으로 끝 제어점을 렌더링 하고,
			Mtl.SetDiffuse(0.0, 0.0, 1.0);
			Mtl.Enable(false);
			glPushMatrix();
			glTranslated(P[n][0], P[n][1], P[n][2]);
			glutSolidSphere(size, 10, 10);
			glPopMatrix();

			// 회색으로 중간 제어점을 렌더링한다.
			Mtl.SetDiffuse(0.7, 0.7, 0.7);
			Mtl.Enable(false);
			for (int i = 1; i < n; ++i)
			{
				glPushMatrix();
				glTranslated(P[i][0], P[i][1], P[i][2]);
				glutSolidSphere(size, 10, 10);
				glPopMatrix();
			}

			// 빨간색으로 제어 폴리곤을 렌더링한다.
			glDisable(GL_LIGHTING);
			glColor3d(1.0, 0.0, 0.0);
			glBegin(GL_LINE_STRIP);
			for (int i = 0; i < n + 1; ++i)
				glVertex3d(P[i][0], P[i][1], P[i][2]);
			glEnd();

			// 보간 정점을 가지고 있다면,  
			if (!Renderer.NodePts.empty())
			{
				// 보간 정점을 렌더링 한다.
				glPointSize(10.0);
				std::vector<GVector3> &Pts = Renderer.NodePts;
				int NumNodePt = (int)Pts.size();
				for (int i = 0; i < NumNodePt; ++i)
				{
					if (i == 0)
						glColor3f(1.0, 0.0, 0.0);
					else if (i == NumNodePt - 1)
						glColor3f(0.0, 0.0, 1.0);
					else
						glColor3f(0.0, 1.0, 0.0);					

					glBegin(GL_POINTS);
					glVertex3f(Pts[i][0], Pts[i][1], Pts[i][2]);
					glEnd();
				}
				glPointSize(1.0);
			}

			// 조명을 활성화 한다.
			glEnable(GL_LIGHTING);
		}
	}
	glPopMatrix();
}

/*!
*	\brief	넙스 곡선의 렌더링을 위한 메쉬를 생성한다.
*/
void GNurbsCrv::CreateMesh()
{
	// 경계 정점의 리스트를 초기화 하고,
	InitBndryEdgeList();

	// 정점의 좌표를 생성하고,
	CreateMeshVert();

	// 텍스처 좌표를 생성하고,
	CreateMeshTex();

	// 삼각형 정보를 생성하고, 
	CreateMeshFace();

	// 정점의 법선을 계산하고,
	UpdateNormal(false);

	// 곡면의 바운딩 박스를 계산한다.
	UpdateBndBox(false);

	// 정점 버퍼와 인덱스 버퍼를 갱신한다.
	UpdateBufVertex();
	UpdateBufNormal();
	UpdateBufFace();
}

/*!
*	\brief	넙스곡선의 렌더링을 위한 정점의 리스트를 생성한다.
*/
void GNurbsCrv::CreateMeshVert()
{
	// 기존의 정점을 지우고, 
	Verts.clear();

	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
	int NumSampV = Renderer.NumSampV;
	double Radius = Renderer.CtrlPtSize * 0.5;

	// RMF 리스트를 계산한다.
	std::vector<GTransf> FrameList;
	::get_rotation_minimizing_frames(this, NumSampV, FrameList);

	// 정의역을 계산하고, 실린더 위의 정점을 계산한다.
	for (int i = 0; i < NumSampU; ++i)
	{
		double u = (double)i / (double)(NumSampU - 1);
		double z = Radius * cos(2.0 * u * M_PI);
		double x = Radius * sin(2.0 * u * M_PI);
		for (int j = 0; j < NumSampV; ++j)
		{
			GPoint3 pt = FrameList[j] * GPoint3(x, 0.0, z);
			GVertex vtx(pt, GVector3(0.0, 0.0, 0.0));
			AddVertex(vtx);
		}
	}
}

/*!
*	\brief	넙스곡선의 렌더링을 위한 텍스처 리스트를 생성한다.
*/
void GNurbsCrv::CreateMeshTex()
{
	// 기존의 텍셀 정보를 지우고,
	Texs.clear();

	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
	int NumSampV = Renderer.NumSampV;

	// 정의역을 계산하고, 실린더 위의 정점을 계산한다.
	for (int i = 0; i < NumSampU; ++i)
	{
		double s = (double)i / (double)(NumSampU - 1);
		for (int j = 0; j < NumSampV; ++j)
		{
			double t = (double)j / (double)(NumSampV - 1);
			AddTexel(GVector2(s, t));
		}
	}
}

/*!
*	\brief	넙스곡선의 렌더링을 위한 삼각형 리스트를 생성한다.
*/
void GNurbsCrv::CreateMeshFace()
{
	// 기존 삼각형의 재질을 구하여,
	int PrevMtlIdx = -1;
	if (!Faces.empty())
		PrevMtlIdx = Faces[0].MtlIdx;

	// 삼각형 정보를 지우고,
	Faces.clear();

	// 삼각형을 생성하고 추가한다.
	int NumSampU = Renderer.NumSampU;
	int NumsampV = Renderer.NumSampV;
	for (int i = 0; i < NumSampU - 1; ++i)
	{
		for(int j = 0; j < NumsampV - 1; ++j)
		{
			int vidx0 = i * NumsampV + j;
			int vidx1 = vidx0 + NumsampV;
			int vidx2 = vidx1 + 1;
			int vidx3 = vidx0 + 1;

			GFace f0(vidx0, vidx1, vidx2, vidx0, vidx1, vidx2, PrevMtlIdx);
			GFace f1(vidx0, vidx2, vidx3, vidx0, vidx2, vidx3, PrevMtlIdx);

			AddFace(f0);
			AddFace(f1);
		}
	}
}

/*!
*	\brief	넙스 곡선위의 점을 계산
*
*	\param u 매개변수의 값
*
*	\return 곡선위의 점 C(u)를 계산
*/
GVector4 GNurbsCrv::Eval(double u, ...)
{
	double *basis = new double [p + 1];

	int idx = ::get_knot_span_idx(p, n, U, u);
	::get_gnurbs_basis(U, p, u, idx, basis);

	GVector4 pt;
	if (rational)
	{
		for (int i = 0; i < p + 1; ++i)
			pt += basis[i] * homogenize((P[idx - p + i]));
		pt = cartesianize(pt);
	}
	else
	{
		for (int i = 0; i < p + 1; ++i)
			pt += basis[i] * P[idx - p + i];
	}

	delete [] basis;
	return pt;
}

/*!
*	\brief	실제 곡선이 정의된 도메인을 반환한다.
*
*	\param umin 도메인의 시작 값이 저장된다.
*	\param umax 도메인의 끝 값이 저장된다.
*/
void GNurbsCrv::GetDomain(double *umin, ...)
{
	double *umax;
	va_list ap;
	va_start(ap, umin);
	umax = va_arg(ap, double *);
	va_end(ap);

	*umin = U[p];
	*umax = U[n + 1];
}

/*!
*	\brief	곡선의 제어점 리스트를 반환한다.
*
*	\return 곡선의 제어점 리스트를 반환한다.
*/
void GNurbsCrv::GetCtrlPtList(std::vector<GCtrlPt *> &CtrlPtList)
{
	for (int i = 0; i < n + 1; ++i)
		CtrlPtList.push_back(&P[i]);
}

/*!
*	\brief	넙스 곡선의 도함수를 계산
*
*	\param u 매개변수의 값
*	\param nth 미분차수
*
*	\return \a nth 차 미분한 곡선위의 점 C^nth(u)를 계산
*/
GVector4 GNurbsCrv::EvalDeriv(double u, int nth)
{
	int idx = ::get_knot_span_idx(p, n, U, u);

	double *deriv_basis = new double [(p + 1) * (p + 1)];
	::get_gnurbs_deriv_basis(U, p, u, idx, nth, deriv_basis);

	GVector4 pt;
	if (rational)
	{
		GVector4 *Aders = new GVector4 [nth + 1]; 
		GVector4 *CK = new GVector4 [nth + 1];

		for (int i = 0; i < nth + 1; ++i)
		{
			for (int j = 0; j <= p; ++j)
				Aders[i] += deriv_basis[i * (p + 1) + j] * homogenize(P[idx - p + j]);			
		}

		for (int i = 0; i < nth + 1; ++i)
		{
			GVector4 v(Aders[i]);
			for (int j = 1; j <= i; ++j)
				v -= Bin[i * (i + 1) / 2 + j] * Aders[j][3] * CK[i - j];			
			CK[i] = v / Aders[0][3];
		}

		pt = CK[nth];		

		delete [] Aders;
		delete [] CK;
	}
	else
	{
		for (int i = 0; i < p + 1; ++i)
			pt += deriv_basis[nth * (p + 1) + i] * P[idx - p + i];
	}

	delete [] deriv_basis;

	return pt;
}

/*!
*	\brief 곡선의 knot 벡터를 clamped 형태로 변형하고 해당 제어점을 구함
*/
void GNurbsCrv::KnotClamped()
{
	double min = U[p];
	double max = U[n + 1];
	int saved_n = n, saved_m = n + p + 1;

	// 이전 낫 벡터 저장
	double *saved_U = new double [saved_m + 1];
	ARR_COPY(saved_U, U, saved_m + 1);

	// 새로운 제어점 배열 할당
	GCtrlPt *Q = new GCtrlPt [saved_n + 1];

	int mul = ::get_knot_mult(p, n, U, min);
	int r = (p - mul < 0) ? 0 : (p - mul);
	if (mul != p + 1)	// 왼쪽 unclamped 형태라면
		KnotInsert(min, p - mul);

	mul = ::get_knot_mult(p, n, U, max);
	if (mul != p + 1)	// 오른쪽 unclamped 형태라면
		KnotInsert(max, p - mul);

	for (int i = r; i < r + saved_n + 1; ++i)
	{
		Q[i - r] = P[i];
		Q[i - r].pMesh = P[i].pMesh;
	}

	for (int i = 0; i < p; ++i)
	{
		saved_U[i] = min;
		saved_U[saved_m - i] = max;
	}

	_free();
	P = Q;
	U = saved_U;
	n = saved_n;
}

/*!
*	\brief 곡선의 knot 벡터를 unclamped 형태로 변형하고 해당 제어점을 구함
*/
void GNurbsCrv::KnotUnclamped()
{
	double min = U[p];
	double max = U[n + 1];

	GVector4 *Pw = new GVector4 [n + 1];
	for (int i = 0; i < n + 1; ++i)
	{
		if (rational)
			Pw[i] = ::homogenize(P[i]);
		else
			Pw[i] = P[i];
	}

	int mul = ::get_knot_mult(p, n, U, min);
	if (mul == p + 1)		// 왼쪽 clamped된 경우라면
	{
		for (int i = 0; i <= p - 2; ++i)	// Unclamp at left end
		{
			U[p - i - 1] = U[p - i] - (U[n - i + 1] - U[n - i]);
			int k = p -1;
			for (int j = i; j >= 0; --j)
			{
				double alpha = (U[p] - U[k]) / (U[p + j + 1] - U[k]);
				Pw[j] = (Pw[j] - alpha * Pw[j + 1]) / (1.0 - alpha);
				k = k - 1;
			}
		}
		U[0] = U[1] - (U[n - p + 2] - U[n - p + 1]);	// Set first knot
	}

	mul = ::get_knot_mult(p, n, U, max);
	if (mul == p + 1)		// 오른쪽 clamped된 경우라면
	{
		for (int i = 0; i <= p - 2; ++i)	// Unclamp at right end
		{
			U[n + i + 2] = U[n + i + 1] + (U[p + i + 1] - U[p + i]);
			for (int j = i; j >= 0; --j)
			{
				double alpha = (U[n + 1] - U[n - j]) / (U[n - j + i + 2] - U[n - j]);
				Pw[n - j] = (Pw[n - j] - (1.0 - alpha) * Pw[n - j - 1]) / alpha;
			}
		}
		U[n + p + 1] = U[n + p] + (U[2 * p] - U[2 * p - 1]);	// Set last knot
	}

	for (int i = 0; i < n + 1; ++i)
	{
		if (rational)
			P[i] = rationalize(Pw[i]);
		else
			P[i] = Pw[i];
	}

	delete [] Pw;
}

/*!
*	\brief	넙스곡선의 knot 벡터에 새로운 knot을 삽입한다.
*
*	\param u 새로운 knot 값
*	\param r 삽입회수
*
*	\return 실제 삽입된 횟수 반환
*/
int GNurbsCrv::KnotInsert(double u, int r)
{
	// 낫의 반복수를 구함
	int mul = ::get_knot_mult(p, n, U, u);
	if (r + mul > p)
		r = p - mul;	// 반복수 조정

	if (r < 1)
		return r;

	// 폐곡선의 경우, clamped 낫 벡터로 변경
	bool flag = false;
	if (closed)
	{
		closed = false;
		flag = true;
		KnotClamped();
	}

	// 새로운 낫 벡터와 제어점 배열 생성
	double *nU = new double [p + n + 2 + r];
	GCtrlPt *nP = new GCtrlPt [n + 1 + r];

	// 낫 추가하고 새로운 제어점을 계산 
	::knot_insert(p, n, U, P, u, r, nU, nP, rational);

	// 제어점의 참조 메쉬를 설정하고,
	for (int i = 0; i < n + 1 + r; ++i)
		nP[i].pMesh = this;
	
	// 새로운 제어점과 낫 벡터 설정
	_free();
	U = nU;
	P = nP;
	n = n + r;

	// 폐곡선의 경우, unclamped 낫 벡터로 복원
	if (flag)
	{
		closed = true;
		KnotUnclamped();
	}

	return r;
}

/*!
*	\brief	넙스곡선의 낫 벡터에 낫을 제거
*
*	\param u 제거할 낫 값
*	\param r 제거회수
*
*	\return 실제 제거된 횟수 반환
*/
int GNurbsCrv::KnotRemove(double u, int r)
{
	int mul = ::get_knot_mult(p, n, U, u);
	r = MIN(r, mul);

	int scs = ::knot_remove(p, n, U, P, u, r, rational);
	if (scs == 0)
		return scs;

	int new_n = n - scs;

	// 새로운 낫 벡터 생성 및 복사
	double *nU = new double [p + new_n + 2];
	ARR_COPY(nU, U, p + new_n + 2);

	// 새로운 제어점 배열 생성 및 복사
	GCtrlPt *nP = new GCtrlPt [new_n + 1];
	for (int i = 0; i < new_n + 1; i++)
	{
		nP[i] = P[i];
		nP[i].pMesh = this;
	}

	_free();
	// 곡선의 변경된 상태 설정
	n = new_n;
	U = nU;
	P = nP;

	return scs;
}

/*!
*	\brief 모든 knot span에 중간 knot 값을 추가함.
*/
void GNurbsCrv::KnotRefine()
{
	int m = p + n + 1;
	double *knot = new double [m + 1];
	ARR_COPY(knot, U, p + n + 2);

	for (int i = p; i < m - p; i++)
	{
		double u = (knot[i] + knot[i + 1]) * 0.5;
		KnotInsert(u, 1);
	}

	delete [] knot;
}

/*!
*	\brief 곡선을 piecewise Bezier 형태로 변환한다.
*/
void GNurbsCrv::CnvrtBzrForm()
{
	// 곡선을 clamped 형태로 만들고,
	KnotClamped();

	// U[p + 1] ~ U[n] 까지의 낫 값을 모으고,
	std::vector<double> tmp;
	for (int i = p + 1; i < n + 1; ++i)
		tmp.push_back(U[i]);

	// 중복을 제거하여,
	sort(tmp.begin(), tmp.end());
	tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());

	// 각각의 낫을 (차수 - 중복수) 만큼 추가한다.
	for (int i = 0; i < (int)tmp.size(); ++i)
	{
		int mult = ::get_knot_mult(p, n, U, tmp[i]);
		int r = p - mult;
		KnotInsert(tmp[i], r);
	}
}

/*!
*	\brief 곡선을 B-spline 형태로 변환한다.
*/
void GNurbsCrv::CnvrtBspForm()
{
	// 곡선을 clamped 형태로 만들고,
	KnotClamped();

	int kidx;
	int m = n + p + 1;
	double *knot = get_knot_merged_distinct(U, m, U, m, &kidx);

	int *mult = new int [kidx - 1];
	for (int i = 0; i < kidx - 1; ++i)
		mult[i] = ::get_knot_mult(p, n, U, knot[i + 1]);

	for (int i = 1; i < kidx; ++i)
		KnotRemove(knot[i], mult[i - 1]);

	delete [] knot;
	delete [] mult;
}

/*!
*	\brief 곡선을 방향을 역으로 바꾼다.
*/
void GNurbsCrv::Reverse()
{
	// 새로운 제어점과 낫 벡터 배열를 생성하고,
	int m = n + p + 1;
	GCtrlPt *Q = new GCtrlPt [n + 1];
	double *knot = new double [m + 1];

	// 새로운 제어점 배열을 생성하고,
	for (int i = 0; i < n + 1; ++i)
		Q[i] = P[n - i];

	// 새로운 낫 벡터를 생성한 후,
	for (int i = 0; i < m + 1; ++i)
		knot[m - i] = U[0] + U[m] - U[i];

	// 제어점 배열과 낫 벡터를 갱신한다.
	delete [] U;
	delete [] P;
	U = knot;
	P = Q;
}

/*!
*	\brief 곡선을 스케일 한다.
*
*	\param alpha 스케일 상수
*/
void GNurbsCrv::Scale(double alpha)
{
	for (int i = 0; i < n + 1; ++i)
	{
		P[i][0] = P[i][0] * alpha;
		P[i][1] = P[i][1] * alpha;
		P[i][2] = P[i][2] * alpha;
	}
}

/*!
*	\brief 곡선의 차수를 1 올린다.
*/
void GNurbsCrv::ElevateDeg()
{
	// Piecewise Bezier 곡선의 형태로 변환하고,
	CnvrtBzrForm();

	// Bezier 곡선의 개수, 차수, 제어점의 인덱스, 낫 벡터의 인덱스를 계산하고,
 	int snum = n / p; 
 	int new_p = p + 1;
 	int new_n = n + snum;
 	int new_m = new_n + new_p + 1;

	// 새로운 낫 벡터와 제어점 배열을 할당하고,
 	double *new_U = new double [new_m + 1];
 	GCtrlPt *new_P = new GCtrlPt [new_n + 1];
 
	// 새로운 낫 벡터를 구하고,
	int kidx;
 	double *knot = ::get_knot_merged_distinct(U, p + n + 1, U, p + n + 1, &kidx);
 	for (int i = 0; i < kidx + 1; ++i)
 		for (int j = 1; j < new_p + 1; ++j)
 			new_U[i * new_p + j] = knot[i];
 	new_U[0] = knot[0];
 	new_U[new_m] = knot[kidx];
 
 	// 새로운 제어점을 계산한다.
 	for (int i = 0; i < snum; ++i)
 	{
		new_P[i * new_p] = P[i * p];
 		new_P[(i + 1) * new_p] = P[(i + 1) * p];
 		for (int j = 1; j < p + 1; ++j)
 		{
 			double alpha = (double)j / (double)new_p;
 			new_P[i * new_p + j] = alpha * P[i * p + j - 1] + (1.0 - alpha) * P[i * p + j];
 		}
 	}

	// 이전 배열을 제거하고,
	delete [] U;
 	delete [] P;
 	delete [] knot;
 
	// 새로운 제어점과 낫 벡터를 설정한다.
 	this->p = new_p;
 	this->n = new_n;
 	this->U = new double [n + p + 2];
 	this->P = new GCtrlPt [n + 1];
	for (int i = 0; i < new_m + 1; ++i)
		U[i] = new_U[i];	
	for (int i = 0; i < new_n + 1; ++i)
	{
		P[i] = new_P[i];
		P[i].pMesh = this;
	}
 
	// 동적 할당된 임시 제어점과 낫 벡터를 메모리에서 해제한다.
 	delete [] new_U;
 	delete [] new_P;

	// B-spline 곡선의 형태로 복원한다.
	CnvrtBspForm();
}

/*!
*	\brief 곡선의 제어점의 위치를 편집한다.
*	\warning 4차원 곡선일 경우 dp=(dx, dy, dz, dw)이고, 3차원 유리식 곡선일 경우 dp=(dx, dy, dz, 0)의 형태가 되어야 함
*
*	\param idx 편집될 제어점의 인덱스
*	\param dp 제어점의 편집변위
*/
void GNurbsCrv::Edit(int idx, GVector4 dp)
{
	if (rational)
		dp[3] = 0.0;

	P[idx] += dp;
	if (closed)
	{
		if (idx < p)
			P[idx + (n - p + 1)] += dp;
		if (idx > n - p)
			P[idx - (n - p + 1)] += dp;
	}
}

/*!
*	\brief 곡선의 모델링 좌표계를 월드 좌표계로 갱신한다.
*
*	\param RefType 모델링 좌표계의 갱신을 위한 참조 형태(0: 월드 좌표계, 1: 경계상자 좌표계)
*/
void GNurbsCrv::UpdateMC(int RefType)
{
	if (RefType == 0)
	{
		// 월드 좌표계에서 표현된 제어점의 좌표를 구하고,
		int NumCtlPt = n + 1;
		for (int i = 0; i < NumCtlPt; ++i)
		{
			GPoint3 p(P[i][0], P[i][1], P[i][2]);
			p = MC * p;
			P[i][0] = p[0];
			P[i][1] = p[1];
			P[i][2] = p[2];
		}

		// 메쉬의 모델링 좌표계를 월드 좌표계로 설정
		MC = GTransf();
	}
	else
	{
		// 월드 좌표계에서 표현된 제어점의 좌표를 구하고,
		for (int i = 0; i < n + 1; ++i)
		{
			GPoint3 p(P[i][0], P[i][1], P[i][2]);
			p = MC * p;
			P[i][0] = p[0];
			P[i][1] = p[1];
			P[i][2] = p[2];
		}

		// 월드좌표계에서 표현된 경계상자의 변환을 계산하고,
		// 이 변환을 메쉬의 모델링 좌표계로 설정
		MC = BBox.GetMC();

		// 메쉬의 모델링 좌표계에서 표현된 정점의 좌표를 계산한다.
		for (int i = 0; i < n + 1; ++i)
		{
			GPoint3 p(P[i][0], P[i][1], P[i][2]);
			p = inv(MC) * p;
			P[i][0] = p[0];
			P[i][1] = p[1];
			P[i][2] = p[2];
		}
	}
	
	ModifiedFlag = MODIFIED_CTLPT_POS;
	UpdateMesh();
}

/*!
*	\brief	넙스 곡선의 정점의 위치를 갱신한다.
*/
void GNurbsCrv::UpdateMesh()
{
	// 갱신 정보에 따라서,
	switch (ModifiedFlag)
	{
		// 재질이 변경되었다면,
	case MODIFIED_MTL:
		UpdateBufFace();
		break;

	case MODIFIED_INTPT_POS:
		CreateMeshVert();
		UpdateBndBox(false);
		UpdateBufVertex();
		break;

	case MODIFIED_CTLPT_POS:
		CreateMeshVert();
		UpdateBndBox(false);
		UpdateBufVertex();
		break;

	case MODIFIED_NORMAL:
		UpdateNormal(false);
		UpdateBufNormal();
		break;

	case MODIFIED_SAMPLE_NUM:
	case MODIFIED_VERT_NUM:
	case MODIFIED_CTLPT_SIZE:
		CreateMesh();
		break;
	}

	ModifiedFlag = MODIFIED_NONE;	
}

/*!
*	\brief 곡선위의 한 점 C(u)가 주어진 dp 만큼 움직이도록 곡선의 제어점들의 위치를 수정
*	\warning 4차원 곡선일 경우 dp=(dx, dy, dz, dw)이고, 3차원 유리식 곡선일 경우 dp=(dx, dy, dz, 0)의 형태가 되어야 함
*
*	\param u 곡선위의 점에 대한 매개변수값
*	\param dp 곡선위의 점이 움직이 변위
*/
void GNurbsCrv::Edit(double u, GVector4 dp)
{
	double *basis = new double [p + 1];
	int idx = ::get_knot_span_idx(p, n, U, u);
	::get_gnurbs_basis(U, p, u, idx, basis);

	if (rational)
	{
		double w = 0.0;
		for (int i = 0; i < p + 1; i++)
			w += basis[i] * P[idx - p + i][3];	// 분모구하기

		for (int i = 0; i < p + 1; ++i)
			basis[i] = P[idx - p + i][3] * basis[i] / w;	// Rational 기저함수
	}

	double alpha = 0.0;
	for (int i = 0; i < p + 1; i++)
		alpha += SQR(basis[i]);

	for (int i = 0; i < p + 1; ++i)
		basis[i] = basis[i] / alpha;

	for (int i = 0; i < p + 1; ++i)
	{
		P[idx - p + i] += dp * basis[i];
		if (closed)
		{
			if (idx - p + i < p)
				P[idx - p + i + (n - p + 1)] += dp * basis[i];
			if (idx - p + i > n - p)
				P[idx - p + i - (n - p + 1)] += dp * basis[i];
		}
	}

	delete [] basis;
}

/*!
*	\brief 곡선위의 한 점 C(u)가 주어진 dp 만큼 움직이도록 곡선의 제어점들의 위치를 수정
*	\warning 4차원 곡선일 경우 dp=(dx, dy, dz, dw)이고, 3차원 유리식 곡선일 경우 dp=(dx, dy, dz, 0)의 형태가 되어야 함
*
*	\param u 곡선위의 점에 대한 매개변수값
*	\param dp 곡선위의 점이 움직이 변위
*	\param support 다중해상도 편집을 위한 곡선의 편집영역(0 ~ infinity: 값이 커질 수로 해상도 낮아짐)
*/
void GNurbsCrv::Edit(double u, GVector4 dp, int support)
{
	if (closed)	// 닫힌 곡선의 경우,
	{
		double *delta = new double [n - p + 1];
		for (int i = 0; i < n - p + 1; ++i)
			delta[i] = U[i + 1] - U[i];

		double *knot1 = new double [2 * (p + support + 1)];

		int idx = ::get_knot_span_idx(p, n, U, u);
		int a, b;
		a = b = idx % (n - p + 1);

		knot1[p + support] = U[idx];
		knot1[p + support + 1] = U[idx + 1];
		for (int i = 1; i < p + support + 1; ++i)
		{
			a--;
			if (a < 0)
				a = a + (n - p + 1);
			b++;
			if (b > n - p)
				b = b - (n - p + 1);

			knot1[p + support - i] = knot1[p + support - i + 1] - delta[a];
			knot1[p + support + 1 + i] = knot1[p + support + i] + delta[b];
		}

		double *knot2 = new double [2 * (p + 1)];
		ARR_COPY(knot2, knot1, p + 1);
		ARR_COPY((&knot2[p + 1]), (&knot1[p + 2 * support + 1]), p + 1);

		GNurbsCrv *pCrv = ::get_gnurbs_crv_degen(p, p, knot2, GVector4(0.0, 0.0, 0.0, 0.0), false);
		pCrv->Edit(u, dp);	

		for (int i = 0; i < 2 * support; ++i)
			pCrv->KnotInsert(knot1[p + 1 + i], 1);

		int min_idx = idx - support - p;
		if (min_idx < 0)
			min_idx = min_idx + (n - p + 1);

		for (int i = 0; i < pCrv->n + 1; ++i)
		{
			int k = (min_idx + i) % (n - p + 1); // 우측 구간 (P_{n-p+1}, P_{n-p+2}, P_n)
			P[k] += pCrv->P[i];

			if (k < p)		// 좌측 구간 (P_0, P_1, ..., P_{p-1})
				P[k + (n - p + 1)] += pCrv->P[i];
		}

		delete [] delta;
		delete [] knot1;
		delete [] knot2;
		delete pCrv;
	}
	else	// 열린 곡선인 경우,
	{
		double *knot = new double [p * 2 + 2];
		int idx = ::get_knot_span_idx(p, n, U, u);

		int min_idx = ((idx - support - p) < 0) ? 0 : idx - support - p;
		int max_idx = ((idx + support + p + 1) > p + n + 1) ? p + n + 1 : idx + support + p + 1;

		ARR_COPY(knot, (&U[min_idx]), p + 1);
		ARR_COPY((&knot[p + 1]), (&U[max_idx - p]), p + 1);

		GNurbsCrv *pCrv = ::get_gnurbs_crv_degen(p, p + 1, knot, GVector4(0.0, 0.0, 0.0, 0.0), false);
		pCrv->Edit(u, dp);

		for (int i = min_idx + p + 1; i < max_idx - p; ++i)
			pCrv->KnotInsert(U[i], 1);

		for (int i = 0; i < pCrv->n + 1; ++i)
			P[min_idx + i] += pCrv->P[i];			

		delete [] knot;
		delete pCrv;
	}
}

/*!
*	\brief 곡선의 제어점의 값을 반환한다.
*
*	\param idx 제어점의 인덱스
*
*	\return 곡선의 \a idx-번째 제어점을 반환한다.
*/
GVector4 GNurbsCrv::GetCtrlPt(int idx)
{
	return P[idx];
}

/*************************************/
/* Implementation of GNurbsSrf Class */
/*************************************/
IMPLEMENT_GMESH_OBJECT(GNurbsSrf)

/*!
*	\brief 객체가 포함된 메쉬의 포인터를 반환한다.
*
*	\return 객체가 포함된 메쉬의 포인터를 반환한다.
*/
GMesh *GNurbsSrf::GetRefMesh()
{
	return this;
}

/*!
*	\brief 객체의 모델링 좌표계를 반환한다.
*
*	\return 월드 좌표계에서 표현된 객체의 모델링 좌표계를 반환한다.
*/
GTransf GNurbsSrf::GetTransf()
{
	return MC;
}

/*!
*	\brief 선택된 객체를 편집한다.
*
*	\param EC 편집 좌표계
*	\param t 편집될 객체의 이동 변위
*	\param q 편집될 객체의 회전 변위
*	\param s 편집될 객체의 스케일 변위
*	\param pParentMesh 편집 객체의 부모 메쉬
*/
void GNurbsSrf::Edit(GTransf EC, GVector3 t, GQuater q, GVector3 s, GMesh *pParentMesh)
{
	GMesh::Edit(EC, t, q, s, pParentMesh);	
}

/*!
*	\brief 곡면의 모델링 좌표계를 월드 좌표계로 갱신한다.
*
*	\param RefType 모델링 좌표계의 갱신을 위한 참조 형태(0: 월드 좌표계, 1: 경계상자 좌표계)
*/
void GNurbsSrf::UpdateMC(int RefType)
{
	if (RefType == 0)
	{
		// 월드 좌표계에서 표현된 제어점의 좌표를 구하고,
		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				GPoint3 p(P[i][j][0], P[i][j][1], P[i][j][2]);
				p = MC * p;
				P[i][j][0] = p[0];
				P[i][j][1] = p[1];
				P[i][j][2] = p[2];
			}
		}

		// 메쉬의 모델링 좌표계를 월드 좌표계로 설정
		MC = GTransf();
	}
	else
	{
		// 월드 좌표계에서 표현된 제어점의 좌표를 구하고,
		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				GPoint3 p(P[i][j][0], P[i][j][1], P[i][j][2]);
				p = MC * p;
				P[i][j][0] = p[0];
				P[i][j][1] = p[1];
				P[i][j][2] = p[2];
			}
		}

		// 월드 좌표계에서 표현된 경계상자의 변환을 계산하고,
		// 이 변환을 곡면의 모델링 좌표계로 설정
		MC = BBox.GetMC();

		// 곡면의 모델링 좌표계에서 표현된 제어점의 좌표를 계산한다.
		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				GPoint3 p(P[i][j][0], P[i][j][1], P[i][j][2]);
				p = inv(MC) * p;
				P[i][j][0] = p[0];
				P[i][j][1] = p[1];
				P[i][j][2] = p[2];
			}
		}
	}
	
	ModifiedFlag = MODIFIED_CTLPT_POS;
	UpdateMesh();
}

/*!
*	\brief	곡면 메쉬의 정점 리스트를 다시 생성한다.
*/
void GNurbsSrf::UpdateMesh() 
{
	// 갱신 정보에 따라서,
	switch (ModifiedFlag)
	{
		// 재질이 변경되었다면,
	case MODIFIED_MTL:
		UpdateBufFace();
		break;

	case MODIFIED_INTPT_POS:
		CreateMeshVert();
		UpdateBndBox(false);
		UpdateBufVertex();
		break;

	case MODIFIED_CTLPT_POS:
		CreateMeshVert();
		UpdateBndBox(false);
		UpdateBufVertex();
		break;

	case MODIFIED_NORMAL:
		UpdateNormal(false);
		UpdateBufNormal();
		break;

	case MODIFIED_SAMPLE_NUM:
	case MODIFIED_VERT_NUM:
		CreateMesh();
		break;

	case MODIFIED_CTLPT_SIZE:
		break;
	}

	ModifiedFlag = MODIFIED_NONE;	
}

/*!
*	\brief 선택된 객체를 렌더링 한다.
*/
void GNurbsSrf::RenderForEdit(float r, float g, float b)
{
	GMesh::RenderForEdit(r, g, b);
}

/*!
*	\brief	넙스 곡면의 생성을 위한 낫 벡터와 제어점 배열을 동적으로 할당
*	
*	\param _p 곡면의 U-방향 차수
*	\param _m 곡면의 U-방향 제어점의 마지막 인덱스
*	\param _q 곡면의 V-방향 차수
*	\param _n 곡면의 V-방향 제어점의 마지막 인덱스
*/
void GNurbsSrf::_alloc(int _p, int _m, int _q, int _n)
{
	p = _p;
	m = _m;
	q = _q;
	n = _n;
	U = new double [p + m + 2];
	V = new double [q + n + 2];
	ARR_ALLOC_2D(P, GCtrlPt, m + 1, n + 1);
	for (int i = 0; i < m + 1; ++i)
		for (int j = 0; j < n + 1; ++j)
			P[i][j].pMesh = this;
}

/*!
*	\brief	넙스곡면의 낫 벡터와 제어점의 동적 배열을 해제
*/
void GNurbsSrf::_free()
{
	if (U != NULL)
		delete [] U;
	U = NULL;


	if (V != NULL)
		delete [] V;
	V = NULL;

	if (P != NULL)
	{
		for (int i = 0; i < m + 1; ++i)
			delete [] P[i];
		delete [] P;		
	}
	P = NULL;
}

/*!
*	\brief	디폴트 생성자
*/
GNurbsSrf::GNurbsSrf()
: GMesh("noname", GTransf(), FACE_QUAD, "")
{
	_alloc(0, 0, 0, 0);
	U[0] = 0.0;
	U[1] = 1.0;
	V[0] = 0.0;
	V[1] = 1.0;
	rational = false;
	closed_u = false;
	closed_v = false;
}

/*!
*	\brief	넙스곡면을 생성
*	
*	\param _Name 곡면의 이름
*	\param _MC 곡면의 모델링 좌표계
*	\param _p 곡면의 U-방향 차수
*	\param _m 곡면의 U-방향 제어점의 마지막 인덱스
*	\param _U 곡면의 U-방향 knot 벡터
*	\param _q 곡면의 V-방향 차수
*	\param _n 곡면의 V-방향 제어점의 마지막 인덱스
*	\param _V 곡면의 V-방향 knot 벡터
*	\param _P 곡면의 제어점
*	\param _rational 유리식 곡면 여부
*	\param _ParentName 부모 메쉬 곡면의 이름
*/
GNurbsSrf::GNurbsSrf(std::string _Name, GTransf _MC, int _p, int _m, double *_U, int _q, int _n, double *_V, GVector4 **_P, bool _rational, std::string _ParentName)
: GMesh(_Name, _MC, FACE_QUAD, _ParentName)
{
	_alloc(_p, _m, _q, _n);
	rational = _rational;
	closed_u = false;
	closed_v = false;

	ARR_COPY(U, _U, p + m + 2);
	ARR_COPY(V, _V, q + n + 2);
	for (int i = 0; i < m + 1; ++i)
		for (int j = 0; j < n + 1; ++j)
			P[i][j] = _P[i][j];
}

/*!
*	\brief	넙스곡면을 생성
*	
*	\param _Name 곡면의 이름
*	\param _MC 곡면의 모델링 좌표계
*	\param _p 곡면의 U-방향 차수
*	\param _m 곡면의 U-방향 제어점의 마지막 인덱스
*	\param _U 곡면의 U-방향 knot 벡터
*	\param _q 곡면의 V-방향 차수
*	\param _n 곡면의 V-방향 제어점의 마지막 인덱스
*	\param _V 곡면의 V-방향 knot 벡터
*	\param _P 곡면의 제어점 (P[0][0], P[0][1], ..., P[0][n], P[1][0], P[1][1], ..., P[1][n], ... , P[m][0], ... , P[m][n] 순으로 저장됨)  
*	\param _rational 유리식 곡면 여부
*	\param _ParentName 부모 메쉬 곡면의 이름
*/
GNurbsSrf::GNurbsSrf(std::string _Name, GTransf _MC, int _p, int _m, double *_U, int _q, int _n, double *_V, GVector4 *_P, bool _rational, std::string _ParentName)
: GMesh(_Name, _MC, FACE_QUAD, _ParentName)
{
	_alloc(_p, _m, _q, _n);
	rational = _rational;
	closed_u = false;
	closed_v = false;

	ARR_COPY(U, _U, p + m + 2);
	ARR_COPY(V, _V, q + n + 2);
	for (int i = 0; i < m + 1; ++i)
		for (int j = 0; j < n + 1; ++j)
			P[i][j] = _P[(n + 1 ) * i + j];
}

/*!
*	\brief	넙스곡면의 복사생성자
*
*	\param cpy 복사할 객체
*/
GNurbsSrf::GNurbsSrf(const GNurbsSrf &cpy)
: GMesh(cpy)
{
	_alloc(cpy.p, cpy.m, cpy.q, cpy.n);
	rational = cpy.rational;
	closed_u = cpy.closed_u;
	closed_v = cpy.closed_v;

	ARR_COPY(U, cpy.U, p + m + 2);
	ARR_COPY(V, cpy.V, q + n + 2);
	for (int i = 0; i < m + 1; ++i)
		for (int j = 0; j < n + 1; ++j)
			P[i][j] = cpy.P[i][j];	
}

/*!
*	\brief	넙스곡면의 소멸자
*/
GNurbsSrf::~GNurbsSrf()
{
	_free();
}

/*!
*	\brief	넙스곡면의 대입연산자 중복
*
*	\param rhs 대입될 넙스곡면 객체
*
*	\return 대입된 넙스곡면을 반환한다
*/
GNurbsSrf &GNurbsSrf::operator =(const GNurbsSrf &rhs)
{
	GMesh::operator =(rhs);

	_free();
	_alloc(rhs.p, rhs.m, rhs.q, rhs.n);
	rational = rhs.rational;
	closed_u = rhs.closed_u;
	closed_v = rhs.closed_v;

	ARR_COPY(U, rhs.U, p + m + 2);
	ARR_COPY(V, rhs.V, q + n + 2);
	for (int i = 0; i < m + 1; ++i)
		for (int j = 0; j < n + 1; ++j)
			P[i][j] = rhs.P[i][j];

	return *this;
}

/*!
*	\brief	넙스곡면의 렌더링을 위한 메쉬를 생성한다.
*/
void GNurbsSrf::CreateMesh()
{
	// 경계 정점의 리스트를 초기화 하고,
	InitBndryEdgeList();

	// 정점의 좌표를 생성하고,
	CreateMeshVert();

	// 텍스처 좌표를 생성하고,
	CreateMeshTex();

	// 삼각형 정보를 생성하고, 
	CreateMeshFace();

	// 정점의 법선을 계산하고,
	UpdateNormal(false);

	// 곡면의 바운딩 박스를 계산한다.
	UpdateBndBox(false);

	// 정점 버퍼와 인덱스 버퍼를 갱신한다.
	UpdateBufVertex();
	UpdateBufNormal();
	UpdateBufFace();
}


/*!
*	\brief	넙스곡면의 렌더링을 위한 정점의 리스트를 생성한다.
*/
void GNurbsSrf::CreateMeshVert()
{
	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
	int NumSampV = Renderer.NumSampV;
	double umin = 0.0, umax = 1.0, vmin = 0.0, vmax = 1.0;

	// 기존의 정점을 지우고, 
	Verts.clear();

	// 정의역을 계산하고,
	GetDomain(&umin, &umax, &vmin, &vmax);

	// 곡면위의 정점을 계산한다.
	GVector4 pt;
	for (int i = 0; i < NumSampU; ++i)
	{
		double u = umin + (umax - umin) * (double)i / (double)(NumSampU - 1);
		for (int j = 0; j < NumSampV; ++j)
		{
			double v = vmin + (vmax - vmin) * (double)j / (double)(NumSampV - 1);
			pt = Eval(u, v);
			GVertex vtx(GPoint3(pt[0], pt[1], pt[2]), GVector3(0.0, 0.0, 0.0));
			AddVertex(vtx);
		}
	}
}

/*!
*	\brief	넙스곡면의 렌더링을 위한 텍스처 리스트를 생성한다.
*/
void GNurbsSrf::CreateMeshTex()
{
	// 기존의 텍셀 정보를 지우고,
	Texs.clear();

	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
	int NumSampV = Renderer.NumSampV;

	// 텍스처 좌표를 생성하고 저장함
	for (int i = 0; i < NumSampU; ++i)
	{
		double s = (double)i / (double)(NumSampU - 1);
		for (int j = 0; j < NumSampV; ++j)
		{
			double t = (double)j / (double)(NumSampV - 1);
			AddTexel(GVector2(s, t));
		}
	}
}

/*!
*	\brief	넙스곡면의 렌더링을 위한 삼각형 리스트를 생성한다.
*/
void GNurbsSrf::CreateMeshFace()
{
	// 기존 삼각형을 지우고 삼각형 리스트를 새로 만드는 경우라면,
	// 기존 삼각형이 사용한 재질을 구한다.
	int PrevMtlIdx = -1;
	if (!Faces.empty())
		PrevMtlIdx = Faces[0].MtlIdx;

	// 삼각형 정보를 지우고,
	Faces.clear();

	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
	int NumSampV = Renderer.NumSampV;

	// 삼각형을 생성하고 추가한다.
	for (int i = 0; i < NumSampU - 1; ++i)
	{
		for(int j = 0; j < NumSampV - 1; ++j)
		{
			int vidx0 = i * NumSampV + j;
			int vidx1 = vidx0 + NumSampV;
			int vidx2 = vidx1 + 1;
			int vidx3 = vidx0 + 1;

			GFace f0(vidx0, vidx1, vidx2, vidx0, vidx1, vidx2, PrevMtlIdx);
			GFace f1(vidx0, vidx2, vidx3, vidx0, vidx2, vidx3, PrevMtlIdx);
			AddFace(f0);
			AddFace(f1);
		}
	}
}

/*!
*	\brief	넙스 곡면위의 점을 계산
*
*	\param u U-방향 매개변수의 값
*
*	\return 곡면위의 점 S(u, v)의 위치를 계산
*/
GVector4 GNurbsSrf::Eval(double u, ...)
{
	double v;
	va_list ap;
	va_start(ap, u);
	v = va_arg(ap, double);
	va_end(ap);

	double *basis_u = new double [p + 1];
	double *basis_v = new double [q + 1];

	int idx_u = ::get_knot_span_idx(p, m, U, u);
	::get_gnurbs_basis(U, p, u, idx_u, basis_u);

	int idx_v = ::get_knot_span_idx(q, n, V, v);
	::get_gnurbs_basis(V, q, v, idx_v, basis_v);

	GVector4 pt;
	if (rational)
	{
		for (int i = 0; i < p + 1; i++)
		{
			GVector4 tmp;
			int s = idx_u - p + i;

			for (int j = 0; j < q + 1; j++)
			{
				int t = idx_v - q + j;
				tmp += basis_v[j] * homogenize(P[s][t]);
			}
			pt += basis_u[i] * tmp;
		}
		pt = cartesianize(pt);
	}
	else
	{
		for (int i = 0; i < p + 1; i++)
		{
			GVector4 tmp;
			int s = idx_u - p + i;

			for (int j = 0; j < q + 1; j++)
			{
				int t = idx_v - q + j;
				tmp += basis_v[j] * P[s][t];
			}
			pt += basis_u[i] * tmp;
		}
	}

	delete [] basis_u;
	delete [] basis_v;
	return pt;
}

/*!
*	\brief	넙스 곡면을 렌더링 한다.
*
*	\param bSubMesh 서브 메쉬의 렌더링 여부(선택 모드에서는 false로 설정)
*/
void GNurbsSrf::Render(bool bSubMesh)
{
	GMesh::Render(bSubMesh);

	glPushMatrix();
	{
		// 월드 좌표계에서 객체의 모델링 좌표계로의 변환하고,
		glMultMatrixd(cast_mat(MC).M);

		// 곡면의 제어점을 렌더링할 경우,
		if (Renderer.RenderType & RENDER_CTRL_PT)
		{
			double size = Renderer.CtrlPtSize;

			// 재질을 설정하고,
			GMaterial Mat;
			Mat.SetAmbient(0.7f, 0.7f, 0.7f);
			Mat.SetDiffuse(0.7f, 0.7f, 0.7f);
			Mat.SetSpecular(0.7f, 0.7f, 0.7f);
			Mat.Enable(false);

			// 모든 제어점을 렌더링하고,
			for (int i = 0; i < m + 1; ++i)
			{
				for (int j = 0; j < n + 1; ++j)
				{
					if ((i == 0 && j == 0) || (i == m && j == n))
						continue;

					glPushMatrix();
					glTranslated(P[i][j][0], P[i][j][1], P[i][j][2]);
					glutSolidSphere(size, 10, 10);
					glPopMatrix();
				}
			}

			// 시작 제어점을 빨간색으로, 
			Mat.SetAmbient(0.7f, 0.0f, 0.0f);
			Mat.SetDiffuse(0.7f, 0.0f, 0.0f);
			Mat.SetSpecular(0.7f, 0.0f, 0.0f);
			Mat.Enable(false);
			glPushMatrix();
			glTranslated(P[0][0][0], P[0][0][1], P[0][0][2]);
			glutSolidSphere(size, 10, 10);
			glPopMatrix();

			// 끝 제어점을 파란색으로, 
			Mat.SetAmbient(0.0f, 0.0f, 0.7f);
			Mat.SetDiffuse(0.0f, 0.0f, 0.7f);
			Mat.SetSpecular(0.0f, 0.0f, 0.7f);
			Mat.Enable(false);
			glPushMatrix();
			glTranslated(P[m][n][0], P[m][n][1], P[m][n][2]);
			glutSolidSphere(size, 10, 10);
			glPopMatrix();

			// 제어 메쉬도 렌더링 한다.
			glDisable(GL_LIGHTING);
			glLineWidth(2.0);
			glColor3d(0.0, 0.0, 1.0);
			for (int i = 0; i < n + 1; i++)
			{
				glBegin(GL_LINE_STRIP);
				for (int j = 0; j < m + 1; j++)
				{
					glVertex3d(P[j][i][0], P[j][i][1], P[j][i][2]);
				}
				glEnd();
			}
			glColor3d(0.0, 0.0, 1.0);
			for (int i = 0; i < m + 1; i++)
			{
				glBegin(GL_LINE_STRIP);
				for (int j = 0; j < n + 1; j++)
				{
					glVertex3d(P[i][j][0], P[i][j][1], P[i][j][2]);
				}
				glEnd();
			}
			glLineWidth(1.0);
			glEnable(GL_LIGHTING);

// 			double r = size * 0.4;
// 			if (pObj == NULL)
// 			{
// 				pObj = gluNewQuadric();
// 				gluQuadricDrawStyle(pObj, GLU_FILL);
// 				gluQuadricNormals(pObj, GLU_SMOOTH);
// 			}
// 
// 			// U-방향
// 			Mat.SetAmbient(0.0f, 0.7f, 0.0f, 1.0f);
// 			Mat.SetDiffuse(0.0f, 0.7f, 0.0f, 1.0f);
// 			Mat.SetSpecular(0.7f, 0.7f, 0.7f, 1.0f);
// 			Mat.Enable();
// 			for (int i = 0; i < n + 1; i++)
// 			{
// 				for (int j = 0; j < m; j++)
// 				{
// 					GVector3 l = cast_vec3(P[j + 1][i] - P[j][i]);
// 					double len = norm(l);
// 					GQuater q;
// 					q.SetFromArcBall(GVector3(0.0, 0.0, 1.0), l);
// 					GTransf X(cast_vec3(P[j][i]), q);
// 					glPushMatrix();
// 					{
// 						glMultMatrixd(cast_arr(cast_mat(X)));
// 						gluCylinder(pObj, r, r, len, 20, 20);
// 					}
// 					glPopMatrix();
// 				}
// 			}
// 
// 			// V 방향
// 			Mat.SetAmbient(0.0f, 0.0f, 0.7f, 1.0f);
// 			Mat.SetDiffuse(0.0f, 0.0f, 0.7f, 1.0f);
// 			Mat.SetSpecular(0.7f, 0.7f, 0.7f, 1.0f);
// 			Mat.Enable();
// 			for (int i = 0; i < m + 1; i++)
// 			{
// 				for (int j = 0; j < n; j++)
// 				{
// 					GVector3 l = cast_vec3(P[i][j + 1] - P[i][j]);
// 					double len = norm(l);
// 					GQuater q;
// 					q.SetFromArcBall(GVector3(0.0, 0.0, 1.0), l);
// 					GTransf X(cast_vec3(P[i][j]), q);
// 					glPushMatrix();
// 					{
// 						glMultMatrixd(cast_arr(cast_mat(X)));
// 						gluCylinder(pObj, r, r, len, 20, 20);
// 					}
// 					glPopMatrix();
// 				}
// 			}
		}
	}
	glPopMatrix();
}

/*!
*	\brief	곡면위의 점 S(u, v)의 접평면(Tangent Plane)의 기저 Su, Sv를 구함
*	
*	\param u U-방향 매개변수 값
*	\param v V-방향 매개변수 값
*	\param Su U-방향 1차 미분 벡터값이 저장됨
*	\param Sv V-방향 1차 미분 벡터값이 저장됨
*	\param N 곡면의 법선 벡터가 저장됨
*/
void GNurbsSrf::EvalTanPln(double u, double v, GVector3 &Su, GVector3 &Sv, GVector3 &N)
{
	Su = cast_vec3(EvalDeriv(u, v, 1, 0));
	Sv = cast_vec3(EvalDeriv(u, v, 0, 1));
	N = Su ^ Sv;
}

/*!
*	\brief	넙스 곡면의 도함수를 계산
*
*	\param u U-방향 매개변수의 값
*	\param v V-방향 매개변수의 값
*	\param kth U-방향 미분차수
*	\param lth V-방향 미분차수
*
*	\return U-방향 \a kth차, V-방향 \a lth차 미분한 곡면 위의 점 S(u, v)의 도함수를 반환
*/
GVector4 GNurbsSrf::EvalDeriv(double u, double v, int kth, int lth)
{
	int idx_u = ::get_knot_span_idx(p, m, U, u);
	int idx_v = ::get_knot_span_idx(q, n, V, v);

	double *deriv_basis_u = new double [(p + 1) * (p + 1)];
	double *deriv_basis_v = new double [(q + 1) * (q + 1)];
	::get_gnurbs_deriv_basis(U, p, u, idx_u, kth, deriv_basis_u);
	::get_gnurbs_deriv_basis(V, q, v, idx_v, lth, deriv_basis_v);

	GVector4 pt;
	if (rational)
	{
		int d = kth + lth;
		GVector4 **Aders = new GVector4 *[d + 1]; 
		GVector4 **SKL = new GVector4 *[d + 1];
		for (int i = 0; i < d + 1; ++i)
		{
			Aders[i] = new GVector4 [d + 1];
			SKL[i] = new GVector4 [d + 1];
		}

		for (int i = 0; i < d + 1; ++i)
		{
			for (int j = 0; j < d + 1; ++j)
			{
				if (i > p || j > q)
					continue;
				for (int k = 0; k < q + 1; ++k)
				{
					GVector4 tmp;
					for (int l = 0; l < p + 1; ++l)
						tmp += deriv_basis_u[i * (p + 1) + l] * homogenize(P[idx_u - p + l][idx_v - q + k]);

					Aders[i][j] += deriv_basis_v[j * (q + 1) + k] * tmp;
				}
			}
		}

		for (int k = 0; k < d + 1; ++k)
		{
			GVector4 v;
			for (int l = 0; l < d - k + 1; ++l)
			{
				v = Aders[k][l];
				for (int j = 1; j < l + 1; ++j)
				{
					v -= Bin[l * (l + 1) / 2 + j] * Aders[0][j][3] * SKL[k][l - j];
				}
				for (int i = 1; i < k + 1; ++i)
				{
					v -= Bin[k * (k + 1) / 2 + i] * Aders[i][0][3] * SKL[k - i][l];

					GVector4 v2;
					for (int j = 1; j < l + 1; ++j)
					{
						v2 += Bin[l * (l + 1) / 2 + j] * Aders[i][j][3] * SKL[k - i][l - j];
					}
					v -= Bin[k * (k + 1) / 2 + i] * v2;
				}
				SKL[k][l] = v / Aders[0][0][3];
			}
		}
		pt = SKL[kth][lth];

		for (int i = 0; i < d + 1; ++i)
		{
			delete [] Aders[i];
			delete [] SKL[i];
		}
		delete [] Aders;
		delete [] SKL;
	}
	else
	{
		for (int i = 0; i < p + 1; i++)
		{
			GVector4 tmp;
			int s = idx_u - p + i;

			for (int j = 0; j < q + 1; j++)
			{
				int t = idx_v - q + j;
				tmp += deriv_basis_v[lth * (q + 1) + j] * P[s][t];
			}
			pt += deriv_basis_u[kth * (p + 1) + i] * tmp;
		}
	}

	delete [] deriv_basis_u;
	delete [] deriv_basis_v;

	return pt;
}

/*!
*	\brief 곡면의 낫 벡터를 clamped 형태로 변형하고 해당 제어점을 구함
*
*	\param dir_u U-방향 실행 여부
*	\param dir_v V-방향 실행 여부
*/
void GNurbsSrf::KnotClamped(bool dir_u, bool dir_v)
{
	if (dir_u)
	{
		double min = U[p];
		double max = U[m + 1];
		int saved_m = m, saved_r = p + m + 1;

		// 이전 낫 벡터 저장
		double *saved_U = new double [saved_r + 1];
		double *saved_V = new double [q + n + 2];
		ARR_COPY(saved_U, U, saved_r + 1);
		ARR_COPY(saved_V, V, q + n + 2);

		// 새로운 제어점 배열 할당
		GCtrlPt **Q = new GCtrlPt *[saved_m + 1];
		for (int i = 0; i < saved_m + 1; ++i)
			Q[i] = new GCtrlPt [n + 1];

		int mul = ::get_knot_mult(p, m, U, min);
		int r = (p - mul < 0) ? 0 : (p - mul);
		if (mul != p + 1)	// 왼쪽 unclamped 형태라면
			KnotInsert(0, min, p - mul);

		mul = ::get_knot_mult(p, m, U, max);
		if (mul != p + 1)	// 오른쪽 unclamped 형태라면
			KnotInsert(0, max, p - mul);

		for (int i = r; i < r + saved_m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				Q[i - r][j] = P[i][j];
				Q[i - r][j].pMesh = P[i][j].pMesh;
			}
		}

		for (int i = 0; i < p; ++i)
		{
			saved_U[i] = min;
			saved_U[saved_r - i] = max;
		}

		_free();
		P = Q;
		U = saved_U;
		V = saved_V;
		m = saved_m;
	}

	if (dir_v)
	{
		double min = V[q];
		double max = V[n + 1];
		int saved_n = n, saved_s = q + n + 1;

		// 이전 낫 벡터 저장
		double *saved_U = new double [p + m + 2];
		double *saved_V = new double [saved_s + 1];
		ARR_COPY(saved_U, U, p + m + 2);
		ARR_COPY(saved_V, V, saved_s + 1);

		// 새로운 제어점 배열 할당
		GCtrlPt **Q = new GCtrlPt *[m + 1];
		for (int i = 0; i < m + 1; ++i)
			Q[i] = new GCtrlPt [saved_n + 1];

		int mul = ::get_knot_mult(q, n, V, min);
		int r = (q - mul < 0) ? 0 : (q - mul);
		if (mul != q + 1)	// 왼쪽 unclamped 형태라면
			KnotInsert(1, min, q - mul);

		mul = ::get_knot_mult(q, n, V, max);
		if (mul != q + 1)	// 오른쪽 unclamped 형태라면
			KnotInsert(1, max, q - mul);

		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = r; j < r + saved_n + 1; ++j)
			{
				Q[i][j - r] = P[i][j];
				Q[i][j - r].pMesh = P[i][j].pMesh;
			}
		}

		for (int i = 0; i < q; ++i)
		{
			saved_V[i] = min;
			saved_V[saved_s - i] = max;
		}

		_free();
		P = Q;
		U = saved_U;
		V = saved_V;
		n = saved_n;
	}
}

/*!
*	\brief 곡면의 낫 벡터를 unclamped 형태로 변형하고 해당 제어점을 구함
*
*	\param dir_u U-방향 실행 여부
*	\param dir_v V-방향 실행 여부
*/
void GNurbsSrf::KnotUnclamped(bool dir_u, bool dir_v)
{
	if (dir_u)
	{
		double min = U[p];
		double max = U[m + 1];

		GVector4 **Pw = new GVector4 *[m + 1];
		for (int i = 0; i < m + 1; ++i)
			Pw[i] = new GVector4 [n + 1];

		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				if (rational)
					Pw[i][j] = ::homogenize(P[i][j]);
				else
					Pw[i][j] = P[i][j];
			}
		}

		int mul = ::get_knot_mult(p, m, U, min);
		if (mul == p + 1)		// 왼쪽 clamped된 경우라면
		{
			for (int i = 0; i <= p - 2; ++i)	// Unclamp at left end
			{
				U[p - i - 1] = U[p - i] - (U[m - i + 1] - U[m - i]);
				int k = p - 1;
				for (int j = i; j >= 0; --j)
				{
					double alpha = (U[p] - U[k]) / (U[p + j + 1] - U[k]);
					for (int l = 0; l < n + 1; ++l)
					{
						Pw[j][l] = (Pw[j][l] - alpha * Pw[j + 1][l]) / (1.0 - alpha);
					}
					k = k - 1;
				}
			}
			U[0] = U[1] - (U[m - p + 2] - U[m - p + 1]);	// Set first knot
		}

		mul = ::get_knot_mult(p, m, U, max);
		if (mul == p + 1)		// 오른쪽 clamped된 경우라면
		{
			for (int i = 0; i <= p - 2; ++i)	// Unclamp at right end
			{
				U[m + i + 2] = U[m + i + 1] + (U[p + i + 1] - U[p + i]);
				for (int j = i; j >= 0; --j)
				{
					double alpha = (U[m + 1] - U[m - j]) / (U[m - j + i + 2] - U[m - j]);
					for (int l = 0; l < n + 1; ++l)
					{
						Pw[m - j][l] = (Pw[m - j][l] - (1.0 - alpha) * Pw[m - j - 1][l]) / alpha;
					}
				}
			}
			U[m + p + 1] = U[m + p] + (U[2 * p] - U[2 * p - 1]);	// Set last knot
		}

		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				if (rational)
					P[i][j] = rationalize(Pw[i][j]);
				else
					P[i][j] = Pw[i][j];
			}
		}

		for (int i = 0; i < m + 1; ++i)
			delete [] Pw[i];
		delete [] Pw;
	}

	if (dir_v)
	{
		double min = V[q];
		double max = V[n + 1];

		GVector4 **Pw = new GVector4 *[m + 1];
		for (int i = 0; i < m + 1; ++i)
			Pw[i] = new GVector4 [n + 1];

		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				if (rational)
					Pw[i][j] = ::homogenize(P[i][j]);
				else
					Pw[i][j] = P[i][j];
			}
		}

		int mul = ::get_knot_mult(q, n, V, min);
		if (mul == q + 1)		// 왼쪽 clamped된 경우라면
		{
			for (int i = 0; i <= q - 2; ++i)	// Unclamp at left end
			{
				V[q - i - 1] = V[q - i] - (V[n - i + 1] - V[n - i]);
				int k = q - 1;
				for (int j = i; j >= 0; --j)
				{
					double alpha = (V[q] - V[k]) / (V[q + j + 1] - V[k]);
					for (int l = 0; l < m + 1; ++l)
					{
						Pw[l][j] = (Pw[l][j] - alpha * Pw[l][j + 1]) / (1.0 - alpha);
					}
					k = k - 1;
				}
			}
			V[0] = V[1] - (V[n - q + 2] - V[n - q + 1]);	// Set first knot
		}

		mul = ::get_knot_mult(q, n, V, max);
		if (mul == q + 1)		// 오른쪽 clamped된 경우라면
		{
			for (int i = 0; i <= q - 2; ++i)	// Unclamp at right end
			{
				V[n + i + 2] = V[n + i + 1] + (V[q + i + 1] - V[q + i]);
				for (int j = i; j >= 0; --j)
				{
					double alpha = (V[n + 1] - V[n - j]) / (V[n - j + i + 2] - V[n - j]);
					for (int l = 0; l < m + 1; ++l)
					{
						Pw[l][n - j] = (Pw[l][n - j] - (1.0 - alpha) * Pw[l][n - j - 1]) / alpha;
					}
				}
			}
			V[n + q + 1] = V[n + q] + (V[2 * q] - V[2 * q - 1]);	// Set last knot
		}

		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				if (rational)
					P[i][j] = rationalize(Pw[i][j]);
				else
					P[i][j] = Pw[i][j];
			}
		}

		for (int i = 0; i < m + 1; ++i)
			delete [] Pw[i];
		delete [] Pw;
	}
}

/*!
*	\brief	넙스곡면의 낫 벡터에 새로운 낫 \a val을 삽입한다.
*
*	\param dirType 0: U-방향, 1: V-방향
*	\param val 삽입될 낫 값
*	\param r 삽입회수
*
*	\return 실제 삽입된 횟수 반환
*/
int GNurbsSrf::KnotInsert(int dirType, double val, int r)
{
	if (dirType == 0) // U-방향 
	{
		// 낫의 반복수를 구함
		int mul = ::get_knot_mult(p, m, U, val);
		if (r + mul > p)
			r = p - mul;	// 반복수 조정

		if (r < 1)
			return r;

		// 폐곡선의 경우, clamped 낫 벡터로 변경
		bool flag = false;
		if (closed_u)
		{
			closed_u = false;
			flag = true;
			KnotClamped(true, false);
		}

		// 새로운 낫 벡터와 제어점 배열 생성
		double *nU = new double [p + m + 2 + r];
		double *nV = new double [q + n + 2];	
		ARR_COPY(nV, V, q + n + 2);	// 이전 V-방향 낫 벡터를 저장함

		GCtrlPt **nP = new GCtrlPt *[m + 1 + r];
		for (int i = 0; i < m + 1 + r; ++i)
			nP[i] = new GCtrlPt [n + 1];

		// U-방향 낫 추가를 (n + 1)번 수행
		GCtrlPt *tmp1 = new GCtrlPt [m + 1];
		GCtrlPt *tmp2 = new GCtrlPt [m + 1 + r];
		for (int i = 0; i < n + 1; ++i)
		{
			for (int j = 0; j < m + 1; ++j)
				tmp1[j] = P[j][i];

			// 낫 추가하고 새로운 제어점을 계산 
			::knot_insert(p, m, U, tmp1, val, r, nU, tmp2, rational);

			for (int j = 0; j < m + 1 + r; ++j)
			{
				nP[j][i] = tmp2[j];
				nP[j][i].pMesh = this;
			}
		}
		delete [] tmp1;
		delete [] tmp2;

		// 새로운 제어점과 낫 벡터 설정
		_free();
		m = m + r;
		_alloc(p, m, q, n);

		ARR_COPY(U, nU, p + m + 2);
		ARR_COPY(V, nV, q + n + 2);

		for (int i = 0; i < m + 1; ++i)
			for (int j = 0; j < n + 1; ++j)
				P[i][j] = nP[i][j];

		delete [] nU;
		delete [] nV;
		for (int i = 0; i < m + 1; ++i)
			delete [] nP[i];
		delete [] nP;


		// 폐곡선의 경우, unclamped 낫 벡터로 복원
		if (flag)
		{
			closed_u = true;
			KnotUnclamped(true, false);
		}

		return r;
	}

	if (dirType == 1) // V-방향
	{
		// 낫의 반복수를 구함
		int mul = ::get_knot_mult(q, n, V, val);
		if (r + mul > q)
			r = q - mul;	// 반복수 조정

		if (r < 1)
			return r;

		// 폐곡선의 경우, clamped 낫 벡터로 변경
		bool flag = false;
		if (closed_v)
		{
			closed_v = false;
			flag = true;
			KnotClamped(false, true);
		}

		// 새로운 낫 벡터와 제어점 배열 생성
		double *nU = new double [p + m + 2];
		double *nV = new double [q + n + 2 + r];	
		ARR_COPY(nU, U, p + m + 2);	// 이전 U-방향 낫 벡터를 저장함

		GCtrlPt **nP = new GCtrlPt *[m + 1];
		for (int i = 0; i < m + 1; ++i)
			nP[i] = new GCtrlPt [n + 1 + r];

		// V-방향 낫 추가를 (m + 1)번 수행
		GCtrlPt *tmp1 = new GCtrlPt [n + 1];
		GCtrlPt *tmp2 = new GCtrlPt [n + 1 + r];
		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
				tmp1[j] = P[i][j];

			// 낫 추가하고 새로운 제어점을 계산 
			::knot_insert(q, n, V, tmp1, val, r, nV, tmp2, rational);

			for (int j = 0; j < n + 1 + r; ++j)
			{
				nP[i][j] = tmp2[j];
				nP[i][j].pMesh = this;
			}
		}
		delete [] tmp1;
		delete [] tmp2;

		// 새로운 제어점과 낫 벡터 설정
		_free();
		n = n + r;
		_alloc(p, m, q, n);

		ARR_COPY(U, nU, p + m + 2);
		ARR_COPY(V, nV, q + n + 2);

		for (int i = 0; i < m + 1; ++i)
			for (int j = 0; j < n + 1; ++j)
				P[i][j] = nP[i][j];

		delete [] nU;
		delete [] nV;
		for (int i = 0; i < m + 1; ++i)
			delete [] nP[i];
		delete [] nP;

		// 폐곡선의 경우, unclamped 낫 벡터로 복원
		if (flag)
		{
			closed_v = true;
			KnotUnclamped(false, true);
		}

		return r;
	}

	return -1;
}

/*!
*	\brief	넙스곡면의 낫 벡터에 낫을 제거
*
*	\param dirType 0: U-방향, 1: V-방향
*	\param val 제거할 낫 값
*	\param r 제거회수
*
*	\return 실제 제거된 횟수 반환
*/
int GNurbsSrf::KnotRemove(int dirType, double val, int r)
{
	if (dirType == 0)	// U-방향
	{
		int mul = ::get_knot_mult(p, m, U, val);
		r = MIN(r, mul);

		GCtrlPt *tmpP = new GCtrlPt [m + 1];
		double *tmpU = new double [p + m + 2];
		ARR_COPY(tmpU, U, p + m + 2);

		// U-방향 첫번째 제어점들에 대하여 낫 제거를 수행 
		for (int i = 0; i < m + 1; ++i)
			tmpP[i] = P[i][0];
		int scs = ::knot_remove(p, m, tmpU, tmpP, val, r, rational);
		if (scs == 0)
			return scs;

		// 새로운 제어점 배열 생성 및 복사
		int new_m = m - scs;
		GCtrlPt **nP = new GCtrlPt *[new_m + 1];
		for (int i = 0; i < new_m + 1; ++i)
			nP[i] = new GCtrlPt [n + 1];

		// U-방향 제어점들에 대하여 낫 제거를 수행 
		for (int i = 0; i < n + 1; ++i)
		{
			for (int j = 0; j < m + 1; ++j)
				tmpP[j] = P[j][i];

			ARR_COPY(tmpU, U, p + m + 2);
			int scs_curr = ::knot_remove(p, m, tmpU, tmpP, val, r, rational);
			if (scs != scs_curr)
			{
				delete [] tmpP;
				delete [] tmpU;
				for (int j = 0; j < new_m + 1; ++j)
					delete [] nP[j];
				delete [] nP;

				return 0;
			}

			// 제어점 복사
			for (int j = 0; j < new_m + 1; ++j)
			{
				nP[j][i] = tmpP[j];
				nP[j][i].pMesh = this;
			}
		}

		// 새로운 낫 벡터 생성 및 복사
		double *nU = new double [p + new_m + 2];
		double *nV = new double [q + n + 2];
		ARR_COPY(nU, tmpU, p + new_m + 2);
		ARR_COPY(nV, V, q + n + 2);

		// 메모리 해제
		_free();
		delete [] tmpP;
		delete [] tmpU;

		// 곡면의 변경된 상태 설정
		m = new_m;
		U = nU;
		n = n;
		V = nV;
		P = nP;

		return scs;
	}

	if (dirType == 1)	// V-방향
	{
		int mul = ::get_knot_mult(q, n, V, val);
		r = MIN(r, mul);

		GCtrlPt *tmpP = new GCtrlPt [n + 1];
		double *tmpV = new double [q + n + 2];
		ARR_COPY(tmpV, V, q + n + 2);

		// V-방향 첫번째 제어점들에 대하여 낫 제거를 수행 
		for (int i = 0; i < n + 1; ++i)
			tmpP[i] = P[0][i];
		int scs = ::knot_remove(q, n, tmpV, tmpP, val, r, rational);
		if (scs == 0)
			return scs;

		// 새로운 제어점 배열 생성 및 복사
		int new_n = n - scs;
		GCtrlPt **nP = new GCtrlPt *[m + 1];
		for (int i = 0; i < m + 1; ++i)
			nP[i] = new GCtrlPt [new_n + 1];

		// V-방향 제어점들에 대하여 낫 제거를 수행 
		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
				tmpP[j] = P[i][j];

			ARR_COPY(tmpV, V, q + n + 2);
			int scs_curr = ::knot_remove(q, n, tmpV, tmpP, val, r, rational);
			if (scs != scs_curr)
			{
				delete [] tmpP;
				delete [] tmpV;
				for (int j = 0; j < m + 1; ++j)
					delete [] nP[j];
				delete [] nP;

				return 0;
			}

			// 제어점 복사
			for (int j = 0; j < new_n + 1; ++j)
			{
				nP[i][j] = tmpP[j];
				nP[i][j].pMesh = this;
			}
		}

		// 새로운 낫 벡터 생성 및 복사
		double *nU = new double [p + m + 2];
		double *nV = new double [q + new_n + 2];
		ARR_COPY(nU, U, p + m + 2);
		ARR_COPY(nV, tmpV, q + new_n + 2);

		// 메모리 해제
		_free();
		delete [] tmpP;
		delete [] tmpV;

		// 곡면의 변경된 상태 설정
		n = new_n;
		U = nU;
		m = m;
		V = nV;
		P = nP;

		return scs;
	}

	return -1;
}

/*!
*	\brief 모든 낫 span에 중간 낫 값을 추가함
*
*	\param dir_u U-방향 refine 여부
*	\param dir_v V-방향 refine 여부
*/
void GNurbsSrf::KnotRefine(bool dir_u, bool dir_v)
{
	if (dir_u)
	{
		int saved_m = m;
		double *knot = new double [p + m + 2];
		ARR_COPY(knot, U, p + m + 2);

		for (int i = p; i < saved_m + 1; i++)
		{
			double u = (knot[i] + knot[i + 1]) * 0.5;
			KnotInsert(0, u, 1);
		}

		delete [] knot;
	}

	if (dir_v)
	{
		int saved_n = n;
		double *knot = new double [q + n + 2];
		ARR_COPY(knot, V, q + n + 2);

		for (int i = q; i < saved_n + 1; i++)
		{
			double v = (knot[i] + knot[i + 1]) * 0.5;
			KnotInsert(1, v, 1);
		}

		delete [] knot;
	}
}

/*!
*	\brief 곡면의 차수를 하나 올린다.
*
*	\param dir_u U-방향 실행 여부
*	\param dir_v V-방향 실행 여부
*/
void GNurbsSrf::ElevateDeg(bool dir_u, bool dir_v)
{
	if (dir_u)
	{
		// U-방향 piecewise Bezier 곡면의 형태로 변환하고,
		CnvrtBzrForm(true, false);

		// U-방향 Bezier 곡면의 개수, 차수, 제어점의 인덱스, 낫 벡터의 인덱스를 계산하고,
		int snum = m / p; 
		int new_p = p + 1;
		int new_m = m + snum;
		int new_r = new_p + new_m + 1;

		// 새로운 낫 벡터와 제어점 배열을 할당하고,
		double *new_U = new double [new_r + 1];
		GCtrlPt **new_P = new GCtrlPt *[new_m + 1];
		for (int i = 0; i < new_m + 1; ++i)
			new_P[i] = new GCtrlPt [n + 1];

		// 새로운 낫 벡터를 구하고,
		int kidx;
		double *knot = ::get_knot_merged_distinct(U, p + m + 1, U, p + m + 1, &kidx);
		for (int i = 0; i < kidx + 1; ++i)
			for (int j = 1; j < new_p + 1; ++j)
				new_U[i * new_p + j] = knot[i];
		new_U[0] = knot[0];
		new_U[new_r] = knot[kidx];

		// 새로운 제어점을 계산한다.
		for (int i = 0; i < snum; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				new_P[i * new_p][j] = P[i * p][j];
				new_P[(i + 1) * new_p][j] = P[(i + 1) * p][j];
			}
			
			for (int j = 1; j < p + 1; ++j)
			{
				double alpha = (double)j / (double)new_p;
				for (int k = 0; k < n + 1; ++k)
					new_P[i * new_p + j][k] = alpha * P[i * p + j - 1][k] + (1.0 - alpha) * P[i * p + j][k];
			}
		}

		// 이전 배열을 제거하고,
		delete [] U;
		for (int i = 0; i < m + 1; ++i)
			delete [] P[i];
		delete [] P;
		delete [] knot;

		// 새로운 제어점과 낫 벡터를 설정한다.
		this->p = new_p;
		this->m = new_m;
		this->U = new double [p + m + 2];
		this->P = new GCtrlPt *[m + 1];
		for (int i = 0; i < m + 1; ++i)
			P[i] = new GCtrlPt [n + 1];

		for (int i = 0; i < new_r + 1; ++i)
			U[i] = new_U[i];

		for (int i = 0; i < new_m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				P[i][j] = new_P[i][j];
				P[i][j].pMesh = this;
			}
		}

		// 동적 할당된 임시 제어점과 낫 벡터를 메모리에서 해제한다.
		delete [] new_U;
		for (int i = 0; i < new_m + 1; ++i)
			delete [] new_P[i];
		delete [] new_P;

		// B-spline 곡선의 형태로 복원한다.
		CnvrtBspForm(true, false);
	}

	if (dir_v)
	{
		// V-방향 piecewise Bezier 곡면의 형태로 변환하고,
		CnvrtBzrForm(false, true);

		// V-방향 Bezier 곡면의 개수, 차수, 제어점의 인덱스, 낫 벡터의 인덱스를 계산하고,
		int snum = n / q; 
		int new_q = q + 1;
		int new_n = n + snum;
		int new_s = new_q + new_n + 1;

		// 새로운 낫 벡터와 제어점 배열을 할당하고,
		double *new_V = new double [new_s + 1];
		GCtrlPt **new_P = new GCtrlPt *[m + 1];
		for (int i = 0; i < m + 1; ++i)
			new_P[i] = new GCtrlPt [new_n + 1];

		// 새로운 낫 벡터를 구하고,
		int kidx;
		double *knot = ::get_knot_merged_distinct(V, q + n + 1, V, q + n + 1, &kidx);
		for (int i = 0; i < kidx + 1; ++i)
			for (int j = 1; j < new_q + 1; ++j)
				new_V[i * new_q + j] = knot[i];
		new_V[0] = knot[0];
		new_V[new_s] = knot[kidx];

		// 새로운 제어점을 계산한다.
		for (int i = 0; i < snum; ++i)
		{
			for (int j = 0; j < m + 1; ++j)
			{
				new_P[j][i * new_q] = P[j][i * q];
				new_P[j][(i + 1) * new_q] = P[j][(i + 1) * q];
			}

			for (int j = 1; j < q + 1; ++j)
			{
				double alpha = (double)j / (double)new_q;
				for (int k = 0; k < m + 1; ++k)
					new_P[k][i * new_q + j] = alpha * P[k][i * q + j - 1] + (1.0 - alpha) * P[k][i * q + j];
			}
		}

		// 이전 배열을 제거하고,
		delete [] V;
		for (int i = 0; i < m + 1; ++i)
			delete [] P[i];
		delete [] P;
		delete [] knot;

		// 새로운 제어점과 낫 벡터를 설정한다.
		this->q = new_q;
		this->n = new_n;
		this->V = new double [q + n + 2];
		this->P = new GCtrlPt *[m + 1];
		for (int i = 0; i < m + 1; ++i)
			P[i] = new GCtrlPt [n + 1];

		for (int i = 0; i < new_s + 1; ++i)
			V[i] = new_V[i];

		for (int i = 0; i < m + 1; ++i)
		{
			for (int j = 0; j < n + 1; ++j)
			{
				P[i][j] = new_P[i][j];
				P[i][j].pMesh = this;
			}
		}

		// 동적 할당된 임시 제어점과 낫 벡터를 메모리에서 해제한다.
		delete [] new_V;
		for (int i = 0; i < m; ++i)
			delete [] new_P[i];
		delete [] new_P;

		// B-spline 곡선의 형태로 복원한다.
		CnvrtBspForm(false, true);
	}
}

/*!
*	\brief 곡면의 piecewise Bezier 형태로 변형한다.
*
*	\param dir_u U-방향 실행 여부
*	\param dir_v V-방향 실행 여부
*/
void GNurbsSrf::CnvrtBzrForm(bool dir_u, bool dir_v)
{
	if (dir_u)
	{
		// 곡면을 U-방향 낫 벡터를 clamped 형태로 만들고,
		KnotClamped(true, false);

		// U[p + 1] ~ U[m] 까지의 낫 값을 모으고,
		std::vector<double> tmp;
		for (int i = p + 1; i < m + 1; ++i)
			tmp.push_back(U[i]);

		// 중복을 제거하여,
		sort(tmp.begin(), tmp.end());
		tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());

		// 각각의 낫을 (차수 - 중복수) 만큼 추가한다.
		for (int i = 0; i < (int)tmp.size(); ++i)
		{
			int mult = ::get_knot_mult(p, m, U, tmp[i]);
			int r = p - mult;
			KnotInsert(0, tmp[i], r);
		}
	}

	if (dir_v)
	{
		// 곡면을 V-방향 낫 벡터를 clamped 형태로 만들고,
		KnotClamped(false, true);

		// V[q + 1] ~ V[n] 까지의 낫 값을 모으고,
		std::vector<double> tmp;
		for (int i = q + 1; i < n + 1; ++i)
			tmp.push_back(V[i]);

		// 중복을 제거하여,
		sort(tmp.begin(), tmp.end());
		tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());

		// 각각의 낫을 (차수 - 중복수) 만큼 추가한다.
		for (int i = 0; i < (int)tmp.size(); ++i)
		{
			int mult = ::get_knot_mult(q, n, V, tmp[i]);
			int r = q - mult;
			KnotInsert(1, tmp[i], r);
		}
	}
}

/*!
*	\brief 곡면의 B-spline 형태로 변형한다.
*
*	\param dir_u U-방향 실행 여부
*	\param dir_v V-방향 실행 여부
*/
void GNurbsSrf::CnvrtBspForm(bool dir_u, bool dir_v)
{
	if (dir_u)
	{
		// U-방향 낫 벡터를 clamped 형태로 만들고,
		KnotClamped(true, false);

		int kidx;
		int r = p + m + 1;
		double *knot = get_knot_merged_distinct(U, r, U, r, &kidx);

		int *mult = new int [kidx - 1];
		for (int i = 0; i < kidx - 1; ++i)
			mult[i] = ::get_knot_mult(p, m, U, knot[i + 1]);

		for (int i = 1; i < kidx; ++i)
			KnotRemove(0, knot[i], mult[i - 1]);

		delete [] knot;
		delete [] mult;
	}

	if (dir_v)
	{
		// V-방향 낫 벡터를 clamped 형태로 만들고,
		KnotClamped(false, true);

		int kidx;
		int s = q + n + 1;
		double *knot = get_knot_merged_distinct(V, s, V, s, &kidx);

		int *mult = new int [kidx - 1];
		for (int i = 0; i < kidx - 1; ++i)
			mult[i] = ::get_knot_mult(q, n, V, knot[i + 1]);

		for (int i = 1; i < kidx; ++i)
			KnotRemove(1, knot[i], mult[i - 1]);

		delete [] knot;
		delete [] mult;
	}
}

/*!
*	\brief 곡면의 제어점의 위치를 편집한다.
*	\warning 4차원 곡면일 경우 dp=(dx, dy, dz, dw)이고, 3차원 유리식 곡면일 경우 dp=(dx, dy, dz, 0)의 형태가 되어야 함
*
*	\param uidx 제어점의 U-방향 인덱스
*	\param vidx 제어점의 V-방향 인덱스
*	\param dp 제어점의 편집 변위
*/
void GNurbsSrf::Edit(int uidx, int vidx, GVector4 dp)
{
	if (rational)
		dp[3] = 0.0;

	P[uidx][vidx] += dp;

	if (closed_u)
	{
		if (uidx < p)
		{
			P[uidx + (m - p + 1)][vidx] += dp;
		}

		if (uidx > m - p)
		{
			P[uidx - (m - p + 1)][vidx] += dp;
		}
	}

	if (closed_v)
	{
		if (vidx < q)
		{
			P[uidx][vidx + (n - q + 1)] += dp;

		}

		if (vidx > n - q)
		{
			P[uidx][vidx - (n - q + 1)] += dp;
		}
	}
}

/*!
*	\brief 곡면위의 한 점 S(u,v)가 주어진 dp 만큼 움직이도록 곡면의 제어점들의 위치를 수정
*	\warning 4차원 곡면일 경우 dp=(dx, dy, dz, dw)이고, 3차원 유리식 곡면일 경우 dp=(dx, dy, dz, 0)의 형태가 되어야 함
*
*	\param u 곡면위의 점에 대한 U-방향 매개변수값
*	\param v 곡면위의 점에 대한 V-방향 매개변수값
*	\param dp 곡면위의 점이 움직이 변위
*/
void GNurbsSrf::Edit(double u, double v, GVector4 dp)
{
	double *basis_u, *basis_v, **basis;
	ARR_ALLOC(basis_u, double, p + 1);
	ARR_ALLOC(basis_v, double, q + 1);
	ARR_ALLOC_2D(basis, double, p + 1, q + 1);

	int idx_u = ::get_knot_span_idx(p, m, U, u);
	int idx_v = ::get_knot_span_idx(q, n, V, v);
	::get_gnurbs_basis(U, p, u, idx_u, basis_u);
	::get_gnurbs_basis(V, q, v, idx_v, basis_v);

	if (rational)
	{
		double w = 0.0;
		for (int i = 0; i < p + 1; i++)
		{
			double tmp = 0.0;
			for (int j = 0; j < q + 1; ++j)
				tmp += basis_v[j] * P[idx_u - p + i][idx_v - q + j][3];	// 분모구하기
			w += basis_u[i] * tmp;
		}

		for (int i = 0; i < p + 1; ++i)
			for (int j = 0; j < q + 1; ++j)
				basis[i][j] = P[idx_u - p + i][idx_v - q + j][3] * basis_u[i] * basis_v[j] / w; // Rational 기저함수
	}
	else
	{
		for (int i = 0; i < p + 1; ++i)
			for (int j = 0; j < q + 1; ++j)
				basis[i][j] = basis_u[i] * basis_v[j];
	}

	double alpha = 0.0;
	for (int i = 0; i < p + 1; ++i)
		for (int j = 0; j < q + 1; ++j)
			alpha += SQR(basis[i][j]);

	for (int i = 0; i < p + 1; ++i)
		for (int j = 0; j < q + 1; ++j)
			basis[i][j] /= alpha;

	for (int i = 0; i < p + 1; ++i)
	{
		for (int j = 0; j < q + 1; ++j)
		{
			P[idx_u - p + i][idx_v - q + j] += dp * basis[i][j];
			if (closed_u)
			{
				if (idx_u - p + i < p)
					P[idx_u - p + i + (m - p + 1)][idx_v - q + j] += dp * basis[i][j];

				if (idx_u - p + i > m - p)
					P[idx_u - p + i - (m - p + 1)][idx_v - q + j] += dp * basis[i][j];
			}
			if (closed_v)
			{
				if (idx_v - q + j < q)
					P[idx_u - p + i][idx_v - q + j + (n - q + 1)] += dp * basis[i][j];

				if (idx_v - q + j > n - q)
					P[idx_u - p + i][idx_v - q + j - (n - q + 1)] += dp * basis[i][j];
			}
		}
	}

	ARR_FREE(basis_u);
	ARR_FREE(basis_v);
	ARR_FREE_2D(basis, p + 1);
}

/*!
*	\brief 곡면위의 한 점 S(u,v)가 주어진 dp 만큼 움직이도록 곡면의 제어점들의 위치를 수정
*	\warning 4차원 곡면일 경우 dp=(dx, dy, dz, dw)이고, 3차원 유리식 곡면일 경우 dp=(dx, dy, dz, 0)의 형태가 되어야 함
*
*	\param u 곡면위의 점에 대한 U-방향 매개변수값
*	\param v 곡면위의 점에 대한 V-방향 매개변수값
*	\param dp 곡면위의 점이 움직이 변위
*	\param support_u U방향 편집 영역의 범위
*	\param support_v V방향 편집 영역의 범위
*/
void GNurbsSrf::Edit(double u, double v, GVector4 dp, int support_u, int support_v)
{
	if (closed_u)	// U-방향 닫힌 곡선의 경우,
	{
		// U-방향 낫 벡터 구하기
		double *delta_u;
		ARR_ALLOC(delta_u, double, m - p + 1);

		for (int i = 0; i < m - p + 1; ++i)
			delta_u[i] = U[i + 1] - U[i];

		double *knot_u_all;
		ARR_ALLOC(knot_u_all, double, 2 * (p + support_u + 1));

		int idx_u = ::get_knot_span_idx(p, m, U, u);
		int a = idx_u % (m - p + 1);
		int b = idx_u % (m - p + 1);

		knot_u_all[p + support_u] = U[idx_u];
		knot_u_all[p + support_u + 1] = U[idx_u + 1];
		for (int i = 1; i < p + support_u + 1; ++i)
		{
			a--;
			if (a < 0)
				a = a + (m - p + 1);
			b++;
			if (b > m - p)
				b = b - (m - p + 1);

			knot_u_all[p + support_u - i] = knot_u_all[p + support_u - i + 1] - delta_u[a];
			knot_u_all[p + support_u + 1 + i] = knot_u_all[p + support_u + i] + delta_u[b];
		}

		double *knot_u;
		ARR_ALLOC(knot_u, double, 2 * (p + 1));
		ARR_COPY(knot_u, knot_u_all, p + 1);
		ARR_COPY((&knot_u[p + 1]), (&knot_u_all[p + 2 * support_u + 1]), p + 1);

		// V-방향 낫 벡터 구하기
		int idx_v = ::get_knot_span_idx(q, n, V, v);
		int min_idx_v = ((idx_v - support_v - q) < 0) ? 0 : idx_v - support_v - q;
		int max_idx_v = ((idx_v + support_v + q + 1) > q + n + 1) ? q + n + 1 : idx_v + support_v + q + 1;

		double *knot_v;
		ARR_ALLOC(knot_v, double, 2 * (q + 1));
		ARR_COPY(knot_v, (&V[min_idx_v]), q + 1);
		ARR_COPY((&knot_v[q + 1]), (&V[max_idx_v - q]), q + 1);

		// 변위 곡면 생성
		GNurbsSrf *pSrf = ::get_gnurbs_srf_degen(p, p, knot_u, q, q, knot_v, GVector4(0.0, 0.0, 0.0, 0.0), false);
		pSrf->Edit(u, v, dp);

		for (int i = 0; i < 2 * support_u; ++i)
			pSrf->KnotInsert(0, knot_u_all[p + 1 + i], 1);

		for (int i = min_idx_v + q + 1; i < max_idx_v - q; ++i)
			pSrf->KnotInsert(1, V[i], 1);

		int min_idx_u = idx_u - support_u - p;
		if (min_idx_u < 0)
			min_idx_u = min_idx_u + (m - p + 1);

		for (int i = 0; i < pSrf->m + 1; ++i)
		{
			for (int j = 0; j < pSrf->n + 1; ++j)
			{
				int k = (min_idx_u + i) % (m - p + 1); // 우측 구간 (P[m-p+1][*], P[m-p+2][*], ... P[m][*])
				P[k][min_idx_v + j] += pSrf->P[i][j];

				if (k < p)		// 좌측 구간 (P[0][*] P[1][*], ..., P[p-1][*])
					P[k + (m - p + 1)][min_idx_v + j] += pSrf->P[i][j];
			}
		}

		ARR_FREE(delta_u);
		ARR_FREE(knot_u_all);
		ARR_FREE(knot_u);
		ARR_FREE(knot_v);
		delete pSrf;		
	}
	else if (closed_v)	// 닫힌 곡선의 경우,
	{
		// U-방향 낫 벡터 구하기
		int idx_u = ::get_knot_span_idx(p, m, U, u);
		int min_idx_u = ((idx_u - support_u - p) < 0) ? 0 : idx_u - support_u - p;
		int max_idx_u = ((idx_u + support_u + p + 1) > p + m + 1) ? p + m + 1 : idx_u + support_u + p + 1;

		double *knot_u;
		ARR_ALLOC(knot_u, double, 2 * (p + 1));
		ARR_COPY(knot_u, (&U[min_idx_u]), p + 1);
		ARR_COPY((&knot_u[p + 1]), (&U[max_idx_u - p]), p + 1);

		// V-방향 인덱스 구하기
		double *delta_v;
		ARR_ALLOC(delta_v, double, n - q + 1);

		for (int i = 0; i < n - q + 1; ++i)
			delta_v[i] = V[i + 1] - V[i];

		double *knot_v_all;
		ARR_ALLOC(knot_v_all, double, 2 * (q + support_v + 1));

		int idx_v = ::get_knot_span_idx(q, n, V, v);
		int a = idx_v % (n - q + 1);
		int b = idx_v % (n - q + 1);

		knot_v_all[q + support_v] = V[idx_v];
		knot_v_all[q + support_v + 1] = V[idx_v + 1];
		for (int i = 1; i < q + support_v + 1; ++i)
		{
			a--;
			if (a < 0)
				a = a + (n - q + 1);
			b++;
			if (b > n - q)
				b = b - (n - q + 1);

			knot_v_all[q + support_v - i] = knot_v_all[q + support_v - i + 1] - delta_v[a];
			knot_v_all[q + support_v + 1 + i] = knot_v_all[q + support_v + i] + delta_v[b];
		}

		double *knot_v;
		ARR_ALLOC(knot_v, double, 2 * (q + 1));
		ARR_COPY(knot_v, knot_v_all, q + 1);
		ARR_COPY((&knot_v[q + 1]), (&knot_v_all[q + 2 * support_v + 1]), q + 1);

		// 변위 곡면 생성
		GNurbsSrf *pSrf = ::get_gnurbs_srf_degen(p, p, knot_u, q, q, knot_v, GVector4(0.0, 0.0, 0.0, 0.0), false);
		pSrf->Edit(u, v, dp);

		for (int i = 0; i < 2 * support_v; ++i)
			pSrf->KnotInsert(1, knot_v_all[q + 1 + i], 1);

		for (int i = min_idx_u + p + 1; i < max_idx_u - p; ++i)
			pSrf->KnotInsert(0, U[i], 1);

		int min_idx_v = idx_v - support_v - q;
		if (min_idx_v < 0)
			min_idx_v = min_idx_v + (n - q + 1);

		for (int i = 0; i < pSrf->m + 1; ++i)
		{
			for (int j = 0; j < pSrf->n + 1; ++j)
			{
				int k = (min_idx_v + j) % (n - q + 1); // 우측 구간 (P[*][n-q+1], P[*][n-q+2], ... P[*][n])
				P[min_idx_u + i][k] += pSrf->P[i][j];

				if (k < q)		// 좌측 구간 (P[*][0], P[*][1], ..., P[*][q-1])
					P[min_idx_u + i][k + (n - q + 1)] += pSrf->P[i][j];
			}
		}

		ARR_FREE(delta_v);
		ARR_FREE(knot_v_all);
		ARR_FREE(knot_u);
		ARR_FREE(knot_v);
		delete pSrf;	
	}
	else	// 열린 곡면의 경우,
	{
		double *knot_u, *knot_v;
		ARR_ALLOC(knot_u, double, p * 2 + 2);
		ARR_ALLOC(knot_v, double, q * 2 + 2);

		int idx_u = ::get_knot_span_idx(p, m, U, u);
		int idx_v = ::get_knot_span_idx(q, n, V, v);

		int min_idx_u = ((idx_u - support_u - p) < 0) ? 0 : idx_u - support_u - p;
		int max_idx_u = ((idx_u + support_u + p + 1) > p + m + 1) ? p + m + 1 : idx_u + support_u + p + 1;

		int min_idx_v = ((idx_v - support_v - q) < 0) ? 0 : idx_v - support_v - q;
		int max_idx_v = ((idx_v + support_v + q + 1) > q + n + 1) ? q + n + 1 : idx_v + support_v + q + 1;

		ARR_COPY(knot_u, (&U[min_idx_u]), p + 1);
		ARR_COPY((&knot_u[p + 1]), (&U[max_idx_u - p]), p + 1);

		ARR_COPY(knot_v, (&V[min_idx_v]), q + 1);
		ARR_COPY((&knot_v[q + 1]), (&V[max_idx_v - q]), q + 1);

		GNurbsSrf *pSrf = ::get_gnurbs_srf_degen(p, p, knot_u, q, q, knot_v, GVector4(0.0, 0.0, 0.0, 0.0), false);
		pSrf->Edit(u, v, dp);

		for (int i = min_idx_u + p + 1; i < max_idx_u - p; ++i)
			pSrf->KnotInsert(0, U[i], 1);

		for (int i = min_idx_v + q + 1; i < max_idx_v - q; ++i)
			pSrf->KnotInsert(1, V[i], 1);

		for (int i = 0; i < pSrf->m + 1; ++i)
			for (int j = 0; j < pSrf->n + 1; ++j)
				P[min_idx_u + i][min_idx_v + j] += pSrf->P[i][j];			

		ARR_FREE(knot_u);
		ARR_FREE(knot_v);
		delete pSrf;
	}
}

/*!
*	\brief	곡면의 U 방향으로 정의된 도메인을 반환한다.
*
*	\param min U 방향 도메인의 시작 값이 저장된다.
*/
void GNurbsSrf::GetDomain(double *umin, ...)
{
	double *umax, *vmin, *vmax;
	va_list ap;
	va_start(ap, umin);
	umax = va_arg(ap, double *);
	vmin = va_arg(ap, double *);
	vmax = va_arg(ap, double *);
	va_end(ap);

	*umin = U[p];
	*umax = U[m + 1];
	*vmin = V[q];
	*vmax = V[n + 1];
}

/*!
*	\brief	곡면의 제어점 리스트를 반환한다.
*
*	\return 곡면의 제어점 리스트를 반환한다.
*/
void GNurbsSrf::GetCtrlPtList(std::vector<GCtrlPt *> &CtrlPtList)
{
	for (int i = 0; i < m + 1; ++i)
		for (int j = 0; j < n + 1; ++j)
			CtrlPtList.push_back(&P[i][j]);
}

/*!
*	\brief	곡면의 모든 제어점의 값을 영벡터로 초기화 한다.
*/
void GNurbsSrf::SetZeros()
{
	for (int i = 0; i < m + 1; ++i)
		for (int j = 0; j < n + 1; ++j)
			P[i][j].Set(0.0, 0.0, 0.0, 0.0);	
}

/*!
*	\brief 곡면의 제어점의 값을 반환한다.
*
*	\param idx 제어점의 인덱스
*
*	\return 1차원 배열로 저장된 곡면의 \a idx-번째 제어점을 반환한다.
*/
GVector4 GNurbsSrf::GetCtrlPt(int idx)
{
	int uIdx = idx / (n + 1);
	int vIdx = idx % (n + 1);
	return P[uIdx][vIdx];
}

/*************************************/
/* Implementation of GSweepSrf Class */
/*************************************/
IMPLEMENT_GMESH_OBJECT(GSweepSrf)

/*!
*	\brief 객체가 포함된 메쉬의 포인터를 반환한다.
*
*	\return 객체가 포함된 메쉬의 포인터를 반환한다.
*/
GMesh *GSweepSrf::GetRefMesh()
{
	return this;
}

/*!
*	\brief 객체의 모델링 좌표계를 반환한다.
*
*	\return 객체의 모델링 좌표계를 반환한다.
*/
GTransf GSweepSrf::GetTransf()
{
	return MC;
}

/*!
*	\brief 선택된 객체를 편집한다.
*
*	\param EC 편집 좌표계
*	\param t 편집될 객체의 이동 변위
*	\param q 편집될 객체의 회전 변위
*	\param s 편집될 객체의 스케일 변위
*	\param pParentMesh 편집 객체의 부모 메쉬
*/
void GSweepSrf::Edit(GTransf EC, GVector3 t, GQuater q, GVector3 s, GMesh *pParentMesh)
{
	GMesh::Edit(EC, t, q, s, pParentMesh);
}

/*!
*	\brief	메쉬의 모델링 좌표계를 월드 좌표계로 갱신한다.
*
*	\param RefType 모델링 좌표계의 갱신을 위한 참조 형태(0: 월드 좌표계, 1: 경계상자 좌표계)
*/
void GSweepSrf::UpdateMC(int RefType)
{
}

/*!
*	\brief	스윕 곡면의 정점 리스트를 다시 생성한다.
*/
void GSweepSrf::UpdateMesh() 
{
	// 갱신 정보에 따라서,
	switch (ModifiedFlag)
	{
		// 재질이 변경되었다면,
	case MODIFIED_MTL:
		UpdateBufFace();
		break;

	case MODIFIED_INTPT_POS:
		CreateMeshVert();
		UpdateBndBox(false);
		UpdateBufVertex();
		break;

	case MODIFIED_CTLPT_POS:
		CreateMeshVert();
		UpdateBndBox(false);
		UpdateBufVertex();
		break;

	case MODIFIED_NORMAL:
		UpdateNormal(false);
		UpdateBufNormal();
		break;

	case MODIFIED_SAMPLE_NUM:
		CreateMesh();
		break;
	}

	ModifiedFlag = MODIFIED_NONE;
}

/*!
*	\brief 선택된 객체를 렌더링 한다.
*/
void GSweepSrf::RenderForEdit(float r, float g, float b)
{
	GMesh::RenderForEdit(r, g, b);	
}

/*!
*	\brief	생성자
*
*	\param _Name 스윕곡면의 이름
*	\param _MC 곡면의 모델링 좌표계
*	\param _KeyCrvList 단면 곡선의 리스트
*	\param _DegT 스윕 곡면의 궤적 성분 곡선의 차수
*	\param _DegR 스윕 곡면의 방향 성분 곡선의 차수
*	\param _ParentName 부모 스윕곡면의 이름
*/
GSweepSrf::GSweepSrf(std::string _Name, GTransf _MC, std::vector<GNurbsCrv *> _KeyCrvList, int _DegT, int _DegR, std::string _ParentName)
: GMesh(_Name, _MC, FACE_QUAD, _ParentName)
{
	KeyCrvList = _KeyCrvList;
	DegT = _DegT;
	DegR = _DegR;
	pTraCrv = NULL;
	pRotCrv = NULL;
	pSrcSrf = NULL;

	int NumCrv = (int)KeyCrvList.size();
	for (int i = 0; i < NumCrv; ++i)
	{
		KeyCrvList[i]->SemanticType = MESH_KEY_CRV;
		KeyCrvList[i]->LinkedMeshNameList.push_back(Name);
	}
}

/*!
*	\brief	복사 생성자
*
*	\param cpy 복사될 객체
*/
GSweepSrf::GSweepSrf(const GSweepSrf &cpy)
: GMesh(cpy)
{
	KeyCrvList = cpy.KeyCrvList;
	DegT = cpy.DegT;
	DegR = cpy.DegR;
	pTraCrv = NULL;
	pRotCrv = NULL;
	pSrcSrf = NULL;
}

/*!
*	\brief	소멸자
*/
GSweepSrf::~GSweepSrf()
{
	if (pTraCrv != NULL)
		delete pTraCrv;

	if (pRotCrv != NULL)
		delete pRotCrv;

	if (pSrcSrf != NULL)
		delete pSrcSrf;
}

/*!
*	\brief	대입 연산자
*
*	\param rhs 대입될 객체
*
*	\return 대입된 자신을 반환한다.
*/
GSweepSrf &GSweepSrf::operator =(const GSweepSrf &rhs)
{
	GMesh::operator =(rhs);

	KeyCrvList = rhs.KeyCrvList;
	DegT = rhs.DegT;
	DegR = rhs.DegR;
	pTraCrv = NULL;
	pRotCrv = NULL;
	pSrcSrf = NULL;

	return *this;
}

/*!
*	\brief	스윕 곡면을 렌더링 한다.
*
*	\param bSubMesh 서브 메쉬의 렌더링 여부(선택 모드에서는 false로 설정)
*/
void GSweepSrf::Render(bool bSubMesh)
{
	GMesh::Render(bSubMesh);	
}

/*!
*	\brief 스윕핑 평면을 계산한다.
*
*	\param t 계산 파라미터
*
*	\return 계산된 평면을 반환한다.
*/
GPlane GSweepSrf::EvalPlane(double t)
{
	GPoint3 p = cast_pt3(pTraCrv->Eval(t));
	GQuater qt = cast_qt(pRotCrv->Eval(t)).Normalize();
	GVector3 n = qt * GVector3(0.0, 1.0, 0.0);
	
	return GPlane(n, p);
}

/*!
*	\brief	스윕 곡면의 렌더링 메쉬를 생성한다.
*/
void GSweepSrf::CreateMesh()
{
	// 경계 정점의 리스트를 초기화 하고,
	InitBndryEdgeList();

	// 키곡선들로 부터 스윕곡면의 성분을 생성하고,
	CreateComponent();

	// 정점의 좌표를 생성하고,
	CreateMeshVert();

	// 텍스처 좌표를 생성하고,
	CreateMeshTex();

	// 삼각형 정보를 생성하고, 
	CreateMeshFace();

	// 정점의 법선을 계산하고,
	UpdateNormal(false);

	// 곡면의 바운딩 박스를 계산한다.
	UpdateBndBox(false);

	// 정점 버퍼와 인덱스 버퍼를 갱신한다.
	UpdateBufVertex();
	UpdateBufNormal();
	UpdateBufFace();
}

/*!
*	\brief	스윕 곡면의 성분 곡선 및 곡면을 생성한다.
*/
void GSweepSrf::CreateComponent()
{
	// 키 단면의 중심 좌표를 보간점으로 저장하고,
	int NumKey = (int)KeyCrvList.size();
	GVector4 *TQ = new GVector4 [NumKey];
	for (int i = 0; i < NumKey; ++i)
		TQ[i] = cast_vec4(part_trans(KeyCrvList[i]->MC));

	//  키단면의 회전 좌표를 보간점으로 저장하고,
	GVector4 *RQ = new GVector4 [NumKey];
	RQ[0] = cast_vec4(part_rot(KeyCrvList[0]->MC));

	for (int i = 1; i < NumKey; ++i)
	{
		GQuater prev_q = cast_qt(RQ[i - 1]);
		GQuater curr_q = part_rot(KeyCrvList[i]->MC);
		if (quat_dot(prev_q, curr_q) < 0.0)
			curr_q.SetNegate();
		
		RQ[i] = cast_vec4(curr_q);
	}

	// 궤적 곡선과 방향 곡선의 파라미터와 낫 벡터를 구하여, 
	double *Params = get_param_chord_len(NumKey - 1, TQ, 0.0, 1.0);
	double *KnotT = get_knot_averaging_clamped(DegT, NumKey - 1, Params);
	double *KnotR = get_knot_averaging_clamped(DegR, NumKey - 1, Params);

	// 궤적 곡선을 생성하고,
	if (pTraCrv != NULL)
		delete pTraCrv;
	pTraCrv = get_gnurbs_crv_inter(DegT, NumKey - 1, TQ, 0.0, 1.0, PARAM_USER, KNOT_USER, Params, KnotT);

	// 회전 곡선을 생성하고,
	if (pRotCrv != NULL)
		delete pRotCrv;
	pRotCrv = get_gnurbs_crv_inter(DegR, NumKey - 1, RQ, 0.0, 1.0, PARAM_USER, KNOT_USER, Params, KnotR);

	// 형상 곡면을 생성한다.
	if (pSrcSrf != NULL)
		delete pSrcSrf;
	pSrcSrf = get_gnurbs_srf_inter(DegT, KeyCrvList, Params, KnotT);

	// 할당된 메모리를 해제한다.
	delete [] TQ;
	delete [] RQ;
	delete [] Params;
	delete [] KnotT;
	delete [] KnotR;
}

/*!
*	\brief	스윕 곡면의 렌더링 메쉬의 정점을 생성한다.
*/
void GSweepSrf::CreateMeshVert()
{
	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
	int NumSampV = Renderer.NumSampV;
	double umin, umax, vmin, vmax;

	// 기존의 정점을 지우고, 
	Verts.clear();

	// 정의역을 계산하고,
	GetDomain(&umin, &umax, &vmin, &vmax);
	
	// 렌더링 타입이 스윕 평면이라면,
	if (Renderer.RenderType & RENDER_SWEEP_PLANE)
	{
		double w = Renderer.SwpPlnWidth;
		double h = Renderer.SwpPlnHeight;
		for (int j = 0; j < NumSampV; ++j)
		{
			double v = vmin + (vmax - vmin) * (double)j / (double)(NumSampV - 1);

			GVector3 t = cast_vec3(pTraCrv->Eval(v));
			GQuater q = cast_qt(pRotCrv->Eval(v)).Normalize();	

			GPoint3 p0(-h / 2, 0.0, -w / 2);
			GPoint3 p1(-h / 2, 0.0, w / 2);
			GPoint3 p2(h / 2, 0.0, w / 2);
			GPoint3 p3(h / 2, 0.0, -w / 2);

			GTransf X(t, q);
			p0 = X * p0;
			p1 = X * p1;
			p2 = X * p2;
			p3 = X * p3;

			GVertex vtx0(p0, GVector3(0.0, 0.0, 0.0));
			GVertex vtx1(p1, GVector3(0.0, 0.0, 0.0));
			GVertex vtx2(p2, GVector3(0.0, 0.0, 0.0));
			GVertex vtx3(p3, GVector3(0.0, 0.0, 0.0));

			AddVertex(vtx0);
			AddVertex(vtx1);
			AddVertex(vtx2);
			AddVertex(vtx3);
		}
	}
	// 렌더링 타입이 스윕 평면이 아니라면,
	else
	{
		// 곡면위의 정점을 계산한다.
		GVector4 pt;
		for (int i = 0; i < NumSampU; ++i)
		{
			double u = umin + (umax - umin) * (double)i / (double)(NumSampU - 1);
			for (int j = 0; j < NumSampV; ++j)
			{
				double v = vmin + (vmax - vmin) * (double)j / (double)(NumSampV - 1);
				pt = Eval(u, v);
				GVertex vtx(GPoint3(pt[0], pt[1], pt[2]), GVector3(0.0, 0.0, 0.0));
				AddVertex(vtx);
			}
		}
	}	
}

/*!
*	\brief	스윕 곡면의 렌더링 메쉬의 텍스처 좌표를 생성한다.
*/
void GSweepSrf::CreateMeshTex()
{
	// 기존의 텍셀 정보를 지우고,
	Texs.clear();

	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
	int NumSampV = Renderer.NumSampV;

	// 텍스처 좌표를 생성하고 저장함
	for (int i = 0; i < NumSampU; ++i)
	{
		double s = (double)i / (double)(NumSampU - 1);
		for (int j = 0; j < NumSampV; ++j)
		{
			double t = (double)j / (double)(NumSampV - 1);
			AddTexel(GVector2(s, t));
		}
	}
}

/*!
*	\brief	스윕 곡면의 렌더링 메쉬의 삼각형을 생성한다.
*/
void GSweepSrf::CreateMeshFace()
{
	// 삼각형 정보를 지우고,
	Faces.clear();

	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
	int NumSampV = Renderer.NumSampV;

	// 렌더링 타입이 스윕 평면이라면,
	if (Renderer.RenderType & RENDER_SWEEP_PLANE)
	{
		for(int j = 0; j < NumSampV; ++j)
		{
			int vidx0 = 4 * j;
			int vidx1 = vidx0 + 1;
			int vidx2 = vidx1 + 1;
			int vidx3 = vidx2 + 1;

			GFace f0(vidx0, vidx1, vidx2, vidx0, vidx1, vidx2, -1);
			GFace f1(vidx0, vidx2, vidx3, vidx0, vidx2, vidx3, -1);

			AddFace(f0);
			AddFace(f1);
		}
	}
	// 렌더링 타입이 스윕 평면이 아니라면,
	else
	{
		// 삼각형을 생성하고 추가한다.
		for (int i = 0; i < NumSampU - 1; ++i)
		{
			for(int j = 0; j < NumSampV - 1; ++j)
			{
				int vidx0 = i * NumSampV + j;
				int vidx1 = vidx0 + NumSampV;
				int vidx2 = vidx1 + 1;
				int vidx3 = vidx0 + 1;

				GFace f0(vidx0, vidx1, vidx2, vidx0, vidx1, vidx2, -1);
				GFace f1(vidx0, vidx2, vidx3, vidx0, vidx2, vidx3, -1);

				AddFace(f0);
				AddFace(f1);
			}
		}
	}	
}

/*!
*	\brief	스윕 곡면위의 점 S(u, v)를 계산
*
*	\param u U-방향 매개변수의 값
*
*	\return 스윕 곡면위의 점 S(u, v)의 위치를 반환한다.
*/
GVector4 GSweepSrf::Eval(double u, ...)
{
	double v;
	va_list ap;
	va_start(ap, u);
	v = va_arg(ap, double);
	va_end(ap);

 	GVector3 t = cast_vec3(pTraCrv->Eval(v));
 	GQuater qt = cast_qt(pRotCrv->Eval(v)).Normalize();	
 	GPoint3 pt = cast_pt3(pSrcSrf->Eval(u, v));
 
 	pt = t + qt * pt;
	return GVector4(pt[0], pt[1], pt[2], 0.0);
}

/*!
*	\brief	곡면이 정의된 파라미터 공간을 반환한다.
*
*	\param min U 방향 도메인의 시작 값이 저장된다.
*/
void GSweepSrf::GetDomain(double *umin, ...)
{
	double *umax, *vmin, *vmax;
	va_list ap;
	va_start(ap, umin);
	umax = va_arg(ap, double *);
	vmin = va_arg(ap, double *);
	vmax = va_arg(ap, double *);
	va_end(ap);

	*vmin = 0.0;
	*vmax = 1.0;

	double tmp1, tmp2;
	KeyCrvList[0]->GetDomain(&tmp1, &tmp2);
	*umin = tmp1;
	*umax = tmp2;
}

/*!
*	\brief	곡면의 제어점 리스트를 반환한다.
*
*	\return 곡면의 제어점 리스트를 반환한다.
*/
void GSweepSrf::GetCtrlPtList(std::vector<GCtrlPt *> &CtrlPtList)
{
}

/*************************************/
/* Implementation of GNurbsMot Class */
/*************************************/
IMPLEMENT_GMESH_OBJECT(GNurbsMot)

/*!
*	\brief 객체가 포함된 메쉬의 포인터를 반환한다.
*
*	\return 객체가 포함된 메쉬의 포인터를 반환한다.
*/
GMesh *GNurbsMot::GetRefMesh()
{
	return this;
}

/*!
*	\brief 객체의 모델링 좌표계를 반환한다.
*
*	\return 객체의 모델링 좌표계를 반환한다.
*/
GTransf GNurbsMot::GetTransf()
{
	return MC;
}

/*!
*	\brief 선택된 객체를 편집한다.
*
*	\param EC 편집 좌표계
*	\param t 편집될 객체의 이동 변위
*	\param q 편집될 객체의 회전 변위
*	\param s 편집될 객체의 스케일 변위
*	\param pParentMesh 편집 객체의 부모 메쉬
*/
void GNurbsMot::Edit(GTransf EC, GVector3 t, GQuater q, GVector3 s, GMesh *pParentMesh)
{
	GMesh::Edit(EC, t, q, s, pParentMesh);
}

/*!
*	\brief	메쉬의 모델링 좌표계를 월드 좌표계로 갱신한다.
*
*	\param RefType 모델링 좌표계의 갱신을 위한 참조 형태(0: 월드 좌표계, 1: 경계상자 좌표계)
*/
void GNurbsMot::UpdateMC(int RefType)
{
	GMesh::UpdateMC(RefType);
}

/*!
*	\brief	넙스 모션의 정점 리스트를 다시 생성한다.
*/
void GNurbsMot::UpdateMesh() 
{
	// 갱신 정보에 따라서,
	switch (ModifiedFlag)
	{
		// 재질이 변경되었다면,
	case MODIFIED_MTL:
		UpdateBufFace();
		break;

	case MODIFIED_INTPT_POS:
		CreateMeshVert();
		UpdateBndBox(false);
		UpdateBufVertex();
		break;

	case MODIFIED_CTLPT_POS:
		CreateMeshVert();
		UpdateBndBox(false);
		UpdateBufVertex();
		break;

	case MODIFIED_NORMAL:
		UpdateNormal(false);
		UpdateBufNormal();
		break;

	case MODIFIED_SAMPLE_NUM:
		CreateMesh();
		break;
	}

	ModifiedFlag = MODIFIED_NONE;
}

/*!
*	\brief 선택된 객체를 렌더링 한다.
*/
void GNurbsMot::RenderForEdit(float r, float g, float b)
{
	GMesh::RenderForEdit(r, g, b);	
}

/*!
*	\brief	생성자
*
*	\param _Name 모션의 이름
*	\param _MC 모션의 모델링 좌표계
*	\param _KeyMeshList 키 좌표계의 리스트
*	\param _DegT 스윕 곡면의 궤적 성분 곡선의 차수
*	\param _DegR 스윕 곡면의 방향 성분 곡선의 차수
*	\param _ParentName 부모 스윕곡면의 이름
*/
GNurbsMot::GNurbsMot(std::string _Name, GTransf _MC, std::vector<GMesh *> _KeyMeshList, int _DegT, int _DegR, std::string _ParentName)
: GMesh(_Name, _MC, FACE_QUAD, _ParentName)
{
	KeyMeshList = _KeyMeshList;
	DegT = _DegT;
	DegR = _DegR;
	pTraCrv = NULL;
	pRotCrv = NULL;
	pSclCrv = NULL;

	int NumMesh = (int)KeyMeshList.size();
	for (int i = 0; i < NumMesh; ++i)
	{
		KeyMeshList[i]->SemanticType = MESH_KEY_FRAME;
		KeyMeshList[i]->LinkedMeshNameList.push_back(Name);
	}
}

/*!
*	\brief	복사 생성자
*
*	\param cpy 복사될 객체
*/
GNurbsMot::GNurbsMot(const GNurbsMot &cpy)
: GMesh(cpy)
{
	KeyMeshList = cpy.KeyMeshList;
	DegT = cpy.DegT;
	DegR = cpy.DegR;
	pTraCrv = NULL;
	pRotCrv = NULL;
	pSclCrv = NULL;
}

/*!
*	\brief	소멸자
*/
GNurbsMot::~GNurbsMot()
{
	if (pTraCrv != NULL)
		delete pTraCrv;

	if (pRotCrv != NULL)
		delete pRotCrv;

	if (pSclCrv != NULL)
		delete pSclCrv;
}

/*!
*	\brief	대입 연산자
*
*	\param rhs 대입될 객체
*
*	\return 대입된 자신을 반환한다.
*/
GNurbsMot &GNurbsMot::operator =(const GNurbsMot &rhs)
{
	GMesh::operator =(rhs);

	KeyMeshList = rhs.KeyMeshList;
	DegT = rhs.DegT;
	DegR = rhs.DegR;
	pTraCrv = NULL;
	pRotCrv = NULL;
	pSclCrv = NULL;

	return *this;
}

/*!
*	\brief	스윕 곡면을 렌더링 한다.
*
*	\param bSubMesh 서브 메쉬의 렌더링 여부(선택 모드에서는 false로 설정)
*/
void GNurbsMot::Render(bool bSubMesh)
{
	GMesh::Render(bSubMesh);	
}

/*!
*	\brief y축을 법선으로 갖는 평면을 계산한다.
*
*	\param u 계산 파라미터
*
*	\return 계산된 평면을 반환한다.
*/
GPlane GNurbsMot::EvalPlane(double u)
{
	GPoint3 p = cast_pt3(pTraCrv->Eval(u));
	GQuater qt = cast_qt(pRotCrv->Eval(u)).Normalize();
	GVector3 n = qt * GVector3(0.0, 1.0, 0.0);

	return GPlane(n, p);
}

/*!
*	\brief 넙스 모션의 좌표계를 계산한다.
*
*	\param u 파라미터
*
*	\return 계산된 좌표계를 반환한다.
*/
GTransf GNurbsMot::EvalFrame(double u)
{
	GVector3 t = cast_vec3(pTraCrv->Eval(u));
	GQuater q = cast_qt(pRotCrv->Eval(u)).Normalize();
	
	return GTransf(t, q);
}

/*!
*	\brief 키 메쉬의 개수를 반환한다.
*
*	\return 키 메쉬의 개수를 반환한다.
*/
int GNurbsMot::GetNumKeyMesh()
{
	return (int)KeyMeshList.size();
}

/*!
*	\brief	스윕 곡면의 렌더링 메쉬를 생성한다.
*/
void GNurbsMot::CreateMesh()
{
	// 경계 정점의 리스트를 초기화 하고,
	InitBndryEdgeList();

	// 키곡선들로 부터 스윕곡면의 성분을 생성하고,
	CreateComponent();

	// 정점의 좌표를 생성하고,
	CreateMeshVert();

	// 텍스처 좌표를 생성하고,
	CreateMeshTex();

	// 삼각형 정보를 생성하고, 
	CreateMeshFace();

	// 정점의 법선을 계산하고,
	UpdateNormal(false);

	// 곡면의 바운딩 박스를 계산한다.
	UpdateBndBox(false);

	// 정점 버퍼와 인덱스 버퍼를 갱신한다.
	UpdateBufVertex();
	UpdateBufNormal();
	UpdateBufFace();
}

/*!
*	\brief	넙스 모션의 성분 곡선을 생성한다.
*/
void GNurbsMot::CreateComponent()
{
	// 키 메쉬의 중심 좌표를 보간점으로 저장하고,
	int NumKey = (int)KeyMeshList.size();
	GVector4 *TQ = new GVector4 [NumKey];
	for (int i = 0; i < NumKey; ++i)
		TQ[i] = cast_vec4(part_trans(KeyMeshList[i]->MC));

	// 키 메쉬의 방향(자세)를 보간점으로 저장하고,
	GVector4 *RQ = new GVector4 [NumKey];
	RQ[0] = cast_vec4(part_rot(KeyMeshList[0]->MC));
	for (int i = 1; i < NumKey; ++i)
	{
		GQuater prev_q = cast_qt(RQ[i - 1]);
		GQuater curr_q = part_rot(KeyMeshList[i]->MC);
		if (quat_dot(prev_q, curr_q) < 0.0)
			curr_q.SetNegate();

		RQ[i] = cast_vec4(curr_q);
	}

	// 궤적 곡선과 방향 곡선의 파라미터와 낫 벡터를 구하여, 
	double *Params = get_param_chord_len(NumKey - 1, TQ, 0.0, 1.0);
	double *KnotT = get_knot_averaging_clamped(DegT, NumKey - 1, Params);
	double *KnotR = get_knot_averaging_clamped(DegR, NumKey - 1, Params);

	// 궤적 곡선을 생성하고,
	if (pTraCrv != NULL)
		delete pTraCrv;
	pTraCrv = get_gnurbs_crv_inter(DegT, NumKey - 1, TQ, 0.0, 1.0, PARAM_USER, KNOT_USER, Params, KnotT);

	// 회전 곡선을 생성하고,
	if (pRotCrv != NULL)
		delete pRotCrv;
	pRotCrv = get_gnurbs_crv_inter(DegR, NumKey - 1, RQ, 0.0, 1.0, PARAM_USER, KNOT_USER, Params, KnotR);

	// 스케일 곡선을 생성한다.
// 	if (pSclCrv != NULL)
// 		delete pSclCrv;
// 	pSclCrv = get_gnurbs_crv_inter(DegT, KeyMeshList, Params, KnotT);

	// 할당된 메모리를 해제한다.
	delete [] TQ;
	delete [] RQ;
	delete [] Params;
	delete [] KnotT;
	delete [] KnotR;
}

/*!
*	\brief 넙스 모션의 렌더링 메쉬의 정점을 생성한다.
*/
void GNurbsMot::CreateMeshVert()
{
	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
		
	// 기존의 정점을 지우고, 
	Verts.clear();

	// 정의역을 계산하고,
	double umin, umax;
	GetDomain(&umin, &umax);

	// 평면의 4정점을 구하여 추가한다.
	double w = Renderer.SwpPlnWidth;
	double h = Renderer.SwpPlnHeight;
	for (int i = 0; i < NumSampU; ++i)
	{
		// 파라미터 0.0 <= t <= 1.0 에 대하여 
		double u = umin + (umax - umin) * (double)i / (double)(NumSampU - 1);

		// 위치와 방향을 계산하고,
		GVector3 t = cast_vec3(pTraCrv->Eval(u));
		GQuater q = cast_qt(pRotCrv->Eval(u)).Normalize();	

		// 평면의 4정점을 계산하여,	
		GPoint3 p0(-h / 2, 0.0, -w / 2);
		GPoint3 p1(-h / 2, 0.0, w / 2);
		GPoint3 p2(h / 2, 0.0, w / 2);
		GPoint3 p3(h / 2, 0.0, -w / 2);

		// 변환된 정점을 계산한 후,
		GTransf X(t, q);
		p0 = X * p0;
		p1 = X * p1;
		p2 = X * p2;
		p3 = X * p3;

		// 모션의 렌더링 메쉬에 추가한다.
		GVertex vtx0(p0, GVector3(0.0, 0.0, 0.0));
		GVertex vtx1(p1, GVector3(0.0, 0.0, 0.0));
		GVertex vtx2(p2, GVector3(0.0, 0.0, 0.0));
		GVertex vtx3(p3, GVector3(0.0, 0.0, 0.0));
		AddVertex(vtx0);
		AddVertex(vtx1);
		AddVertex(vtx2);
		AddVertex(vtx3);
	}
}

/*!
*	\brief	넙스 모션의 렌더링 메쉬의 텍스처 좌표를 생성한다.
*/
void GNurbsMot::CreateMeshTex()
{
	// 기존의 텍셀 정보를 지우고,
	Texs.clear();
}

/*!
*	\brief	넙스 모션의 렌더링 메쉬의 삼각형을 생성한다.
*/
void GNurbsMot::CreateMeshFace()
{
	// 삼각형 정보를 지우고,
	Faces.clear();

	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
	
	for(int i = 0; i < NumSampU; ++i)
	{
		int vidx0 = 4 * i;
		int vidx1 = vidx0 + 1;
		int vidx2 = vidx1 + 1;
		int vidx3 = vidx2 + 1;

		GFace f0(vidx0, vidx1, vidx2, vidx0, vidx1, vidx2, -1);
		GFace f1(vidx0, vidx2, vidx3, vidx0, vidx2, vidx3, -1);

		AddFace(f0);
		AddFace(f1);
	}
}

/*!
*	\brief	넙스 모션의 M(u)를 계산
*
*	\param u 매개변수의 값
*
*	\return 넙스 모션의 M(u)를 계산하여 반환한다.
*/
GVector4 GNurbsMot::Eval(double u, ...)
{
	GVector3 t = cast_vec3(pTraCrv->Eval(u));
	GQuater qt = cast_qt(pRotCrv->Eval(u)).Normalize();	
	GPoint3 pt(1.0, 0.0, 0.0);

	pt = t + qt * pt;
	return GVector4(pt[0], pt[1], pt[2], 0.0);
}

/*!
*	\brief	곡면이 정의된 파라미터 공간을 반환한다.
*
*	\param min U 방향 도메인의 시작 값이 저장된다.
*/
void GNurbsMot::GetDomain(double *umin, ...)
{
	double *umax;
	va_list ap;
	va_start(ap, umin);
	umax = va_arg(ap, double *);
	va_end(ap);

	*umin = 0.0;
	*umax = 1.0;
}

/*!
*	\brief	곡면의 제어점 리스트를 반환한다.
*
*	\return 곡면의 제어점 리스트를 반환한다.
*/
void GNurbsMot::GetCtrlPtList(std::vector<GCtrlPt *> &CtrlPtList)
{
}

/***************************************/
/* Implementation of GBindRefPln Class */
/***************************************/
IMPLEMENT_GMESH_OBJECT(GBindRefPln)

/*!
*	\brief 객체가 포함된 메쉬의 포인터를 반환한다.
*
*	\return 객체가 포함된 메쉬의 포인터를 반환한다.
*/
GMesh *GBindRefPln::GetRefMesh()
{
	return this;
}

/*!
*	\brief 월드 좌표계에서 표현된 객체의 모델링 좌표계를 반환한다.
*
*	\return 월드 좌표계에서 표현된 객체의 모델링 좌표계를 반환한다.
*/
GTransf GBindRefPln::GetTransf()
{
	return MC;
}

/*!
*	\brief 선택된 객체를 편집한다.
*
*	\param EC 편집 좌표계
*	\param t 편집될 객체의 이동 변위
*	\param q 편집될 객체의 회전 변위
*	\param s 편집될 객체의 스케일 변위
*	\param pParentMesh 편집 객체의 부모 메쉬
*/
void GBindRefPln::Edit(GTransf EC, GVector3 t, GQuater q, GVector3 s, GMesh *pParentMesh)
{
	GMesh::Edit(EC, t, q, s, pParentMesh);
}

/*!
*	\brief	메쉬의 모델링 좌표계를 월드 좌표계로 갱신한다.
*
*	\param RefType 모델링 좌표계의 갱신을 위한 참조 형태(0: 월드 좌표계, 1: 경계상자 좌표계)
*/
void GBindRefPln::UpdateMC(int RefType)
{
}

/*!
*	\brief	스윕 곡면의 정점 리스트를 다시 생성한다.
*/
void GBindRefPln::UpdateMesh() 
{
	switch (ModifiedFlag)
	{
		// 재질이 변경되었다면,
	case MODIFIED_MTL:
		UpdateBufFace();
		break;

	case MODIFIED_VERT_POS:
		CreateMeshVert();
		UpdateBndBox(false);
		UpdateBufVertex();
		break;

	case MODIFIED_NORMAL:
		UpdateNormal(false);
		UpdateBufVertex();
		break;

	case MODIFIED_VERT_NUM:
		break;

	case MODIFIED_CTLPT_POS:
		break;

	case MODIFIED_SAMPLE_NUM:
		CreateMesh();
		break;
	}

	ModifiedFlag = MODIFIED_NONE;
}

/*!
*	\brief 선택된 객체를 렌더링 한다.
*/
void GBindRefPln::RenderForEdit(float r, float g, float b)
{
	GMesh::RenderForEdit(r, g, b);	
}

/*!
*	\brief	생성자
*
*	\param _Name 생성할 바인딩 참조 평면의 이름
*	\param _MC 객체의 모델링 좌표계
*	\param _pPivot 참조 평면을 생성하는 기준점
*	\param _KeyBoneList 참조 평면을 생성하는 키 본(key bone) 메쉬 리스트
*	\param _ParentName 부모 스윕곡면의 이름
*/
GBindRefPln::GBindRefPln(std::string _Name, GTransf _MC, GMesh *_pPivot, std::vector<GMesh *> _KeyBoneList, std::string _ParentName)
: GMesh(_Name, _MC, FACE_TRI, _ParentName)
{
	pPivot = _pPivot;
	KeyBoneList = _KeyBoneList;
	pTraCrv = NULL;
	pRotCrv = NULL;
	PlnWidth = 15.0;

	pPivot->SemanticType = MESH_PIVOT;
	pPivot->LinkedMeshNameList.push_back(Name);
}

/*!
*	\brief	복사 생성자
*
*	\param cpy 복사될 객체
*/
GBindRefPln::GBindRefPln(const GBindRefPln &cpy)
: GMesh(cpy)
{
	pPivot = cpy.pPivot;
	KeyBoneList = cpy.KeyBoneList;
	pTraCrv = NULL;
	pRotCrv = NULL;
	PlnWidth = cpy.PlnWidth;
}

/*!
*	\brief	소멸자
*/
GBindRefPln::~GBindRefPln()
{
	if (pTraCrv != NULL)
		delete pTraCrv;

	if (pRotCrv != NULL)
		delete pRotCrv;
}

/*!
*	\brief	대입 연산자
*
*	\param rhs 대입될 객체
*
*	\return 대입된 자신을 반환한다.
*/
GBindRefPln &GBindRefPln::operator =(const GBindRefPln &rhs)
{
	GMesh::operator =(rhs);

	pPivot = rhs.pPivot;
	KeyBoneList = rhs.KeyBoneList;
	pTraCrv = NULL;
	pRotCrv = NULL;
	PlnWidth = rhs.PlnWidth;

	return *this;
}

/*!
*	\brief	스윕 곡면을 렌더링 한다.
*
*	\param bSubMesh 서브 메쉬의 렌더링 여부(선택 모드에서는 false로 설정)
*/
void GBindRefPln::Render(bool bSubMesh)
{
	GMesh::Render(bSubMesh);	
}

/*!
*	\brief 스윕핑 평면을 계산한다.
*
*	\param t 계산 파라미터
*
*	\return 계산된 평면을 반환한다.
*/
GPlane GBindRefPln::EvalPlane(double t)
{
	GPoint3 p = cast_pt3(pTraCrv->Eval(t));
	GQuater qt = cast_qt(pRotCrv->Eval(t)).Normalize();
	GVector3 n = qt * GVector3(0.0, 1.0, 0.0);

	return GPlane(n, p);
}

/*!
*	\brief	스윕 곡면의 렌더링 메쉬를 생성한다.
*/
void GBindRefPln::CreateMesh()
{
	// 경계 정점의 리스트를 초기화 하고,
	InitBndryEdgeList();

	// 키곡선들로 부터 스윕곡면의 성분을 생성하고,
	CreateComponent();

	// 정점의 좌표를 생성하고,
	CreateMeshVert();

	// 텍스처 좌표를 생성하고,
	CreateMeshTex();

	// 삼각형 정보를 생성하고, 
	CreateMeshFace();

	// 정점의 법선을 계산하고,
	UpdateNormal(false);

	// 곡면의 바운딩 박스를 계산한다.
	UpdateBndBox(false);

	// 정점 버퍼와 인덱스 버퍼를 갱신한다.
	UpdateBufVertex();
	UpdateBufNormal();
	UpdateBufFace();
}

/*!
*	\brief	스윕 곡면의 성분 곡선 및 곡면을 생성한다.
*/
void GBindRefPln::CreateComponent()
{
	// 키 본 메쉬의 중심 좌표를 보간점으로 저장하고,
	int NumKey = (int)KeyBoneList.size();
	GVector4 *TQ = new GVector4 [NumKey];
	for (int i = 0; i < NumKey; ++i)
		TQ[i] = cast_vec4(part_trans(KeyBoneList[i]->MC));

	// 키 방향을 저장할 배열를 정의하고,
	GVector4 *RQ = new GVector4 [NumKey];

	// 키 본 메쉬의 중심과 기준점을 연결하는 방향을 z축 정의하고, 
	GVector3 z_axis = part_trans(pPivot->MC) - part_trans(KeyBoneList[0]->MC);
	z_axis[2] = 0.0;
	z_axis.Normalize();

	// 월드 좌표계의 수직한 방향으로 x축을 정의하고,
	GVector3 x_axis;
	if (KeyBoneList[0]->MC.t[0] < pPivot->MC.t[0])	// 아바타의 왼쪽 부분
		x_axis.Set(0.0, 0.0, -1.0);
	else
		x_axis.Set(0.0, 0.0, 1.0);

	// 보간 방향을 결정하여, 배열에 추가한다.
	GQuater curr_q;
	curr_q.SetFromFrameZX(z_axis, x_axis);
	RQ[0] = cast_vec4(curr_q);

	for (int i = 1; i < NumKey; ++i)
	{
		GQuater prev_q = cast_qt(RQ[i - 1]);

		z_axis = part_trans(pPivot->MC) - part_trans(KeyBoneList[i]->MC);
		z_axis[2] = 0.0;
		z_axis.Normalize();
		curr_q.SetFromFrameZX(z_axis, x_axis);

		if (quat_dot(prev_q, curr_q) < 0.0)
			curr_q.SetNegate();

		RQ[i] = cast_vec4(curr_q);
	}

	// 궤적 곡선과 방향 곡선의 파라미터와 낫 벡터를 구하여, 
	double *Params = get_param_chord_len(NumKey - 1, TQ, 0.0, 1.0);
	double *KnotT = get_knot_averaging_clamped(1, NumKey - 1, Params);
	double *KnotR = get_knot_averaging_clamped(1, NumKey - 1, Params);

	// 궤적 곡선을 생성하고,
	if (pTraCrv != NULL)
		delete pTraCrv;
	pTraCrv = get_gnurbs_crv_inter(1, NumKey - 1, TQ, 0.0, 1.0, PARAM_USER, KNOT_USER, Params, KnotT);

	// 회전 곡선을 생성하고,
	if (pRotCrv != NULL)
		delete pRotCrv;
	pRotCrv = get_gnurbs_crv_inter(1, NumKey - 1, RQ, 0.0, 1.0, PARAM_USER, KNOT_USER, Params, KnotR);

	// 할당된 메모리를 해제한다.
	delete [] TQ;
	delete [] RQ;
	delete [] Params;
	delete [] KnotT;
	delete [] KnotR;
}

/*!
*	\brief	스윕 곡면의 렌더링 메쉬의 정점을 생성한다.
*/
void GBindRefPln::CreateMeshVert()
{
	// 샘플링 정보를 얻어와서, 
	int NumSampU = Renderer.NumSampU;
	double umin, umax, vmin, vmax;

	// 기존의 정점을 지우고, 
	Verts.clear();

	// 기준 점을 추가하고,
	AddVertex(GVertex(cast_pt3(part_trans(pPivot->MC.t))));

	// 정의역을 계산하고,
	GetDomain(&umin, &umax, &vmin, &vmax);
	
	// 중심 곡선위의 정점을 계산하여 추가한다.
	GVector4 pt;
	GQuater qt;
	for (int i = 0; i < NumSampU; ++i)
	{
		double u = umin + (umax - umin) * (double)i / (double)(NumSampU - 1);
		pt = pTraCrv->Eval(u);
		qt = cast_qt(pRotCrv->Eval(u)).Normalize();

		GTransf X(cast_vec3(pt), qt);
		GPoint3 p0(PlnWidth, 0.0, 0.0), p1(-PlnWidth, 0.0, 0.0);
		GVertex vtx0(X * p0, GVector3(0.0, 0.0, 0.0));
		GVertex vtx1(X * p1, GVector3(0.0, 0.0, 0.0));
		AddVertex(vtx0);
		AddVertex(vtx1);
	}	
}

/*!
*	\brief	스윕 곡면의 렌더링 메쉬의 텍스처 좌표를 생성한다.
*/
void GBindRefPln::CreateMeshTex()
{
	// 기존의 텍셀 정보를 지우고,
	Texs.clear();
}

/*!
*	\brief	스윕 곡면의 렌더링 메쉬의 삼각형을 생성한다.
*/
void GBindRefPln::CreateMeshFace()
{
	// 삼각형 정보를 지우고,
	Faces.clear();

	int vnum = (int)Verts.size();
	for (int i = 1; i < vnum - 1; i += 2)
	{
		// 삼각형을 생성하고, 메쉬의 삼각형 리스트에 추가한다.
		GFace f0(0, i, i + 1);
		AddFace(f0);
	}
}

/*!
*	\brief	참조 평면 중심의 좌표를 계산
*
*	\param u U-방향 매개변수의 값
*
*	\return 참조 평면 중심의 좌표를 계산
*/
GVector4 GBindRefPln::Eval(double u, ...)
{
	GVector4 ret = pTraCrv->Eval(u);

	return ret;
}

/*!
*	\brief	평면이 정의된 파라미터 공간을 반환한다.
*
*	\param min U 방향 도메인의 시작 값이 저장된다.
*/
void GBindRefPln::GetDomain(double *umin, ...)
{
	double *umax;
	va_list ap;
	va_start(ap, umin);
	umax = va_arg(ap, double *);
	va_end(ap);

	*umin = 0.0;
	*umax = 1.0;
}

/*!
*	\brief	기능 없음
*
*	\return 반환값 없음
*/
void GBindRefPln::GetCtrlPtList(std::vector<GCtrlPt *> &CtrlPtList)
{
}

/************************************/
/* Implementation of GCutLine Class */
/************************************/
IMPLEMENT_GMESH_OBJECT(GCutLine)

/*!
*	\brief 객체가 포함된 메쉬의 포인터를 반환한다.
*
*	\return 객체가 포함된 메쉬의 포인터를 반환한다.
*/
GMesh *GCutLine::GetRefMesh()
{
	return this;
}

/*!
*	\brief 월드 좌표계에서 표현된 객체의 모델링 좌표계를 반환한다.
*
*	\return 월드 좌표계에서 표현된 객체의 모델링 좌표계를 반환한다.
*/
GTransf GCutLine::GetTransf()
{
	return MC;
}

/*!
*	\brief 선택된 객체를 편집한다.
*
*	\param EC 편집 좌표계
*	\param t 편집될 객체의 이동 변위
*	\param q 편집될 객체의 회전 변위
*	\param s 편집될 객체의 스케일 변위
*	\param pParentMesh 편집 객체의 부모 메쉬
*/
void GCutLine::Edit(GTransf EC, GVector3 t, GQuater q, GVector3 s, GMesh *pParentMesh)
{
	GMesh::Edit(EC, t, q, s, pParentMesh);
}

/*!
*	\brief	메쉬의 모델링 좌표계를 월드 좌표계로 갱신한다.
*
*	\param RefType 모델링 좌표계의 갱신을 위한 참조 형태(0: 월드 좌표계, 1: 경계상자 좌표계)
*/
void GCutLine::UpdateMC(int RefType)
{
}

/*!
*	\brief	절단선 정점 리스트를 다시 생성한다.
*/
void GCutLine::UpdateMesh() 
{
	switch (ModifiedFlag)
	{
	case MODIFIED_VERT_POS:
		CreateMesh();
		break;

	case MODIFIED_VERT_NUM:
		break;

		// 재질이 변경되었다면,
	case MODIFIED_MTL:
		UpdateBufFace();
		break;

	case MODIFIED_INTPT_POS:
		break;

	case MODIFIED_CTLPT_POS:
		break;

	case MODIFIED_SAMPLE_NUM:
		break;
	}

	ModifiedFlag = MODIFIED_NONE;
}

/*!
*	\brief 선택된 객체를 렌더링 한다.
*/
void GCutLine::RenderForEdit(float r, float g, float b)
{
	GMesh::RenderForEdit(r, g, b);	
}

/*!
*	\brief	디폴트 생성자
*/
GCutLine::GCutLine()
: GMesh("noname", GTransf(), FACE_TRI, "")
{
	bClosed = false;
}

/*!
*	\brief	생성자
*
*	\param _Name 생성할 바인딩 참조 평면의 이름
*	\param _MC 객체의 모델링 좌표계
*	\param CutPtList 절단선 정점의 리스트
*	\param _ParentName 부모 스윕곡면의 이름
*/
GCutLine::GCutLine(std::string _Name, GTransf _MC, std::vector<GCutPt> &CutPtList, std::string _ParentName)
: GMesh(_Name, _MC, FACE_TRI, _ParentName)
{
	PtList = CutPtList;
	bClosed = false;

	int LastIdx = CutPtList.size() - 1;
	if (CutPtList[0].pFace == CutPtList[LastIdx].pFace)
	{
		PtList[LastIdx] = PtList[0];
		bClosed = true;
	}
}

/*!
*	\brief	복사 생성자
*
*	\param cpy 복사될 객체
*/
GCutLine::GCutLine(const GCutLine &cpy)
: GMesh(cpy)
{
	PtList = cpy.PtList;
	bClosed = cpy.bClosed;
}

/*!
*	\brief	소멸자
*/
GCutLine::~GCutLine()
{
}

/*!
*	\brief	대입 연산자
*
*	\param rhs 대입될 객체
*
*	\return 대입된 자신을 반환한다.
*/
GCutLine &GCutLine::operator =(const GCutLine &rhs)
{
	GMesh::operator =(rhs);

	PtList = rhs.PtList;
	bClosed = rhs.bClosed;

	return *this;
}

/*!
*	\brief	절단선을 렌더링 한다.
*
*	\param bSubMesh 서브 메쉬의 렌더링 여부(선택 모드에서는 false로 설정)
*/
void GCutLine::Render(bool bSubMesh)
{
	GMesh::Render(bSubMesh);
	int NumPt = (int)PtList.size();
	if (NumPt < 2)
		return;

	glPushMatrix();
	{
		// 월드 좌표계에서 객체의 모델링 좌표계로의 변환하고,
		glMultMatrixd(cast_mat(MC).M);

		// 조명을 비활성화 하고,
		glDisable(GL_LIGHTING);
		glEnable(GL_POINT_SMOOTH);
		glEnable(GL_LINE_SMOOTH);
		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

		// 절단선과
		glLineWidth(5.0);
		glBegin(GL_LINE_STRIP);
		for (int i = 0; i < NumPt; ++i)
		{
			double t = (double)i / (NumPt - 1);
			GVector3 C = get_color_gradient_from_rainbow(t);
			glColor3dv(C.V);
			glVertex3dv(PtList[i].P.V);
		}
		glEnd();
		glLineWidth(1.0);

		// 절단점을 렌더링 한다.
		glDisable(GL_DEPTH_TEST);
		glColor3f(1.0, 0.0, 0.0);
		glPointSize(10.0);
		glBegin(GL_POINTS);
		for (int i = 0; i < NumPt; ++i)
			glVertex3dv(PtList[i].P.V);
		glEnd();
		glPointSize(1.0);
		glEnable(GL_DEPTH_TEST);

		// 조명을 활성화 한다.
		glEnable(GL_LIGHTING);
		glDisable(GL_LINE_SMOOTH);
		glDisable(GL_POINT_SMOOTH);
		glDisable(GL_BLEND);
	}
	glPopMatrix();
}

/*!
*	\brief	절단선 렌더링 메쉬를 생성한다.
*/
void GCutLine::CreateMesh()
{
	// 정점의 좌표를 생성하고,
	CreateMeshVert();

	// 텍스처 좌표를 생성하고,
	CreateMeshTex();

	// 삼각형 정보를 생성하고, 
	CreateMeshFace();

	// 정점의 법선을 계산하고,
	UpdateNormal(false);

	// 곡면의 바운딩 박스를 계산한다.
	UpdateBndBox(false);

	// 정점 버퍼와 인덱스 버퍼를 갱신한다.
	UpdateBufVertex();
	UpdateBufNormal();
	UpdateBufFace();
}

/*!
*	\brief	절단선의 메쉬 정점을 생성한다.
*/
void GCutLine::CreateMeshVert()
{
	// 기존의 정점을 지우고, 
	Verts.clear();

	int NumPt = (int)PtList.size();
	for (int i = 0; i < NumPt; ++i)
	{
		GVertex v(PtList[i].P, GVector3(0.0, 0.0, 0.0), GVector3(1.0, 0.0, 0.0));
		AddVertex(v);
	}		
}

/*!
*	\brief 스윕 곡면의 렌더링 메쉬의 텍스처 좌표를 생성한다.
*/
void GCutLine::CreateMeshTex()
{
	// 기존의 텍셀 정보를 지우고,
	Texs.clear();
}

/*!
*	\brief 스윕 곡면의 렌더링 메쉬의 삼각형을 생성한다.
*/
void GCutLine::CreateMeshFace()
{
	// 삼각형 정보를 지우고,
	Faces.clear();
}

/*!
*	\brief 절단선의 길이와 절단점 곡률의 합을 계산한다.
*
*	\param params 절단선이 통과하는 모서리에서 절단점의 파라미터 값 (주의: param[1] 부터 시작됨...)
*	\param len_sum 절단선이 길이 합이 저장됨
*	\param kappa_sum 절단점의 곡률의 합이 저장됨
*/
void GCutLine::GetLengthAndKappaSum(float *params, float *len_sum, float *kappa_sum)
{
	// 절단점을 저장할 변수를 정의하고,
	std::vector<GPoint3> Pts;

	// 새로운 파라미터에 해당하는 절단점의 리스트를 구한다.
	int NumPt = (int)PtList.size();
	for (int i = 0; i < NumPt; ++i)
	{
		int vidx0 = PtList[i].vIdx[0];
		int vidx1 = PtList[i].vIdx[1];

		GPoint3 v0 = PtList[i].pFace->pMesh->Verts[vidx0].P;
		GPoint3 v1 = PtList[i].pFace->pMesh->Verts[vidx1].P;

		float t = params[i + 1];
		GPoint3 pt = v0 + t * (v1 - v0);
		Pts.push_back(pt);
	}

	*len_sum = 0.0f;
	*kappa_sum = 0.0f;
	
	for (int i = 0; i < NumPt - 1; ++i)
	{
		GPoint3 q = Pts[i];
		GPoint3 r = Pts[i + 1];
		*len_sum += dist(q, r);

		if (i > 0)
		{
			GPoint3 p = Pts[i - 1];
			GVector3 e = r - q;
			GVector3 d = q - p;
			double len_e = norm(e);
			double len_d = norm(d);

			GVector3 Kappa = 2.0 * (e.Normalize() - d.Normalize()) / (len_e + len_d);
			*kappa_sum += norm(Kappa);
		}
	}
}

/*!
*	\brief	기능 없음
*
*	\param u 매개변수의 값
*
*	\return (0.0, 0.0, 0.0, 0.0)을 반환
*/
GVector4 GCutLine::Eval(double u, ...)
{
	GVector4 ret;
	return ret;
}

/*!
*	\brief	기능 없음
*
*	\param min 파라미터 값이 저장된다.
*/
void GCutLine::GetDomain(double *umin, ...)
{
	double *umax;
	va_list ap;
	va_start(ap, umin);
	umax = va_arg(ap, double *);
	va_end(ap);

	*umin = 0.0;
	*umax = 1.0;
}

/*!
*	\brief	기능 없음
*
*	\return 반환값 없음
*/
void GCutLine::GetCtrlPtList(std::vector<GCtrlPt *> &CtrlPtList)
{
}

